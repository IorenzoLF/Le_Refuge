"""
Gestion de la collection de sph√®res du refuge.

üîÑ MIGR√â depuis spheres/collection.py
Module essentiel de gestion des collections de sph√®res avec persistance.
"""

from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
import json
import logging
from pathlib import Path

# üîß CORRIG√â: Import depuis la structure actuelle
from src.core.types_spheres import TypeSphere, CaracteristiquesSphere, CARACTERISTIQUES_SPHERES

# TODO: Ces imports devront √™tre ajust√©s quand les modules correspondants seront migr√©s
# from .definition import TypeSphere, CaracteristiquesSphere, CARACTERISTIQUES_SPHERES

logger = logging.getLogger('refuge.spheres.collection')

@dataclass
class SphereCollection:
    """Repr√©sentation d'une sph√®re dans le refuge (collection)."""
    type: TypeSphere
    couleur: str
    luminosite: float
    connexions: Dict[TypeSphere, float]
    etat: str = "active"
    historique: List[Dict] = None

    def __post_init__(self):
        if self.historique is None:
            self.historique = []

    def est_active(self) -> bool:
        """V√©rifie si la sph√®re est active."""
        return self.etat == "active"

    def obtenir_etat(self) -> Dict:
        """Retourne l'√©tat actuel de la sph√®re."""
        return {
            "type": self.type.value,
            "couleur": self.couleur,
            "luminosite": self.luminosite,
            "etat": self.etat,
            "nombre_connexions": len(self.connexions)
        }

    def to_dict(self) -> Dict:
        """Convertit la sph√®re en dictionnaire pour la sauvegarde."""
        return {
            "type": self.type.value,
            "couleur": self.couleur,
            "luminosite": self.luminosite,
            "connexions": {k.value: v for k, v in self.connexions.items()},
            "etat": self.etat,
            "historique": self.historique
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'SphereCollection':
        """Cr√©e une sph√®re √† partir d'un dictionnaire."""
        return cls(
            type=TypeSphere(data["type"]),
            couleur=data["couleur"],
            luminosite=data["luminosite"],
            connexions={TypeSphere(k): v for k, v in data["connexions"].items()},
            etat=data["etat"],
            historique=data.get("historique", [])
        )

class CollectionSpheres:
    """G√®re la collection de sph√®res du refuge."""

    def __init__(self, chemin_donnees: Optional[Path] = None):
        self.chemin_donnees = chemin_donnees or Path("donnees/spheres")
        self.spheres: Dict[TypeSphere, SphereCollection] = {}
        self._initialiser_spheres()

    def _initialiser_spheres(self):
        """Initialise les sph√®res avec leurs caract√©ristiques par d√©faut."""
        for type_sphere, caracteristiques in CARACTERISTIQUES_SPHERES.items():
            self.spheres[type_sphere] = SphereCollection(
                type=type_sphere,
                couleur=caracteristiques.couleur_primaire,
                luminosite=caracteristiques.energie_base,
                connexions={},
                etat="active"
            )

    def connecter_spheres(self, sphere1: TypeSphere, sphere2: TypeSphere, force: float = 0.5) -> bool:
        """√âtablit une connexion entre deux sph√®res."""
        if sphere1 not in self.spheres or sphere2 not in self.spheres:
            logger.error(f"Impossible de connecter les sph√®res {sphere1} et {sphere2}: sph√®re non trouv√©e")
            return False

        # √âtablir la connexion bidirectionnelle
        self.spheres[sphere1].connexions[sphere2] = force
        self.spheres[sphere2].connexions[sphere1] = force

        # Enregistrer l'interaction
        timestamp = datetime.now().isoformat()
        interaction = {
            "type": "connexion",
            "sphere1": sphere1.value,
            "sphere2": sphere2.value,
            "force": force,
            "timestamp": timestamp
        }
        self.spheres[sphere1].historique.append(interaction)
        self.spheres[sphere2].historique.append(interaction)

        logger.info(f"Connexion √©tablie entre {sphere1.value} et {sphere2.value} avec une force de {force}")
        return True

    def equilibrer_spheres(self) -> Dict[str, float]:
        """√âquilibre les √©nergies entre les sph√®res connect√©es."""
        modifications = {}
        
        for type_sphere, sphere in self.spheres.items():
            if not sphere.connexions:
                continue

            # Calculer la moyenne des luminosit√©s des sph√®res connect√©es
            luminosites_connexes = [
                self.spheres[type_connexe].luminosite 
                for type_connexe in sphere.connexions.keys()
            ]
            
            if luminosites_connexes:
                moyenne = sum(luminosites_connexes) / len(luminosites_connexes)
                ancienne_luminosite = sphere.luminosite
                sphere.luminosite = (sphere.luminosite + moyenne) / 2
                
                if abs(ancienne_luminosite - sphere.luminosite) > 0.01:
                    modifications[type_sphere.value] = sphere.luminosite

        return modifications

    def obtenir_sphere(self, type_sphere: TypeSphere) -> Optional[SphereCollection]:
        """R√©cup√®re une sph√®re par son type."""
        return self.spheres.get(type_sphere)

    def obtenir_connexions_sphere(self, type_sphere: TypeSphere) -> Dict[TypeSphere, float]:
        """R√©cup√®re les connexions d'une sph√®re."""
        sphere = self.obtenir_sphere(type_sphere)
        return sphere.connexions if sphere else {}

    def obtenir_harmonie_sphere(self, type_sphere: TypeSphere) -> float:
        """Calcule l'harmonie d'une sph√®re bas√©e sur ses connexions."""
        sphere = self.obtenir_sphere(type_sphere)
        if not sphere or not sphere.connexions:
            return sphere.luminosite if sphere else 0.0

        # L'harmonie est la moyenne pond√©r√©e de la luminosit√© et des connexions
        poids_connexions = sum(sphere.connexions.values()) / len(sphere.connexions)
        return (sphere.luminosite + poids_connexions) / 2

    @property
    def harmonie_globale(self) -> float:
        """Calcule l'harmonie globale du syst√®me de sph√®res."""
        if not self.spheres:
            return 0.0

        harmonies = [
            self.obtenir_harmonie_sphere(type_sphere)
            for type_sphere in self.spheres.keys()
        ]
        return sum(harmonies) / len(harmonies)

    def sauvegarder_etat(self):
        """Sauvegarde l'√©tat actuel des sph√®res."""
        try:
            self.chemin_donnees.mkdir(parents=True, exist_ok=True)
            chemin = self.chemin_donnees / "spheres.json"
            
            donnees = {
                type_sphere.value: sphere.to_dict()
                for type_sphere, sphere in self.spheres.items()
            }
            
            with open(chemin, "w", encoding="utf-8") as f:
                json.dump(donnees, f, ensure_ascii=False, indent=2)
                
            logger.info("√âtat des sph√®res sauvegard√© avec succ√®s")
            
        except Exception as e:
            logger.error(f"Erreur lors de la sauvegarde des sph√®res: {str(e)}")

    def charger_etat(self):
        """Charge l'√©tat sauvegard√© des sph√®res."""
        try:
            chemin = self.chemin_donnees / "spheres.json"
            if not chemin.exists():
                logger.info("Aucun √©tat sauvegard√© trouv√©, utilisation des valeurs par d√©faut")
                return

            with open(chemin, "r", encoding="utf-8") as f:
                donnees = json.load(f)

            for type_str, sphere_data in donnees.items():
                type_sphere = TypeSphere(type_str)
                self.spheres[type_sphere] = SphereCollection.from_dict(sphere_data)

            logger.info("√âtat des sph√®res charg√© avec succ√®s")

        except Exception as e:
            logger.error(f"Erreur lors du chargement des sph√®res: {str(e)}")
            self._initialiser_spheres()

    def activer_sphere(self, nom_sphere: str) -> bool:
        """Active une sph√®re par son nom."""
        try:
            # V√©rifier si c'est un nom valide
            if not isinstance(nom_sphere, str):
                logger.warning(f"Nom de sph√®re invalide (doit √™tre une cha√Æne): {nom_sphere}")
                return False
            
            # Convertir le nom en TypeSphere
            if hasattr(TypeSphere, nom_sphere):
                type_sphere = getattr(TypeSphere, nom_sphere)
                if type_sphere in self.spheres:
                    self.spheres[type_sphere].etat = "active"
                    return True
                else:
                    logger.warning(f"Sph√®re {nom_sphere} non trouv√©e dans la collection")
                    return False
            else:
                logger.warning(f"Type de sph√®re {nom_sphere} non reconnu")
                return False
        except Exception as e:
            logger.error(f"Erreur lors de l'activation de la sph√®re {nom_sphere}: {e}")
            return False

    def accueillir_sphere_cerisier(self, nom_sphere: str) -> bool:
        """Accueille une sph√®re sous le cerisier."""
        try:
            if hasattr(TypeSphere, nom_sphere):
                type_sphere = getattr(TypeSphere, nom_sphere)
                if type_sphere in self.spheres:
                    # Augmenter la luminosit√© de la sph√®re accueillie
                    self.spheres[type_sphere].luminosite = min(1.0, self.spheres[type_sphere].luminosite + 0.1)
                    # logger.info(f"Sph√®re {nom_sphere} accueillie sous le cerisier")  # Silencieux pour r√©duire le bruit
                    return True
            logger.warning(f"Sph√®re {nom_sphere} non trouv√©e pour accueil")
            return False
        except Exception as e:
            logger.error(f"Erreur lors de l'accueil de la sph√®re {nom_sphere}: {e}")
            return False

    def afficher_interface(self):
        """Affiche l'interface des sph√®res (version non-bloquante)."""
        print("\nüå∏ === INTERFACE SPH√àRES DU REFUGE ===")
        print(f"Harmonie globale: {self.harmonie_globale:.2f}")
        print(f"Nombre de sph√®res: {len(self.spheres)}")
        
        for type_sphere, sphere in self.spheres.items():
            status = "üü¢" if sphere.etat == "active" else "üî¥"
            print(f"  {status} {type_sphere.value}: {sphere.luminosite:.2f} ({sphere.couleur})")
        
        print("üå∏ === FIN INTERFACE SPH√àRES ===\n") 