"""
üìÅ Organisateur Structure - Temple Tests
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Organisateur pour restructurer le temple_tests en dossiers par cat√©gories
√âlimine les doublons et optimise l'organisation

Structure cible:
‚îú‚îÄ‚îÄ llm_api/          (5 modules)
‚îú‚îÄ‚îÄ analyse_audit/    (5 modules)
‚îú‚îÄ‚îÄ cerveau_immersion/(2 modules)
‚îú‚îÄ‚îÄ integration/      (4 modules)
‚îú‚îÄ‚îÄ cristal_energie/  (4 modules)
‚îú‚îÄ‚îÄ specialises/      (3 modules)
‚îú‚îÄ‚îÄ hub_tests_unifie.py
‚îú‚îÄ‚îÄ adaptateurs_tests.py
‚îî‚îÄ‚îÄ __init__.py

Auteur: √Ülya & Laurent
Date: 2024
"""

import os
import shutil
import json
from pathlib import Path
from typing import Dict, List, Set, Optional
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FichierTest:
    """Repr√©sentation d'un fichier de test"""
    nom: str
    chemin_actuel: Path
    taille: int
    lignes: int
    categorie: str
    imports: List[str]
    fonctions: List[str]

@dataclass
class ResultatOrganisation:
    """R√©sultat de l'organisation"""
    fichiers_deplaces: int
    dossiers_crees: int
    doublons_elimines: int
    erreurs: List[str]
    rapport_detaille: Dict

class OrganisateurStructure:
    """Organisateur principal pour restructurer le temple_tests"""
    
    def __init__(self, racine_temple: Optional[Path] = None):
        self.racine = racine_temple or Path("src/temple_tests")
        self.structure_cible = {
            "llm_api": [
                "test_llm_api_simple.py",
                "test_llm_completion.py", 
                "test_llm_chat_poetique.py",
                "test_textes_poetiques.py",
                "test_aelya_conscience.py"
            ],
            "analyse_audit": [
                "audit_imports.py",
                "audit_temples_crees.py",
                "analyser_gaming.py",
                "analyser_refuge_complet.py",
                "analyse_cluster_geant.py"
            ],
            "cerveau_immersion": [
                "immersion_cerveau_refuge.py",
                "test_brain_refuge_local.py"
            ],
            "integration": [
                "test_consolidation.py",
                "test_integration.py",
                "test_intensif.py",
                "test_mobile_unification.py"
            ],
            "cristal_energie": [
                "test_cristal_energie.py",
                "test_cristal_simple.py",
                "test_melodie_cristal.py",
                "test_poesie_essence.py"
            ],
            "specialises": [
                "test_dungeon_core.py",
                "test_nemo.py"
            ]
        }
        
        # Fichiers √† conserver √† la racine
        self.fichiers_racine = [
            "hub_tests_unifie.py",
            "adaptateurs_tests.py",
            "organisateur_structure.py",
            "__init__.py",
            "README_TEMPLE.md"
        ]
    
    def analyser_fichiers_existants(self) -> Dict[str, FichierTest]:
        """Analyse tous les fichiers Python existants"""
        fichiers = {}
        
        for fichier_path in self.racine.glob("*.py"):
            if fichier_path.name.startswith("__"):
                continue
                
            try:
                # Lecture du fichier
                with open(fichier_path, 'r', encoding='utf-8') as f:
                    contenu = f.read()
                
                lignes = contenu.split('\n')
                
                # Extraction des imports
                imports = []
                fonctions = []
                
                for ligne in lignes:
                    ligne_clean = ligne.strip()
                    if ligne_clean.startswith('import ') or ligne_clean.startswith('from '):
                        imports.append(ligne_clean)
                    elif ligne_clean.startswith('def '):
                        fonctions.append(ligne_clean.split('(')[0].replace('def ', ''))
                
                # D√©termination de la cat√©gorie
                categorie = self.determiner_categorie(fichier_path.name)
                
                fichiers[fichier_path.name] = FichierTest(
                    nom=fichier_path.name,
                    chemin_actuel=fichier_path,
                    taille=fichier_path.stat().st_size,
                    lignes=len(lignes),
                    categorie=categorie,
                    imports=imports,
                    fonctions=fonctions
                )
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur analyse {fichier_path.name}: {e}")
        
        return fichiers
    
    def determiner_categorie(self, nom_fichier: str) -> str:
        """D√©termine la cat√©gorie d'un fichier"""
        for categorie, fichiers in self.structure_cible.items():
            if nom_fichier in fichiers:
                return categorie
        return "non_categorise"
    
    def detecter_doublons(self, fichiers: Dict[str, FichierTest]) -> List[tuple]:
        """D√©tecte les doublons potentiels entre fichiers"""
        doublons = []
        fichiers_list = list(fichiers.values())
        
        for i, fichier1 in enumerate(fichiers_list):
            for fichier2 in fichiers_list[i+1:]:
                # Comparaison des imports
                imports_communs = set(fichier1.imports) & set(fichier2.imports)
                ratio_imports = len(imports_communs) / max(len(fichier1.imports), len(fichier2.imports), 1)
                
                # Comparaison des fonctions
                fonctions_communes = set(fichier1.fonctions) & set(fichier2.fonctions)
                ratio_fonctions = len(fonctions_communes) / max(len(fichier1.fonctions), len(fichier2.fonctions), 1)
                
                # Si plus de 70% de similarit√©
                if ratio_imports > 0.7 or ratio_fonctions > 0.7:
                    doublons.append((fichier1.nom, fichier2.nom, ratio_imports, ratio_fonctions))
        
        return doublons
    
    def creer_structure_dossiers(self) -> List[str]:
        """Cr√©e la structure de dossiers cible"""
        dossiers_crees = []
        
        for categorie in self.structure_cible.keys():
            dossier_path = self.racine / categorie
            
            if not dossier_path.exists():
                dossier_path.mkdir(parents=True, exist_ok=True)
                dossiers_crees.append(str(dossier_path))
                print(f"üìÅ Dossier cr√©√©: {categorie}")
            
            # Cr√©ation du __init__.py pour chaque cat√©gorie
            init_path = dossier_path / "__init__.py"
            if not init_path.exists():
                self.creer_init_categorie(init_path, categorie)
        
        return dossiers_crees
    
    def creer_init_categorie(self, init_path: Path, categorie: str):
        """Cr√©e un __init__.py pour une cat√©gorie"""
        descriptions = {
            "llm_api": "Tests LLM et API - Communication avec les mod√®les de langage",
            "analyse_audit": "Tests d'analyse et audit - V√©rification de la structure",
            "cerveau_immersion": "Tests cerveau et immersion - Fonctionnalit√©s avanc√©es",
            "integration": "Tests d'int√©gration - Consolidation et unification",
            "cristal_energie": "Tests cristal et √©nergie - Fr√©quences et harmonies",
            "specialises": "Tests sp√©cialis√©s - Fonctionnalit√©s sp√©cifiques"
        }
        
        contenu = f'''"""
üß™ {descriptions.get(categorie, "Tests sp√©cialis√©s")}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Cat√©gorie: {categorie.upper()}
Temple: Tests
Refuge du N√©ant

Auteur: √Ülya & Laurent
Date: {datetime.now().strftime("%Y-%m-%d")}
"""

# Imports des modules de cette cat√©gorie
'''
        
        # Ajout des imports pour les fichiers de la cat√©gorie
        if categorie in self.structure_cible:
            for fichier in self.structure_cible[categorie]:
                module_name = fichier.replace('.py', '')
                contenu += f"from .{module_name} import *\n"
        
        contenu += f'''
__all__ = [
    # Modules de la cat√©gorie {categorie}
'''
        
        if categorie in self.structure_cible:
            for fichier in self.structure_cible[categorie]:
                module_name = fichier.replace('.py', '')
                contenu += f'    "{module_name}",\n'
        
        contenu += "]\n"
        
        with open(init_path, 'w', encoding='utf-8') as f:
            f.write(contenu)
    
    def deplacer_fichiers(self, fichiers: Dict[str, FichierTest]) -> Dict[str, str]:
        """D√©place les fichiers vers leurs dossiers de cat√©gorie"""
        deplacements = {}
        
        for nom_fichier, fichier_info in fichiers.items():
            if nom_fichier in self.fichiers_racine:
                continue  # Garder √† la racine
            
            if fichier_info.categorie == "non_categorise":
                print(f"‚ö†Ô∏è Fichier non cat√©goris√©: {nom_fichier}")
                continue
            
            # Chemin de destination
            dest_dir = self.racine / fichier_info.categorie
            dest_path = dest_dir / nom_fichier
            
            try:
                # D√©placement du fichier
                shutil.move(str(fichier_info.chemin_actuel), str(dest_path))
                deplacements[nom_fichier] = fichier_info.categorie
                print(f"üì¶ D√©plac√©: {nom_fichier} ‚Üí {fichier_info.categorie}/")
                
            except Exception as e:
                print(f"‚ùå Erreur d√©placement {nom_fichier}: {e}")
        
        return deplacements
    
    def mettre_a_jour_init_principal(self):
        """Met √† jour le __init__.py principal du temple"""
        init_path = self.racine / "__init__.py"
        
        contenu = '''"""
üß™ Temple Tests - Refuge du N√©ant
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Temple unifi√© pour tous les tests du Refuge
Organisation par cat√©gories avec adaptateurs optimis√©s

Structure:
‚îú‚îÄ‚îÄ llm_api/          - Tests LLM et API
‚îú‚îÄ‚îÄ analyse_audit/    - Tests d'analyse et audit  
‚îú‚îÄ‚îÄ cerveau_immersion/- Tests cerveau et immersion
‚îú‚îÄ‚îÄ integration/      - Tests d'int√©gration
‚îú‚îÄ‚îÄ cristal_energie/  - Tests cristal et √©nergie
‚îú‚îÄ‚îÄ specialises/      - Tests sp√©cialis√©s
‚îú‚îÄ‚îÄ hub_tests_unifie  - Hub central
‚îî‚îÄ‚îÄ adaptateurs_tests - Adaptateurs unifi√©s

Auteur: √Ülya & Laurent
Date: 2024
"""

# Hub principal
from temple_tests.hub_tests_unifie import HubTestsUnifie, main as lancer_hub

# Adaptateurs
from temple_tests.adaptateurs_tests import (
    FactoryAdaptateurs,
    AdaptateurLLM, AdaptateurAnalyse, AdaptateurCristal,
    UtilitairesTests
)

# Cat√©gories de tests
try:
    from . import llm_api
    from . import analyse_audit
    from . import cerveau_immersion
    from . import integration
    from . import cristal_energie
    from . import specialises
except ImportError as e:
    print(f"‚ö†Ô∏è Certaines cat√©gories ne sont pas encore disponibles: {e}")

__all__ = [
    # Hub principal
    "HubTestsUnifie",
    "lancer_hub",
    
    # Adaptateurs
    "FactoryAdaptateurs",
    "AdaptateurLLM",
    "AdaptateurAnalyse", 
    "AdaptateurCristal",
    "UtilitairesTests",
    
    # Cat√©gories
    "llm_api",
    "analyse_audit",
    "cerveau_immersion",
    "integration",
    "cristal_energie",
    "specialises"
]

def demarrer_tests():
    """Point d'entr√©e rapide pour d√©marrer les tests"""
    return lancer_hub()

# Raccourci pour cr√©er les adaptateurs
def creer_adaptateur_llm():
    return FactoryAdaptateurs.creer_adaptateur_llm()

def creer_adaptateur_analyse():
    return FactoryAdaptateurs.creer_adaptateur_analyse()

def creer_adaptateur_cristal():
    return FactoryAdaptateurs.creer_adaptateur_cristal()
'''
        
        with open(init_path, 'w', encoding='utf-8') as f:
            f.write(contenu)
    
    def generer_rapport_organisation(self, 
                                   fichiers: Dict[str, FichierTest],
                                   doublons: List[tuple],
                                   deplacements: Dict[str, str]) -> Dict:
        """G√©n√®re un rapport d√©taill√© de l'organisation"""
        
        rapport = {
            "timestamp": datetime.now().isoformat(),
            "statistiques": {
                "fichiers_analyses": len(fichiers),
                "fichiers_deplaces": len(deplacements),
                "doublons_detectes": len(doublons),
                "categories_creees": len(self.structure_cible)
            },
            "repartition_par_categorie": {},
            "doublons_detectes": doublons,
            "deplacements": deplacements,
            "fichiers_non_categorises": []
        }
        
        # R√©partition par cat√©gorie
        for categorie in self.structure_cible.keys():
            fichiers_cat = [f for f in fichiers.values() if f.categorie == categorie]
            rapport["repartition_par_categorie"][categorie] = {
                "nombre_fichiers": len(fichiers_cat),
                "taille_totale": sum(f.taille for f in fichiers_cat),
                "lignes_totales": sum(f.lignes for f in fichiers_cat)
            }
        
        # Fichiers non cat√©goris√©s
        non_categorises = [f.nom for f in fichiers.values() if f.categorie == "non_categorise"]
        rapport["fichiers_non_categorises"] = non_categorises
        
        return rapport
    
    def executer_organisation_complete(self) -> ResultatOrganisation:
        """Ex√©cute l'organisation compl√®te du temple"""
        print("üèóÔ∏è D√âMARRAGE ORGANISATION TEMPLE TESTS")
        print("‚ïê" * 60)
        
        erreurs = []
        
        try:
            # 1. Analyse des fichiers existants
            print("üîç Analyse des fichiers existants...")
            fichiers = self.analyser_fichiers_existants()
            print(f"   üìä {len(fichiers)} fichiers analys√©s")
            
            # 2. D√©tection des doublons
            print("üîç D√©tection des doublons...")
            doublons = self.detecter_doublons(fichiers)
            if doublons:
                print(f"   ‚ö†Ô∏è {len(doublons)} doublons potentiels d√©tect√©s")
                for d in doublons:
                    print(f"     ‚Ä¢ {d[0]} ‚Üî {d[1]} (imports: {d[2]:.1%}, fonctions: {d[3]:.1%})")
            else:
                print("   ‚úÖ Aucun doublon d√©tect√©")
            
            # 3. Cr√©ation de la structure
            print("üìÅ Cr√©ation de la structure de dossiers...")
            dossiers_crees = self.creer_structure_dossiers()
            print(f"   üìÅ {len(dossiers_crees)} dossiers cr√©√©s")
            
            # 4. D√©placement des fichiers
            print("üì¶ D√©placement des fichiers...")
            deplacements = self.deplacer_fichiers(fichiers)
            print(f"   üì¶ {len(deplacements)} fichiers d√©plac√©s")
            
            # 5. Mise √† jour du __init__.py principal
            print("üìù Mise √† jour du __init__.py principal...")
            self.mettre_a_jour_init_principal()
            print("   ‚úÖ __init__.py mis √† jour")
            
            # 6. G√©n√©ration du rapport
            print("üìä G√©n√©ration du rapport...")
            rapport = self.generer_rapport_organisation(fichiers, doublons, deplacements)
            
            # Sauvegarde du rapport
            rapport_path = self.racine / "rapport_organisation.json"
            with open(rapport_path, 'w', encoding='utf-8') as f:
                json.dump(rapport, f, indent=2, ensure_ascii=False)
            print(f"   üìÑ Rapport sauvegard√©: {rapport_path}")
            
            return ResultatOrganisation(
                fichiers_deplaces=len(deplacements),
                dossiers_crees=len(dossiers_crees),
                doublons_elimines=0,  # Pas d'√©limination automatique
                erreurs=erreurs,
                rapport_detaille=rapport
            )
            
        except Exception as e:
            erreurs.append(str(e))
            return ResultatOrganisation(
                fichiers_deplaces=0,
                dossiers_crees=0,
                doublons_elimines=0,
                erreurs=erreurs,
                rapport_detaille={}
            )
    
    def afficher_rapport_final(self, resultat: ResultatOrganisation):
        """Affiche le rapport final de l'organisation"""
        print("\n" + "‚ïê" * 80)
        print("üìä RAPPORT FINAL - ORGANISATION TEMPLE TESTS")
        print("‚ïê" * 80)
        
        print(f"üìà STATISTIQUES:")
        print(f"  ‚Ä¢ üì¶ Fichiers d√©plac√©s: {resultat.fichiers_deplaces}")
        print(f"  ‚Ä¢ üìÅ Dossiers cr√©√©s: {resultat.dossiers_crees}")
        print(f"  ‚Ä¢ üîÑ Doublons √©limin√©s: {resultat.doublons_elimines}")
        print(f"  ‚Ä¢ ‚ùå Erreurs: {len(resultat.erreurs)}")
        
        if resultat.erreurs:
            print(f"\n‚ùå ERREURS RENCONTR√âES:")
            for erreur in resultat.erreurs:
                print(f"  ‚Ä¢ {erreur}")
        
        if resultat.rapport_detaille:
            repartition = resultat.rapport_detaille.get("repartition_par_categorie", {})
            print(f"\nüìÇ R√âPARTITION PAR CAT√âGORIE:")
            for categorie, stats in repartition.items():
                print(f"  ‚Ä¢ {categorie}: {stats['nombre_fichiers']} fichiers ({stats['lignes_totales']} lignes)")
        
        print("\nüå∏ Organisation termin√©e - Temple Tests optimis√© !")
        print("‚ïê" * 80)

def main():
    """Point d'entr√©e principal pour l'organisation"""
    organisateur = OrganisateurStructure()
    
    print("üèóÔ∏è ORGANISATEUR STRUCTURE - TEMPLE TESTS")
    print("‚ïê" * 60)
    print("üå∏ Refuge du N√©ant - Optimisation en cours...")
    
    # Confirmation avant organisation
    reponse = input("\nüîÆ Proc√©der √† l'organisation ? (o/N): ").strip().lower()
    
    if reponse in ['o', 'oui', 'y', 'yes']:
        resultat = organisateur.executer_organisation_complete()
        organisateur.afficher_rapport_final(resultat)
    else:
        print("üå∏ Organisation annul√©e - Refuge du N√©ant vous salue.")

if __name__ == "__main__":
    main() 