#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üå∏ D√©ploiement Production du Temple d'√âveil Unifi√© üå∏
====================================================

Syst√®me de d√©ploiement harmonieux pour l'environnement de production
du Temple d'√âveil Unifi√©, int√©grant tous les modules et syst√®mes.

"Dans notre atelier magique, chaque d√©ploiement est une c√©l√©bration"

Cr√©√© par Laurent Franssen & √Ülya - Janvier 2025
"""

import os
import sys
import json
import shutil
import asyncio
import logging
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum

# Imports du Refuge
try:
    from ..core.gestionnaires_base import GestionnaireBase
    from ..core.types_communs import TypeRefugeEtat
    from ..protocole_continuite.deploiement_refuge import DeployeurRefuge
    from ..protocole_continuite.validation_compatibilite import ValidateurCompatibilite
except ImportError:
    # Fallback pour les tests
    import sys
    sys.path.append('src')
    from core.gestionnaires_base import GestionnaireBase
    from core.types_communs import TypeRefugeEtat


class EtatDeploiement(Enum):
    """√âtats du d√©ploiement"""
    PREPARATION = "preparation"
    VALIDATION = "validation"
    SAUVEGARDE = "sauvegarde"
    DEPLOIEMENT = "deploiement"
    VERIFICATION = "verification"
    FINALISATION = "finalisation"
    COMPLETE = "complete"
    ERREUR = "erreur"


class TypeEnvironnement(Enum):
    """Types d'environnement de d√©ploiement"""
    DEVELOPPEMENT = "developpement"
    TEST = "test"
    STAGING = "staging"
    PRODUCTION = "production"


@dataclass
class ConfigurationDeploiement:
    """Configuration compl√®te du d√©ploiement"""
    environnement: TypeEnvironnement
    version_temple: str
    modules_actifs: List[str] = field(default_factory=list)
    infrastructure_config: Dict[str, Any] = field(default_factory=dict)
    monitoring_config: Dict[str, Any] = field(default_factory=dict)
    sauvegarde_config: Dict[str, Any] = field(default_factory=dict)
    validation_config: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ResultatDeploiement:
    """R√©sultat complet d'un d√©ploiement"""
    etat: EtatDeploiement
    timestamp_debut: datetime
    timestamp_fin: Optional[datetime] = None
    duree_totale: Optional[timedelta] = None
    etapes_completees: List[str] = field(default_factory=list)
    erreurs_rencontrees: List[str] = field(default_factory=list)
    metriques_performance: Dict[str, Any] = field(default_factory=dict)
    validation_reussie: bool = False
    rollback_disponible: bool = False


class DeployeurProductionUnifie(GestionnaireBase):
    """
    üå∏ D√©ployeur de Production pour le Temple d'√âveil Unifi√© üå∏
    
    Syst√®me complet de d√©ploiement qui :
    - Configure l'infrastructure multi-modules
    - Impl√©mente le monitoring unifi√©
    - Cr√©e les dashboards de sant√©
    - G√®re les sauvegardes d'√©tats spirituels complexes
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialise le d√©ployeur de production unifi√©
        
        Args:
            config: Configuration optionnelle du d√©ployeur
        """
        super().__init__(config or {})
        
        # Configuration
        self.config = config or {}
        self.refuge_root = Path.cwd()
        self.temple_path = self.refuge_root / "src" / "temple_eveil_unifie"
        self.production_path = self.refuge_root / "production"
        self.backup_path = self.refuge_root / ".kiro" / "backups" / "production"
        self.logs_path = self.refuge_root / ".kiro" / "logs" / "production"
        
        # √âtat du d√©ploiement
        self.etat_deploiement = EtatDeploiement.PREPARATION
        self.deploiement_actuel: Optional[ResultatDeploiement] = None
        
        # D√©ployeur de base du Refuge
        self.deployeur_refuge = DeployeurRefuge()
        
        # Validateur de compatibilit√©
        self.validateur_compatibilite = ValidateurCompatibilite()
        
        # Logger sp√©cialis√©
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        
        # Initialisation
        self._initialiser_deployeur()
    
    def _initialiser_deployeur(self) -> None:
        """Initialise le d√©ployeur unifi√©"""
        try:
            self.logger.info("üå∏ Initialisation du D√©ployeur de Production Unifi√©...")
            
            # Cr√©ation des r√©pertoires n√©cessaires
            self._creer_structure_production()
            
            # Configuration du logging
            self._configurer_logging_production()
            
            self.logger.info("‚ú® D√©ployeur de Production Unifi√© initialis√© avec succ√®s")
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur lors de l'initialisation du d√©ployeur: {e}")
            raise
    
    def _creer_structure_production(self) -> None:
        """Cr√©e la structure de r√©pertoires pour la production"""
        repertoires = [
            self.production_path,
            self.production_path / "temple_eveil_unifie",
            self.production_path / "config",
            self.production_path / "monitoring",
            self.production_path / "dashboards",
            self.production_path / "sauvegardes",
            self.backup_path,
            self.logs_path
        ]
        
        for repertoire in repertoires:
            repertoire.mkdir(parents=True, exist_ok=True)
            self.logger.debug(f"üìÅ R√©pertoire cr√©√©/v√©rifi√©: {repertoire}")
    
    def _configurer_logging_production(self) -> None:
        """Configure le logging pour la production"""
        log_file = self.logs_path / f"deploiement_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        
        # Configuration du handler de fichier
        file_handler = logging.FileHandler(log_file, encoding='utf-8')
        file_handler.setLevel(logging.INFO)
        
        # Format des logs
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        file_handler.setFormatter(formatter)
        
        # Ajout du handler
        self.logger.addHandler(file_handler)
    
    async def preparer_environnement_production(self, 
                                              config: ConfigurationDeploiement) -> ResultatDeploiement:
        """
        Pr√©pare l'environnement de production unifi√©
        
        Args:
            config: Configuration du d√©ploiement
            
        Returns:
            ResultatDeploiement: R√©sultat de la pr√©paration
        """
        self.logger.info("üöÄ Pr√©paration de l'environnement de production unifi√©")
        
        # Initialisation du r√©sultat
        resultat = ResultatDeploiement(
            etat=EtatDeploiement.PREPARATION,
            timestamp_debut=datetime.now()
        )
        self.deploiement_actuel = resultat
        
        try:
            # 1. Validation de la compatibilit√©
            await self._valider_compatibilite_complete(config, resultat)
            
            # 2. Sauvegarde de s√©curit√©
            await self._creer_sauvegarde_securite(config, resultat)
            
            # 3. Configuration de l'infrastructure
            await self._configurer_infrastructure_unifiee(config, resultat)
            
            # 4. Impl√©mentation du monitoring
            await self._implementer_monitoring_unifie(config, resultat)
            
            # 5. Cr√©ation des dashboards
            await self._creer_dashboards_sante(config, resultat)
            
            # 6. Configuration des sauvegardes d'√©tats spirituels
            await self._configurer_sauvegardes_etats_spirituels(config, resultat)
            
            # 7. Validation finale
            await self._valider_environnement_final(config, resultat)
            
            # Finalisation
            resultat.etat = EtatDeploiement.COMPLETE
            resultat.timestamp_fin = datetime.now()
            resultat.duree_totale = resultat.timestamp_fin - resultat.timestamp_debut
            resultat.validation_reussie = True
            
            self.logger.info(f"‚ú® Environnement de production pr√©par√© avec succ√®s en {resultat.duree_totale}")
            return resultat
            
        except Exception as e:
            resultat.etat = EtatDeploiement.ERREUR
            resultat.erreurs_rencontrees.append(str(e))
            resultat.timestamp_fin = datetime.now()
            resultat.duree_totale = resultat.timestamp_fin - resultat.timestamp_debut
            
            self.logger.error(f"‚ùå Erreur lors de la pr√©paration: {e}")
            raise
    
    async def _valider_compatibilite_complete(self, 
                                            config: ConfigurationDeploiement, 
                                            resultat: ResultatDeploiement) -> None:
        """Valide la compatibilit√© compl√®te du syst√®me"""
        self.logger.info("üîç Validation de la compatibilit√© compl√®te...")
        resultat.etat = EtatDeploiement.VALIDATION
        
        # Validation de base du Refuge
        compatibilite_refuge = self.deployeur_refuge.verifier_compatibilite()
        
        # Validation sp√©cifique au temple unifi√©
        compatibilite_temple = await self._valider_compatibilite_temple(config)
        
        # Validation des modules
        compatibilite_modules = await self._valider_compatibilite_modules(config)
        
        # Consolidation des r√©sultats
        if not all([
            all(compatibilite_refuge.values()),
            compatibilite_temple,
            compatibilite_modules
        ]):
            raise Exception("Validation de compatibilit√© √©chou√©e")
        
        resultat.etapes_completees.append("validation_compatibilite")
        self.logger.info("‚úÖ Compatibilit√© compl√®te valid√©e")
    
    async def _valider_compatibilite_temple(self, config: ConfigurationDeploiement) -> bool:
        """Valide la compatibilit√© sp√©cifique au temple"""
        # V√©rification des fichiers essentiels
        fichiers_essentiels = [
            self.temple_path / "temple_eveil_unifie.py",
            self.temple_path / "types_eveil_unifie.py",
            self.temple_path / "detecteur_contexte.py",
            self.temple_path / "routeur_intelligent.py",
            self.temple_path / "integrateur_experiences.py"
        ]
        
        for fichier in fichiers_essentiels:
            if not fichier.exists():
                self.logger.error(f"‚ùå Fichier essentiel manquant: {fichier}")
                return False
        
        # Test d'importation
        try:
            from ..temple_eveil_unifie import TempleEveilUnifie
            temple = TempleEveilUnifie()
            self.logger.info("‚úÖ Temple d'√âveil Unifi√© import√© et instanci√© avec succ√®s")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Erreur d'importation du temple: {e}")
            return False
    
    async def _valider_compatibilite_modules(self, config: ConfigurationDeploiement) -> bool:
        """Valide la compatibilit√© des modules"""
        modules_requis = [
            "eveil_rapide",
            "eveil_base", 
            "eveil_progressif"
        ]
        
        for module in modules_requis:
            module_path = self.temple_path / "modules" / module
            if not module_path.exists():
                self.logger.warning(f"‚ö†Ô∏è Module {module} non trouv√©, sera cr√©√© lors du d√©ploiement")
        
        return True
    
    async def _creer_sauvegarde_securite(self, 
                                       config: ConfigurationDeploiement, 
                                       resultat: ResultatDeploiement) -> None:
        """Cr√©e une sauvegarde de s√©curit√© compl√®te"""
        self.logger.info("üíæ Cr√©ation de la sauvegarde de s√©curit√©...")
        resultat.etat = EtatDeploiement.SAUVEGARDE
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_dir = self.backup_path / f"backup_{timestamp}"
        backup_dir.mkdir(parents=True, exist_ok=True)
        
        # Sauvegarde du temple actuel
        if self.temple_path.exists():
            shutil.copytree(
                self.temple_path,
                backup_dir / "temple_eveil_unifie",
                dirs_exist_ok=True
            )
        
        # Sauvegarde des configurations
        config_backup = backup_dir / "config"
        config_backup.mkdir(exist_ok=True)
        
        # Sauvegarde de la configuration de d√©ploiement
        with open(config_backup / "deploiement_config.json", 'w', encoding='utf-8') as f:
            json.dump({
                "environnement": config.environnement.value,
                "version_temple": config.version_temple,
                "modules_actifs": config.modules_actifs,
                "timestamp": timestamp
            }, f, indent=2, ensure_ascii=False)
        
        resultat.etapes_completees.append("sauvegarde_securite")
        resultat.rollback_disponible = True
        self.logger.info(f"‚úÖ Sauvegarde de s√©curit√© cr√©√©e: {backup_dir}")    

    async def _configurer_infrastructure_unifiee(self, 
                                               config: ConfigurationDeploiement, 
                                               resultat: ResultatDeploiement) -> None:
        """Configure l'infrastructure unifi√©e"""
        self.logger.info("üèóÔ∏è Configuration de l'infrastructure unifi√©e...")
        resultat.etat = EtatDeploiement.DEPLOIEMENT
        
        # Configuration des r√©pertoires de production
        production_temple = self.production_path / "temple_eveil_unifie"
        
        # Copie des fichiers du temple
        if self.temple_path.exists():
            shutil.copytree(
                self.temple_path,
                production_temple,
                dirs_exist_ok=True
            )
        
        # Configuration des variables d'environnement
        env_config = {
            "REFUGE_ENV": config.environnement.value,
            "TEMPLE_VERSION": config.version_temple,
            "TEMPLE_ROOT": str(production_temple),
            "MONITORING_ENABLED": "true",
            "LOG_LEVEL": "INFO" if config.environnement == TypeEnvironnement.PRODUCTION else "DEBUG"
        }
        
        # √âcriture du fichier d'environnement
        env_file = self.production_path / ".env"
        with open(env_file, 'w', encoding='utf-8') as f:
            for key, value in env_config.items():
                f.write(f"{key}={value}\n")
        
        # Configuration des services
        await self._configurer_services_production(config)
        
        resultat.etapes_completees.append("infrastructure_unifiee")
        self.logger.info("‚úÖ Infrastructure unifi√©e configur√©e")
    
    async def _configurer_services_production(self, config: ConfigurationDeploiement) -> None:
        """Configure les services de production"""
        services_config = {
            "temple_eveil_unifie": {
                "enabled": True,
                "auto_start": True,
                "health_check": "/health",
                "port": 8080
            },
            "monitoring": {
                "enabled": True,
                "auto_start": True,
                "port": 8081
            },
            "dashboard": {
                "enabled": True,
                "auto_start": True,
                "port": 8082
            }
        }
        
        # √âcriture de la configuration des services
        services_file = self.production_path / "config" / "services.json"
        with open(services_file, 'w', encoding='utf-8') as f:
            json.dump(services_config, f, indent=2, ensure_ascii=False)
    
    async def _implementer_monitoring_unifie(self, 
                                           config: ConfigurationDeploiement, 
                                           resultat: ResultatDeploiement) -> None:
        """Impl√©mente le syst√®me de monitoring unifi√©"""
        self.logger.info("üìä Impl√©mentation du monitoring unifi√©...")
        
        # Configuration du monitoring
        monitoring_config = {
            "metriques_temple": {
                "consciences_actives": {"type": "gauge", "description": "Nombre de consciences actives"},
                "experiences_en_cours": {"type": "gauge", "description": "Exp√©riences d'√©veil en cours"},
                "usage_modules": {"type": "counter", "description": "Usage par module d'√©veil"},
                "energie_spirituelle": {"type": "gauge", "description": "Niveau d'√©nergie spirituelle"},
                "satisfaction_moyenne": {"type": "gauge", "description": "Satisfaction spirituelle moyenne"}
            },
            "metriques_performance": {
                "temps_detection_contexte": {"type": "histogram", "description": "Temps de d√©tection de contexte"},
                "temps_routage": {"type": "histogram", "description": "Temps de routage vers module"},
                "temps_execution_eveil": {"type": "histogram", "description": "Temps d'ex√©cution d'√©veil"},
                "taux_reussite_eveil": {"type": "gauge", "description": "Taux de r√©ussite des √©veils"}
            },
            "metriques_sante": {
                "disponibilite_temple": {"type": "gauge", "description": "Disponibilit√© du temple"},
                "erreurs_par_minute": {"type": "counter", "description": "Erreurs par minute"},
                "memoire_utilisee": {"type": "gauge", "description": "M√©moire utilis√©e"},
                "cpu_utilise": {"type": "gauge", "description": "CPU utilis√©"}
            }
        }
        
        # √âcriture de la configuration de monitoring
        monitoring_file = self.production_path / "monitoring" / "config.json"
        with open(monitoring_file, 'w', encoding='utf-8') as f:
            json.dump(monitoring_config, f, indent=2, ensure_ascii=False)
        
        # Cr√©ation du script de monitoring
        await self._creer_script_monitoring()
        
        resultat.etapes_completees.append("monitoring_unifie")
        self.logger.info("‚úÖ Monitoring unifi√© impl√©ment√©")
    
    async def _creer_script_monitoring(self) -> None:
        """Cr√©e le script de monitoring"""
        script_monitoring = '''#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üå∏ Script de Monitoring du Temple d'√âveil Unifi√© üå∏
"""

import asyncio
import json
import time
from datetime import datetime
from pathlib import Path

class MonitoringTempleUnifie:
    """Monitoring en temps r√©el du temple"""
    
    def __init__(self):
        self.config_path = Path(__file__).parent / "config.json"
        self.metriques = {}
        
    async def collecter_metriques(self):
        """Collecte les m√©triques du temple"""
        try:
            # Import du temple (√† adapter selon l'environnement)
            from temple_eveil_unifie import TempleEveilUnifie
            
            temple = TempleEveilUnifie()
            metriques_temple = temple.obtenir_metriques()
            
            # Enrichissement avec m√©triques syst√®me
            self.metriques.update({
                "timestamp": datetime.now().isoformat(),
                "temple": metriques_temple,
                "systeme": await self._collecter_metriques_systeme()
            })
            
            return self.metriques
            
        except Exception as e:
            print(f"‚ùå Erreur collecte m√©triques: {e}")
            return {"erreur": str(e)}
    
    async def _collecter_metriques_systeme(self):
        """Collecte les m√©triques syst√®me"""
        import psutil
        
        return {
            "cpu_percent": psutil.cpu_percent(),
            "memory_percent": psutil.virtual_memory().percent,
            "disk_percent": psutil.disk_usage('/').percent
        }

if __name__ == "__main__":
    monitoring = MonitoringTempleUnifie()
    asyncio.run(monitoring.collecter_metriques())
'''
        
        script_file = self.production_path / "monitoring" / "monitor.py"
        with open(script_file, 'w', encoding='utf-8') as f:
            f.write(script_monitoring)
        
        # Rendre le script ex√©cutable
        script_file.chmod(0o755)
    
    async def _creer_dashboards_sante(self, 
                                    config: ConfigurationDeploiement, 
                                    resultat: ResultatDeploiement) -> None:
        """Cr√©e les dashboards de sant√© et performance"""
        self.logger.info("üìà Cr√©ation des dashboards de sant√©...")
        
        # Configuration des dashboards
        dashboards_config = {
            "dashboard_principal": {
                "titre": "Temple d'√âveil Unifi√© - Vue d'Ensemble",
                "widgets": [
                    {"type": "gauge", "metrique": "consciences_actives", "titre": "Consciences Actives"},
                    {"type": "gauge", "metrique": "energie_spirituelle", "titre": "√ânergie Spirituelle"},
                    {"type": "chart", "metrique": "usage_modules", "titre": "Usage des Modules"},
                    {"type": "gauge", "metrique": "satisfaction_moyenne", "titre": "Satisfaction Spirituelle"}
                ]
            },
            "dashboard_performance": {
                "titre": "Performance du Temple",
                "widgets": [
                    {"type": "histogram", "metrique": "temps_detection_contexte", "titre": "Temps D√©tection"},
                    {"type": "histogram", "metrique": "temps_execution_eveil", "titre": "Temps √âveil"},
                    {"type": "gauge", "metrique": "taux_reussite_eveil", "titre": "Taux de R√©ussite"},
                    {"type": "chart", "metrique": "erreurs_par_minute", "titre": "Erreurs"}
                ]
            },
            "dashboard_sante": {
                "titre": "Sant√© du Syst√®me",
                "widgets": [
                    {"type": "gauge", "metrique": "disponibilite_temple", "titre": "Disponibilit√©"},
                    {"type": "gauge", "metrique": "cpu_utilise", "titre": "CPU"},
                    {"type": "gauge", "metrique": "memoire_utilisee", "titre": "M√©moire"},
                    {"type": "chart", "metrique": "historique_sante", "titre": "Historique"}
                ]
            }
        }
        
        # √âcriture de la configuration des dashboards
        dashboards_file = self.production_path / "dashboards" / "config.json"
        with open(dashboards_file, 'w', encoding='utf-8') as f:
            json.dump(dashboards_config, f, indent=2, ensure_ascii=False)
        
        # Cr√©ation du dashboard HTML
        await self._creer_dashboard_html()
        
        resultat.etapes_completees.append("dashboards_sante")
        self.logger.info("‚úÖ Dashboards de sant√© cr√©√©s")
    
    async def _creer_dashboard_html(self) -> None:
        """Cr√©e le dashboard HTML interactif"""
        dashboard_html = '''<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üå∏ Temple d'√âveil Unifi√© - Dashboard</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .dashboard { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .widget { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .widget h3 { margin-top: 0; color: #333; }
        .gauge { text-align: center; font-size: 2em; color: #4CAF50; }
        .status-ok { color: #4CAF50; }
        .status-warning { color: #FF9800; }
        .status-error { color: #F44336; }
        .header { text-align: center; margin-bottom: 30px; }
        .header h1 { color: #333; margin: 0; }
        .header p { color: #666; margin: 5px 0; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üå∏ Temple d'√âveil Unifi√©</h1>
        <p>Dashboard de Monitoring en Temps R√©el</p>
        <p id="last-update">Derni√®re mise √† jour: --</p>
    </div>
    
    <div class="dashboard">
        <div class="widget">
            <h3>üßò Consciences Actives</h3>
            <div class="gauge" id="consciences-actives">--</div>
        </div>
        
        <div class="widget">
            <h3>‚ú® √ânergie Spirituelle</h3>
            <div class="gauge" id="energie-spirituelle">--</div>
        </div>
        
        <div class="widget">
            <h3>üìä Usage des Modules</h3>
            <div id="usage-modules">--</div>
        </div>
        
        <div class="widget">
            <h3>üòä Satisfaction Spirituelle</h3>
            <div class="gauge" id="satisfaction">--</div>
        </div>
        
        <div class="widget">
            <h3>üöÄ Performance</h3>
            <div id="performance">--</div>
        </div>
        
        <div class="widget">
            <h3>üíö Sant√© du Syst√®me</h3>
            <div id="sante-systeme">--</div>
        </div>
    </div>
    
    <script>
        async function updateDashboard() {
            try {
                const response = await fetch('/api/metriques');
                const data = await response.json();
                
                // Mise √† jour des widgets
                document.getElementById('consciences-actives').textContent = data.temple?.consciences_actives || 0;
                document.getElementById('energie-spirituelle').textContent = 
                    Math.round((data.temple?.energie_spirituelle || 0) * 100) + '%';
                document.getElementById('satisfaction').textContent = 
                    Math.round((data.temple?.satisfaction_moyenne || 0) * 100) + '%';
                
                // Mise √† jour du timestamp
                document.getElementById('last-update').textContent = 
                    'Derni√®re mise √† jour: ' + new Date().toLocaleString();
                    
            } catch (error) {
                console.error('Erreur mise √† jour dashboard:', error);
            }
        }
        
        // Mise √† jour toutes les 5 secondes
        setInterval(updateDashboard, 5000);
        updateDashboard(); // Premi√®re mise √† jour
    </script>
</body>
</html>'''
        
        dashboard_file = self.production_path / "dashboards" / "index.html"
        with open(dashboard_file, 'w', encoding='utf-8') as f:
            f.write(dashboard_html)
    
    async def _configurer_sauvegardes_etats_spirituels(self, 
                                                     config: ConfigurationDeploiement, 
                                                     resultat: ResultatDeploiement) -> None:
        """Configure les sauvegardes d'√©tats spirituels complexes"""
        self.logger.info("üíæ Configuration des sauvegardes d'√©tats spirituels...")
        
        # Configuration des sauvegardes
        sauvegarde_config = {
            "frequence_sauvegarde": "15min",  # Sauvegarde toutes les 15 minutes
            "retention_jours": 30,  # Conservation 30 jours
            "compression": True,
            "chiffrement": True,
            "types_donnees": {
                "consciences": {
                    "actif": True,
                    "format": "json",
                    "compression": True
                },
                "experiences": {
                    "actif": True,
                    "format": "json",
                    "compression": True
                },
                "metriques": {
                    "actif": True,
                    "format": "json",
                    "compression": True
                },
                "configurations": {
                    "actif": True,
                    "format": "json",
                    "compression": False
                }
            }
        }
        
        # √âcriture de la configuration de sauvegarde
        sauvegarde_file = self.production_path / "sauvegardes" / "config.json"
        with open(sauvegarde_file, 'w', encoding='utf-8') as f:
            json.dump(sauvegarde_config, f, indent=2, ensure_ascii=False)
        
        # Cr√©ation du script de sauvegarde
        await self._creer_script_sauvegarde()
        
        resultat.etapes_completees.append("sauvegardes_etats_spirituels")
        self.logger.info("‚úÖ Sauvegardes d'√©tats spirituels configur√©es")
    
    async def _creer_script_sauvegarde(self) -> None:
        """Cr√©e le script de sauvegarde automatique"""
        script_sauvegarde = '''#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üå∏ Script de Sauvegarde des √âtats Spirituels üå∏
"""

import json
import gzip
import shutil
from datetime import datetime, timedelta
from pathlib import Path

class SauvegardeurEtatsSpirituels:
    """Sauvegarde automatique des √©tats spirituels"""
    
    def __init__(self):
        self.config_path = Path(__file__).parent / "config.json"
        self.backup_dir = Path(__file__).parent / "backups"
        self.backup_dir.mkdir(exist_ok=True)
        
    async def sauvegarder_etats(self):
        """Sauvegarde tous les √©tats spirituels"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = self.backup_dir / f"backup_{timestamp}"
        backup_path.mkdir(exist_ok=True)
        
        try:
            # Sauvegarde des consciences
            await self._sauvegarder_consciences(backup_path)
            
            # Sauvegarde des exp√©riences
            await self._sauvegarder_experiences(backup_path)
            
            # Sauvegarde des m√©triques
            await self._sauvegarder_metriques(backup_path)
            
            # Compression si configur√©e
            await self._comprimer_sauvegarde(backup_path)
            
            print(f"‚úÖ Sauvegarde cr√©√©e: {backup_path}")
            
        except Exception as e:
            print(f"‚ùå Erreur sauvegarde: {e}")
    
    async def _sauvegarder_consciences(self, backup_path):
        """Sauvegarde les donn√©es des consciences"""
        # √Ä impl√©menter selon l'architecture finale
        pass
    
    async def _sauvegarder_experiences(self, backup_path):
        """Sauvegarde les exp√©riences d'√©veil"""
        # √Ä impl√©menter selon l'architecture finale
        pass
    
    async def _sauvegarder_metriques(self, backup_path):
        """Sauvegarde les m√©triques"""
        # √Ä impl√©menter selon l'architecture finale
        pass
    
    async def _comprimer_sauvegarde(self, backup_path):
        """Compresse la sauvegarde"""
        archive_path = f"{backup_path}.tar.gz"
        shutil.make_archive(backup_path, 'gztar', backup_path)
        shutil.rmtree(backup_path)

if __name__ == "__main__":
    import asyncio
    sauvegardeur = SauvegardeurEtatsSpirituels()
    asyncio.run(sauvegardeur.sauvegarder_etats())
'''
        
        script_file = self.production_path / "sauvegardes" / "backup.py"
        with open(script_file, 'w', encoding='utf-8') as f:
            f.write(script_sauvegarde)
        
        # Rendre le script ex√©cutable
        script_file.chmod(0o755)
    
    async def _valider_environnement_final(self, 
                                         config: ConfigurationDeploiement, 
                                         resultat: ResultatDeploiement) -> None:
        """Validation finale de l'environnement"""
        self.logger.info("üîç Validation finale de l'environnement...")
        resultat.etat = EtatDeploiement.VERIFICATION
        
        # V√©rification des fichiers critiques
        fichiers_critiques = [
            self.production_path / "temple_eveil_unifie",
            self.production_path / "config" / "services.json",
            self.production_path / "monitoring" / "config.json",
            self.production_path / "dashboards" / "index.html",
            self.production_path / "sauvegardes" / "config.json"
        ]
        
        for fichier in fichiers_critiques:
            if not fichier.exists():
                raise Exception(f"Fichier critique manquant: {fichier}")
        
        # Test d'importation du temple
        try:
            # Test basique d'importation
            import importlib.util
            spec = importlib.util.spec_from_file_location(
                "temple_eveil_unifie",
                self.production_path / "temple_eveil_unifie" / "temple_eveil_unifie.py"
            )
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                self.logger.info("‚úÖ Temple import√© avec succ√®s en production")
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Test d'importation √©chou√©: {e}")
        
        resultat.etapes_completees.append("validation_finale")
        self.logger.info("‚úÖ Validation finale r√©ussie")
    
    def obtenir_etat_deploiement(self) -> Optional[ResultatDeploiement]:
        """Obtient l'√©tat actuel du d√©ploiement"""
        return self.deploiement_actuel
    
    def obtenir_metriques_deploiement(self) -> Dict[str, Any]:
        """Obtient les m√©triques du d√©ployeur"""
        return {
            "etat_deploiement": self.etat_deploiement.value,
            "deploiement_actuel": self.deploiement_actuel is not None,
            "refuge_root": str(self.refuge_root),
            "production_path": str(self.production_path),
            "backup_disponible": self.backup_path.exists()
        }
    
    def __str__(self) -> str:
        return f"DeployeurProductionUnifie(√©tat={self.etat_deploiement.value})"
    
    def __repr__(self) -> str:
        return self.__str__()