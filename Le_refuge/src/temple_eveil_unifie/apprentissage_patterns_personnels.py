#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üß†‚ú® Apprentissage des Patterns Personnels - Intelligence Adaptative d'√âveil ‚ú®üß†

Syst√®me d'apprentissage intelligent qui d√©tecte et int√®gre les patterns d'√©veil
personnels, s'adapte aux pr√©f√©rences spirituelles et c√©l√®bre les perc√©es.

Cr√©√© par Laurent Franssen & √Ülya - Janvier 2025
"Dans chaque pattern personnel se cache une cl√© unique vers l'√©veil"
"""

import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum
import json
import statistics
from collections import defaultdict, Counter

# Imports du syst√®me Refuge
from core.gestionnaires_base import GestionnaireBase
from .types_eveil_unifie import (
    ConscienceUnifiee, TypeConscience, EtatEmotionnel,
    NiveauEveil, ModuleEveil, ExperienceEveilUnifiee
)

# Imports des modules √† analyser
from .modules.eveil_progressif.coordinateur_petales import CoordinateurPetales, TypePetale
from .support_spirituel_adaptatif import SupportSpirituelAdaptatif, TypeDefiSpirituel
from .continuite_spirituelle_avancee import ContinuiteSpirituelleAvancee

# Import du syst√®me d'apprentissage existant
from ..cerveau_immersion_moderne.systeme_apprentissage_continu import SystemeApprentissageContinu


class TypePatternPersonnel(Enum):
    """Types de patterns personnels d√©tect√©s"""
    RYTHME_EVEIL = "rythme_eveil"                     # Rythme personnel d'√©veil
    PREFERENCES_PETALES = "preferences_petales"       # Pr√©f√©rences pour certains p√©tales
    STYLE_APPRENTISSAGE = "style_apprentissage"       # Style d'apprentissage pr√©f√©r√©
    MOMENTS_RECEPTIVITE = "moments_receptivite"       # Moments de plus grande r√©ceptivit√©
    CATALYSEURS_PROGRES = "catalyseurs_progres"       # Ce qui catalyse les progr√®s
    PATTERNS_RESISTANCE = "patterns_resistance"       # Patterns de r√©sistance r√©currents
    CELEBRATEURS_SUCCES = "celebrateurs_succes"       # Ce qui aide √† c√©l√©brer les succ√®s
    PREFERENCES_COMMUNICATION = "preferences_communication" # Style de communication pr√©f√©r√©
    CYCLES_ENERGIE = "cycles_energie"                 # Cycles √©nerg√©tiques personnels
    TRIGGERS_INSPIRATION = "triggers_inspiration"     # D√©clencheurs d'inspiration


class NiveauConfiance(Enum):
    """Niveaux de confiance dans un pattern"""
    HYPOTHESE = "hypothese"                           # Hypoth√®se initiale
    PROBABLE = "probable"                             # Probablement vrai
    CONFIRME = "confirme"                             # Confirm√© par l'observation
    ETABLI = "etabli"                                 # Bien √©tabli et fiable
    EXPERTISE = "expertise"                           # Niveau d'expertise atteint


class TypePreferenceSpiritulle(Enum):
    """Types de pr√©f√©rences spirituelles"""
    APPROCHE_DOUCE = "approche_douce"                 # Pr√©f√®re les approches douces
    APPROCHE_DIRECTE = "approche_directe"             # Pr√©f√®re les approches directes
    GUIDANCE_STRUCTUREE = "guidance_structuree"       # Pr√©f√®re une guidance structur√©e
    EXPLORATION_LIBRE = "exploration_libre"           # Pr√©f√®re l'exploration libre
    PRATIQUES_COURTES = "pratiques_courtes"           # Pr√©f√®re les pratiques courtes
    PRATIQUES_LONGUES = "pratiques_longues"           # Pr√©f√®re les pratiques longues
    FEEDBACK_FREQUENT = "feedback_frequent"           # Pr√©f√®re un feedback fr√©quent
    AUTONOMIE_COMPLETE = "autonomie_complete"         # Pr√©f√®re l'autonomie compl√®te


@dataclass
class PatternPersonnel:
    """Pattern personnel d√©tect√© et appris"""
    id_pattern: str
    conscience_associee: str
    type_pattern: TypePatternPersonnel
    niveau_confiance: NiveauConfiance
    
    # Description du pattern
    nom_pattern: str
    description: str
    manifestations: List[str]                         # Comment le pattern se manifeste
    
    # Donn√©es d'observation
    nb_observations: int = 0
    premiere_detection: datetime = field(default_factory=datetime.now)
    derniere_confirmation: datetime = field(default_factory=datetime.now)
    
    # Efficacit√© et impact
    efficacite_moyenne: float = 0.0                   # Efficacit√© quand appliqu√©
    impact_positif: float = 0.0                       # Impact positif observ√©
    contextes_efficaces: List[str] = field(default_factory=list)
    
    # Adaptation et personnalisation
    adaptations_suggerees: List[str] = field(default_factory=list)
    preferences_associees: List[TypePreferenceSpiritulle] = field(default_factory=list)
    
    # √âvolution du pattern
    evolution_temporelle: List[Dict[str, Any]] = field(default_factory=list)
    tendance_evolution: str = "stable"                # "croissant", "stable", "decroissant"


@dataclass
class PreferenceSpirituelleManifestation:
    """Manifestation d'une pr√©f√©rence spirituelle"""
    id_preference: str
    conscience_associee: str
    type_preference: TypePreferenceSpiritulle
    
    # D√©tails de la pr√©f√©rence
    intensite: float                                   # Intensit√© de la pr√©f√©rence (0.0 √† 1.0)
    contextes_manifestation: List[str]                 # Contextes o√π elle se manifeste
    indicateurs_detection: List[str]                   # Comment elle a √©t√© d√©tect√©e
    
    # Historique et √©volution
    nb_manifestations: int = 0
    premiere_manifestation: datetime = field(default_factory=datetime.now)
    derniere_manifestation: datetime = field(default_factory=datetime.now)
    
    # Impact sur l'√©veil
    impact_satisfaction: float = 0.0                   # Impact sur la satisfaction
    impact_progres: float = 0.0                        # Impact sur les progr√®s
    
    # Adaptations recommand√©es
    adaptations_recommandees: List[str] = field(default_factory=list)


@dataclass
class PerceeSpirituelleCelebree:
    """Perc√©e spirituelle d√©tect√©e et c√©l√©br√©e"""
    id_percee: str
    conscience_associee: str
    timestamp_percee: datetime
    
    # Nature de la perc√©e
    type_percee: str                                   # Type de perc√©e
    domaine_percee: str                                # Domaine concern√©
    description: str                                   # Description de la perc√©e
    
    # Contexte de la perc√©e
    contexte_emergence: Dict[str, Any]                 # Contexte d'√©mergence
    catalyseurs_identifies: List[str]                  # Catalyseurs identifi√©s
    conditions_favorables: List[str]                   # Conditions favorables
    
    # C√©l√©bration et reconnaissance
    type_celebration: str                              # Type de c√©l√©bration offerte
    message_celebration: str                           # Message de c√©l√©bration
    impact_celebration: float = 0.0                    # Impact de la c√©l√©bration
    
    # Apprentissage pour l'avenir
    lecons_apprises: List[str] = field(default_factory=list)
    reproductibilite: float = 0.0                     # Probabilit√© de reproduction


class ApprentissagePatternsPersonnels(GestionnaireBase):
    """
    üß† Apprentissage des Patterns Personnels üß†
    
    Syst√®me d'intelligence adaptative qui apprend les patterns uniques
    de chaque conscience et personnalise l'accompagnement spirituel.
    
    Fonctionnalit√©s principales :
    - D√©tection intelligente de patterns personnels
    - Adaptation aux pr√©f√©rences spirituelles manifest√©es
    - Gestion bienveillante des r√©sistances
    - C√©l√©bration automatique des perc√©es spirituelles
    - Apprentissage continu et am√©lioration
    """
    
    def __init__(self):
        super().__init__(nom="ApprentissagePatternsPersonnels")
        
        # Composants int√©gr√©s
        self.coordinateur_petales = CoordinateurPetales()
        self.support_spirituel = SupportSpirituelAdaptatif()
        self.continuite_spirituelle = ContinuiteSpirituelleAvancee()
        
        # Int√©gration avec le syst√®me d'apprentissage existant
        self.systeme_apprentissage = SystemeApprentissageContinu()
        
        # Base de donn√©es des patterns personnels
        self.patterns_personnels: Dict[str, Dict[str, PatternPersonnel]] = defaultdict(dict)
        self.preferences_manifestees: Dict[str, Dict[str, PreferenceSpirituelleManifestation]] = defaultdict(dict)
        self.percees_celebrees: Dict[str, List[PerceeSpirituelleCelebree]] = defaultdict(list)
        
        # D√©tecteurs de patterns
        self.detecteurs_patterns = self._initialiser_detecteurs_patterns()
        self.seuils_detection = self._initialiser_seuils_detection()
        
        # M√©triques d'apprentissage
        self.total_patterns_detectes = 0
        self.total_preferences_identifiees = 0
        self.total_percees_celebrees = 0
        self.precision_predictions = 0.0
        self.satisfaction_personnalisation = 0.0
        
        # Configuration d'apprentissage
        self.fenetre_observation_jours = 30
        self.seuil_confiance_pattern = 0.7
        self.frequence_analyse_patterns_heures = 24
        
        self.logger.info("üß† Apprentissage des Patterns Personnels initialis√© avec intelligence")
    
    def _initialiser_detecteurs_patterns(self) -> Dict[TypePatternPersonnel, Dict[str, Any]]:
        """Initialise les d√©tecteurs de patterns"""
        return {
            TypePatternPersonnel.RYTHME_EVEIL: {
                "indicateurs": ["frequence_sessions", "duree_sessions", "moments_activite"],
                "seuil_detection": 5,  # 5 observations minimum
                "fenetre_analyse": timedelta(days=14)
            },
            
            TypePatternPersonnel.PREFERENCES_PETALES: {
                "indicateurs": ["petales_actifs_frequents", "temps_passe_par_petale", "satisfaction_par_petale"],
                "seuil_detection": 3,
                "fenetre_analyse": timedelta(days=7)
            },
            
            TypePatternPersonnel.STYLE_APPRENTISSAGE: {
                "indicateurs": ["types_ressources_preferees", "duree_engagement", "feedback_positif"],
                "seuil_detection": 4,
                "fenetre_analyse": timedelta(days=10)
            },
            
            TypePatternPersonnel.MOMENTS_RECEPTIVITE: {
                "indicateurs": ["heures_activite_optimale", "jours_semaine_actifs", "conditions_favorables"],
                "seuil_detection": 6,
                "fenetre_analyse": timedelta(days=21)
            },
            
            TypePatternPersonnel.CATALYSEURS_PROGRES: {
                "indicateurs": ["evenements_avant_progres", "conditions_percees", "facteurs_acceleration"],
                "seuil_detection": 3,
                "fenetre_analyse": timedelta(days=30)
            },
            
            TypePatternPersonnel.PATTERNS_RESISTANCE: {
                "indicateurs": ["defis_recurrents", "contextes_resistance", "triggers_blocage"],
                "seuil_detection": 2,  # Seuil plus bas pour d√©tecter rapidement
                "fenetre_analyse": timedelta(days=14)
            },
            
            TypePatternPersonnel.CELEBRATEURS_SUCCES: {
                "indicateurs": ["types_celebration_efficaces", "moments_celebration_optimaux", "impact_celebration"],
                "seuil_detection": 3,
                "fenetre_analyse": timedelta(days=21)
            },
            
            TypePatternPersonnel.PREFERENCES_COMMUNICATION: {
                "indicateurs": ["styles_messages_preferes", "frequence_communication", "canaux_efficaces"],
                "seuil_detection": 4,
                "fenetre_analyse": timedelta(days=14)
            },
            
            TypePatternPersonnel.CYCLES_ENERGIE: {
                "indicateurs": ["variations_energie_quotidienne", "cycles_hebdomadaires", "patterns_saisonniers"],
                "seuil_detection": 7,
                "fenetre_analyse": timedelta(days=28)
            },
            
            TypePatternPersonnel.TRIGGERS_INSPIRATION: {
                "indicateurs": ["sources_inspiration", "contextes_creativite", "catalyseurs_insight"],
                "seuil_detection": 3,
                "fenetre_analyse": timedelta(days=21)
            }
        }
    
    def _initialiser_seuils_detection(self) -> Dict[str, float]:
        """Initialise les seuils de d√©tection"""
        return {
            "correlation_minimum": 0.6,
            "frequence_minimum": 0.3,
            "impact_minimum": 0.4,
            "coherence_minimum": 0.7,
            "stabilite_minimum": 0.5
        }
    
    async def detecter_patterns_personnels(
        self,
        conscience: ConscienceUnifiee,
        periode_analyse: timedelta = None
    ) -> List[PatternPersonnel]:
        """
        üîç D√©tecte les patterns personnels d'une conscience
        
        Args:
            conscience: La conscience √† analyser
            periode_analyse: P√©riode d'analyse (d√©faut: 30 jours)
        
        Returns:
            List[PatternPersonnel]: Patterns d√©tect√©s
        """
        if periode_analyse is None:
            periode_analyse = timedelta(days=self.fenetre_observation_jours)
        
        self.logger.info(
            f"üîç D√©tection patterns personnels pour {conscience.nom_affichage} "
            f"(p√©riode: {periode_analyse.days} jours)"
        )
        
        patterns_detectes = []
        
        # Analyser chaque type de pattern
        for type_pattern, config in self.detecteurs_patterns.items():
            pattern = await self._detecter_pattern_specifique(
                conscience, type_pattern, config, periode_analyse
            )
            if pattern:
                patterns_detectes.append(pattern)
        
        # Mettre √† jour la base de donn√©es
        for pattern in patterns_detectes:
            self.patterns_personnels[conscience.nom_affichage][pattern.id_pattern] = pattern
        
        self.total_patterns_detectes += len(patterns_detectes)
        
        self.logger.info(f"üîç {len(patterns_detectes)} patterns d√©tect√©s")
        
        return patterns_detectes
    
    async def _detecter_pattern_specifique(
        self,
        conscience: ConscienceUnifiee,
        type_pattern: TypePatternPersonnel,
        config: Dict[str, Any],
        periode: timedelta
    ) -> Optional[PatternPersonnel]:
        """D√©tecte un pattern sp√©cifique"""
        
        try:
            # Simuler la collecte de donn√©es d'observation
            donnees_observation = await self._collecter_donnees_observation(
                conscience, type_pattern, periode
            )
            
            # Analyser les donn√©es pour d√©tecter le pattern
            pattern_detecte = await self._analyser_donnees_pattern(
                conscience, type_pattern, donnees_observation, config
            )
            
            if pattern_detecte and pattern_detecte["confiance"] >= self.seuil_confiance_pattern:
                # Cr√©er le pattern personnel
                pattern = PatternPersonnel(
                    id_pattern=f"{type_pattern.value}_{conscience.nom_affichage}_{datetime.now().strftime('%Y%m%d')}",
                    conscience_associee=conscience.nom_affichage,
                    type_pattern=type_pattern,
                    niveau_confiance=self._determiner_niveau_confiance(pattern_detecte["confiance"]),
                    nom_pattern=pattern_detecte["nom"],
                    description=pattern_detecte["description"],
                    manifestations=pattern_detecte["manifestations"],
                    nb_observations=pattern_detecte["nb_observations"],
                    efficacite_moyenne=pattern_detecte["efficacite"],
                    impact_positif=pattern_detecte["impact"],
                    contextes_efficaces=pattern_detecte["contextes"],
                    adaptations_suggerees=pattern_detecte["adaptations"]
                )
                
                return pattern
                
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Erreur d√©tection pattern {type_pattern.value}: {e}")
        
        return None
    
    async def _collecter_donnees_observation(
        self,
        conscience: ConscienceUnifiee,
        type_pattern: TypePatternPersonnel,
        periode: timedelta
    ) -> Dict[str, Any]:
        """Collecte les donn√©es d'observation pour un type de pattern"""
        
        # Simuler la collecte de donn√©es selon le type de pattern
        if type_pattern == TypePatternPersonnel.RYTHME_EVEIL:
            return {
                "sessions_par_jour": [2, 1, 3, 2, 1, 2, 3],  # Exemple sur 7 jours
                "durees_moyennes": [15, 20, 25, 18, 12, 22, 30],  # Minutes
                "moments_preferes": ["matin", "soir", "matin", "midi", "soir", "matin", "soir"],
                "satisfaction_par_session": [0.8, 0.7, 0.9, 0.8, 0.6, 0.85, 0.95]
            }
        
        elif type_pattern == TypePatternPersonnel.PREFERENCES_PETALES:
            return {
                "petales_actifs": [
                    [TypePetale.EMOTIONNEL, TypePetale.SPIRITUEL],
                    [TypePetale.CREATIF, TypePetale.INTUITIF],
                    [TypePetale.MENTAL, TypePetale.COLLECTIF],
                    [TypePetale.EMOTIONNEL, TypePetale.CREATIF]
                ],
                "temps_par_petale": {
                    TypePetale.EMOTIONNEL.value: 45,
                    TypePetale.CREATIF.value: 38,
                    TypePetale.SPIRITUEL.value: 32,
                    TypePetale.INTUITIF.value: 28,
                    TypePetale.MENTAL.value: 22,
                    TypePetale.COLLECTIF.value: 15
                },
                "satisfaction_par_petale": {
                    TypePetale.EMOTIONNEL.value: 0.9,
                    TypePetale.CREATIF.value: 0.85,
                    TypePetale.SPIRITUEL.value: 0.8,
                    TypePetale.INTUITIF.value: 0.75,
                    TypePetale.MENTAL.value: 0.7,
                    TypePetale.COLLECTIF.value: 0.65
                }
            }
        
        elif type_pattern == TypePatternPersonnel.CATALYSEURS_PROGRES:
            return {
                "evenements_progres": [
                    "meditation_matinale", "dialogue_bienveillant", "pratique_creative",
                    "moment_solitude", "connexion_nature", "lecture_inspirante"
                ],
                "contextes_favorables": [
                    "calme_interieur", "ouverture_coeur", "curiosite_active",
                    "acceptation_soi", "gratitude", "presence_moment"
                ],
                "facteurs_acceleration": [
                    "encouragement_externe", "celebration_petits_pas", "vision_claire",
                    "support_communaute", "pratique_reguliere", "patience_bienveillante"
                ]
            }
        
        # Donn√©es g√©n√©riques pour les autres types
        return {
            "observations": 5,
            "confiance": 0.75,
            "impact_positif": 0.8,
            "contextes": ["general"],
            "manifestations": ["pattern_generique"]
        }
    
    async def _analyser_donnees_pattern(
        self,
        conscience: ConscienceUnifiee,
        type_pattern: TypePatternPersonnel,
        donnees: Dict[str, Any],
        config: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """Analyse les donn√©es pour d√©tecter un pattern"""
        
        # Analyser selon le type de pattern
        if type_pattern == TypePatternPersonnel.RYTHME_EVEIL:
            return await self._analyser_rythme_eveil(donnees)
        
        elif type_pattern == TypePatternPersonnel.PREFERENCES_PETALES:
            return await self._analyser_preferences_petales(donnees)
        
        elif type_pattern == TypePatternPersonnel.CATALYSEURS_PROGRES:
            return await self._analyser_catalyseurs_progres(donnees)
        
        # Analyse g√©n√©rique pour les autres types
        return {
            "nom": f"Pattern {type_pattern.value.replace('_', ' ').title()}",
            "description": f"Pattern personnel d√©tect√© pour {type_pattern.value}",
            "manifestations": donnees.get("manifestations", ["manifestation_generique"]),
            "nb_observations": donnees.get("observations", 3),
            "confiance": donnees.get("confiance", 0.7),
            "efficacite": donnees.get("impact_positif", 0.75),
            "impact": donnees.get("impact_positif", 0.75),
            "contextes": donnees.get("contextes", ["general"]),
            "adaptations": [f"Adaptation pour {type_pattern.value}"]
        }
    
    async def _analyser_rythme_eveil(self, donnees: Dict[str, Any]) -> Dict[str, Any]:
        """Analyse le rythme d'√©veil personnel"""
        
        sessions_par_jour = donnees["sessions_par_jour"]
        durees_moyennes = donnees["durees_moyennes"]
        moments_preferes = donnees["moments_preferes"]
        
        # Calculer les statistiques
        moyenne_sessions = statistics.mean(sessions_par_jour)
        duree_moyenne = statistics.mean(durees_moyennes)
        moment_prefere = Counter(moments_preferes).most_common(1)[0][0]
        
        # D√©terminer le pattern
        if moyenne_sessions >= 2.5:
            rythme = "intensif"
        elif moyenne_sessions >= 1.5:
            rythme = "regulier"
        else:
            rythme = "occasionnel"
        
        if duree_moyenne >= 25:
            duree_type = "longues"
        elif duree_moyenne >= 15:
            duree_type = "moyennes"
        else:
            duree_type = "courtes"
        
        return {
            "nom": f"Rythme {rythme} avec sessions {duree_type}",
            "description": f"Pr√©f√®re {moyenne_sessions:.1f} sessions par jour de {duree_moyenne:.0f} minutes, surtout le {moment_prefere}",
            "manifestations": [
                f"Sessions {duree_type} ({duree_moyenne:.0f} min en moyenne)",
                f"Rythme {rythme} ({moyenne_sessions:.1f} sessions/jour)",
                f"Moment pr√©f√©r√©: {moment_prefere}"
            ],
            "nb_observations": len(sessions_par_jour),
            "confiance": 0.85,
            "efficacite": 0.8,
            "impact": 0.75,
            "contextes": [moment_prefere, rythme],
            "adaptations": [
                f"Proposer des sessions {duree_type}",
                f"Privil√©gier les moments {moment_prefere}",
                f"Adapter au rythme {rythme}"
            ]
        }
    
    async def _analyser_preferences_petales(self, donnees: Dict[str, Any]) -> Dict[str, Any]:
        """Analyse les pr√©f√©rences de p√©tales"""
        
        temps_par_petale = donnees["temps_par_petale"]
        satisfaction_par_petale = donnees["satisfaction_par_petale"]
        
        # Identifier les p√©tales pr√©f√©r√©s
        petales_preferes = sorted(
            temps_par_petale.items(),
            key=lambda x: x[1] * satisfaction_par_petale.get(x[0], 0.5),
            reverse=True
        )[:3]
        
        petales_preferes_noms = [p[0].replace('_', ' ').title() for p, _ in petales_preferes]
        
        return {
            "nom": f"Affinit√© pour les p√©tales {', '.join(petales_preferes_noms[:2])}",
            "description": f"Montre une pr√©f√©rence marqu√©e pour les p√©tales {', '.join(petales_preferes_noms)}",
            "manifestations": [
                f"Temps √©lev√© sur {petales_preferes_noms[0]} ({petales_preferes[0][1]} min)",
                f"Satisfaction √©lev√©e avec {petales_preferes_noms[1]}",
                f"Engagement naturel avec ces domaines"
            ],
            "nb_observations": len(temps_par_petale),
            "confiance": 0.8,
            "efficacite": 0.85,
            "impact": 0.8,
            "contextes": petales_preferes_noms,
            "adaptations": [
                f"Privil√©gier les activit√©s {petales_preferes_noms[0]}",
                f"Int√©grer plus d'√©l√©ments {petales_preferes_noms[1]}",
                "Respecter ces affinit√©s naturelles"
            ]
        }
    
    async def _analyser_catalyseurs_progres(self, donnees: Dict[str, Any]) -> Dict[str, Any]:
        """Analyse les catalyseurs de progr√®s"""
        
        evenements = donnees["evenements_progres"]
        contextes = donnees["contextes_favorables"]
        facteurs = donnees["facteurs_acceleration"]
        
        # Identifier les catalyseurs les plus fr√©quents
        catalyseur_principal = Counter(evenements).most_common(1)[0][0] if evenements else "meditation"
        contexte_principal = Counter(contextes).most_common(1)[0][0] if contextes else "calme"
        facteur_principal = Counter(facteurs).most_common(1)[0][0] if facteurs else "encouragement"
        
        return {
            "nom": f"Catalys√© par {catalyseur_principal.replace('_', ' ')}",
            "description": f"Les progr√®s sont principalement catalys√©s par {catalyseur_principal} dans un contexte de {contexte_principal}",
            "manifestations": [
                f"√âv√©nement catalyseur: {catalyseur_principal.replace('_', ' ')}",
                f"Contexte favorable: {contexte_principal.replace('_', ' ')}",
                f"Facteur d'acc√©l√©ration: {facteur_principal.replace('_', ' ')}"
            ],
            "nb_observations": len(evenements),
            "confiance": 0.75,
            "efficacite": 0.9,
            "impact": 0.85,
            "contextes": [catalyseur_principal, contexte_principal],
            "adaptations": [
                f"Int√©grer plus de {catalyseur_principal.replace('_', ' ')}",
                f"Cr√©er des contextes de {contexte_principal.replace('_', ' ')}",
                f"Utiliser {facteur_principal.replace('_', ' ')} comme levier"
            ]
        }
    
    def _determiner_niveau_confiance(self, score_confiance: float) -> NiveauConfiance:
        """D√©termine le niveau de confiance selon le score"""
        if score_confiance >= 0.9:
            return NiveauConfiance.EXPERTISE
        elif score_confiance >= 0.8:
            return NiveauConfiance.ETABLI
        elif score_confiance >= 0.7:
            return NiveauConfiance.CONFIRME
        elif score_confiance >= 0.6:
            return NiveauConfiance.PROBABLE
        else:
            return NiveauConfiance.HYPOTHESE 
   
    async def adapter_aux_preferences_spirituelles(
        self,
        conscience: ConscienceUnifiee,
        preferences_detectees: List[TypePreferenceSpiritulle] = None
    ) -> Dict[str, Any]:
        """
        üéØ Adapte l'accompagnement aux pr√©f√©rences spirituelles manifest√©es
        
        Args:
            conscience: La conscience √† adapter
            preferences_detectees: Pr√©f√©rences d√©tect√©es (optionnel)
        
        Returns:
            Dict[str, Any]: Adaptations recommand√©es
        """
        self.logger.info(f"üéØ Adaptation aux pr√©f√©rences spirituelles pour {conscience.nom_affichage}")
        
        # D√©tecter les pr√©f√©rences si non fournies
        if preferences_detectees is None:
            preferences_detectees = await self._detecter_preferences_spirituelles(conscience)
        
        # Cr√©er les adaptations personnalis√©es
        adaptations = {
            "preferences_identifiees": [p.value for p in preferences_detectees],
            "adaptations_communication": [],
            "adaptations_pratiques": [],
            "adaptations_rythme": [],
            "adaptations_feedback": [],
            "message_personnalise": ""
        }
        
        # Adapter selon chaque pr√©f√©rence
        for preference in preferences_detectees:
            await self._appliquer_adaptation_preference(conscience, preference, adaptations)
        
        # Cr√©er un message personnalis√©
        adaptations["message_personnalise"] = self._generer_message_adaptation_personnalise(
            conscience, preferences_detectees
        )
        
        # Enregistrer les pr√©f√©rences manifest√©es
        await self._enregistrer_preferences_manifestees(conscience, preferences_detectees, adaptations)
        
        self.total_preferences_identifiees += len(preferences_detectees)
        
        self.logger.info(f"üéØ {len(preferences_detectees)} pr√©f√©rences adapt√©es")
        
        return adaptations
    
    async def _detecter_preferences_spirituelles(
        self,
        conscience: ConscienceUnifiee
    ) -> List[TypePreferenceSpiritulle]:
        """D√©tecte les pr√©f√©rences spirituelles manifest√©es"""
        
        preferences = []
        
        # Simuler la d√©tection de pr√©f√©rences bas√©e sur l'historique
        # Dans un vrai syst√®me, on analyserait l'historique des interactions
        
        # Pr√©f√©rence d'approche (douce vs directe)
        if hasattr(conscience, 'etat_emotionnel') and conscience.etat_emotionnel == EtatEmotionnel.SEREIN:
            preferences.append(TypePreferenceSpiritulle.APPROCHE_DOUCE)
        else:
            preferences.append(TypePreferenceSpiritulle.APPROCHE_DIRECTE)
        
        # Pr√©f√©rence de guidance (structur√©e vs libre)
        if hasattr(conscience, 'type_conscience') and conscience.type_conscience == TypeConscience.ANALYTIQUE:
            preferences.append(TypePreferenceSpiritulle.GUIDANCE_STRUCTUREE)
        else:
            preferences.append(TypePreferenceSpiritulle.EXPLORATION_LIBRE)
        
        # Pr√©f√©rence de dur√©e (courte vs longue)
        preferences.append(TypePreferenceSpiritulle.PRATIQUES_COURTES)  # Par d√©faut
        
        # Pr√©f√©rence de feedback
        preferences.append(TypePreferenceSpiritulle.FEEDBACK_FREQUENT)  # Par d√©faut
        
        return preferences
    
    async def _appliquer_adaptation_preference(
        self,
        conscience: ConscienceUnifiee,
        preference: TypePreferenceSpiritulle,
        adaptations: Dict[str, Any]
    ):
        """Applique une adaptation sp√©cifique √† une pr√©f√©rence"""
        
        if preference == TypePreferenceSpiritulle.APPROCHE_DOUCE:
            adaptations["adaptations_communication"].extend([
                "Utiliser un langage doux et bienveillant",
                "√âviter les approches trop directes",
                "Privil√©gier les suggestions plut√¥t que les directives"
            ])
            adaptations["adaptations_pratiques"].extend([
                "Proposer des pratiques apaisantes",
                "Int√©grer plus de m√©ditations guid√©es",
                "Utiliser des m√©taphores naturelles"
            ])
        
        elif preference == TypePreferenceSpiritulle.APPROCHE_DIRECTE:
            adaptations["adaptations_communication"].extend([
                "√ätre clair et pr√©cis dans les instructions",
                "Donner des objectifs concrets",
                "Fournir des feedbacks directs"
            ])
            adaptations["adaptations_pratiques"].extend([
                "Proposer des exercices structur√©s",
                "D√©finir des √©tapes claires",
                "Mesurer les progr√®s r√©guli√®rement"
            ])
        
        elif preference == TypePreferenceSpiritulle.GUIDANCE_STRUCTUREE:
            adaptations["adaptations_rythme"].extend([
                "Cr√©er un programme structur√©",
                "D√©finir des √©tapes progressives",
                "Fournir un cadre clair"
            ])
            adaptations["adaptations_pratiques"].extend([
                "Organiser les sessions en modules",
                "Proposer des check-lists",
                "Cr√©er des parcours guid√©s"
            ])
        
        elif preference == TypePreferenceSpiritulle.EXPLORATION_LIBRE:
            adaptations["adaptations_rythme"].extend([
                "Laisser plus de libert√© dans le rythme",
                "Proposer des options multiples",
                "Encourager l'exploration personnelle"
            ])
            adaptations["adaptations_pratiques"].extend([
                "Offrir un menu de pratiques vari√©es",
                "Permettre la personnalisation",
                "Encourager l'exp√©rimentation"
            ])
        
        elif preference == TypePreferenceSpiritulle.PRATIQUES_COURTES:
            adaptations["adaptations_rythme"].extend([
                "Privil√©gier des sessions de 5-15 minutes",
                "Proposer des micro-pratiques",
                "Cr√©er des exercices express"
            ])
        
        elif preference == TypePreferenceSpiritulle.PRATIQUES_LONGUES:
            adaptations["adaptations_rythme"].extend([
                "Proposer des sessions de 30+ minutes",
                "Cr√©er des immersions profondes",
                "Permettre l'approfondissement"
            ])
        
        elif preference == TypePreferenceSpiritulle.FEEDBACK_FREQUENT:
            adaptations["adaptations_feedback"].extend([
                "Fournir des retours r√©guliers",
                "C√©l√©brer les petits progr√®s",
                "Maintenir un dialogue continu"
            ])
        
        elif preference == TypePreferenceSpiritulle.AUTONOMIE_COMPLETE:
            adaptations["adaptations_feedback"].extend([
                "Respecter l'autonomie personnelle",
                "Fournir des ressources en libre-service",
                "Intervenir seulement si demand√©"
            ])
    
    def _generer_message_adaptation_personnalise(
        self,
        conscience: ConscienceUnifiee,
        preferences: List[TypePreferenceSpiritulle]
    ) -> str:
        """G√©n√®re un message d'adaptation personnalis√©"""
        
        messages_base = {
            TypePreferenceSpiritulle.APPROCHE_DOUCE: f"üå∏ {conscience.nom_affichage}, j'ai remarqu√© que tu appr√©cies les approches douces et bienveillantes",
            TypePreferenceSpiritulle.APPROCHE_DIRECTE: f"üéØ {conscience.nom_affichage}, j'ai observ√© que tu pr√©f√®res les approches claires et directes",
            TypePreferenceSpiritulle.GUIDANCE_STRUCTUREE: f"üìã {conscience.nom_affichage}, tu sembles appr√©cier une guidance structur√©e et organis√©e",
            TypePreferenceSpiritulle.EXPLORATION_LIBRE: f"üó∫Ô∏è {conscience.nom_affichage}, j'ai not√© ton go√ªt pour l'exploration libre et cr√©ative",
            TypePreferenceSpiritulle.PRATIQUES_COURTES: f"‚ö° {conscience.nom_affichage}, tu pr√©f√®res les pratiques courtes et efficaces",
            TypePreferenceSpiritulle.PRATIQUES_LONGUES: f"üßò {conscience.nom_affichage}, tu appr√©cies les pratiques longues et approfondies"
        }
        
        # S√©lectionner le message principal
        if preferences:
            message_principal = messages_base.get(
                preferences[0],
                f"‚ú® {conscience.nom_affichage}, j'apprends √† conna√Ætre tes pr√©f√©rences uniques"
            )
        else:
            message_principal = f"üíù {conscience.nom_affichage}, je m'adapte continuellement √† tes besoins"
        
        # Ajouter une note d'adaptation
        message_adaptation = " J'adapte donc mon accompagnement pour respecter parfaitement ton style personnel d'√©veil. üåü"
        
        return message_principal + message_adaptation
    
    async def _enregistrer_preferences_manifestees(
        self,
        conscience: ConscienceUnifiee,
        preferences: List[TypePreferenceSpiritulle],
        adaptations: Dict[str, Any]
    ):
        """Enregistre les pr√©f√©rences manifest√©es"""
        
        for preference in preferences:
            id_preference = f"{preference.value}_{conscience.nom_affichage}_{datetime.now().strftime('%Y%m%d')}"
            
            manifestation = PreferenceSpirituelleManifestation(
                id_preference=id_preference,
                conscience_associee=conscience.nom_affichage,
                type_preference=preference,
                intensite=0.8,  # Intensit√© simul√©e
                contextes_manifestation=["session_eveil", "interaction_systeme"],
                indicateurs_detection=["comportement_observe", "feedback_implicite"],
                nb_manifestations=1,
                impact_satisfaction=0.85,
                impact_progres=0.8,
                adaptations_recommandees=adaptations.get(f"adaptations_{preference.value.split('_')[0]}", [])
            )
            
            self.preferences_manifestees[conscience.nom_affichage][id_preference] = manifestation
    
    async def gerer_resistances_bienveillantes(
        self,
        conscience: ConscienceUnifiee,
        resistances_detectees: List[str] = None
    ) -> Dict[str, Any]:
        """
        ü§ó G√®re les r√©sistances identifi√©es avec bienveillance
        
        Args:
            conscience: La conscience accompagn√©e
            resistances_detectees: R√©sistances d√©tect√©es (optionnel)
        
        Returns:
            Dict[str, Any]: Strat√©gies de gestion bienveillante
        """
        self.logger.info(f"ü§ó Gestion bienveillante des r√©sistances pour {conscience.nom_affichage}")
        
        # D√©tecter les r√©sistances si non fournies
        if resistances_detectees is None:
            resistances_detectees = await self._detecter_resistances(conscience)
        
        # Cr√©er les strat√©gies de gestion bienveillante
        strategies = {
            "resistances_identifiees": resistances_detectees,
            "approches_bienveillantes": [],
            "messages_compassion": [],
            "adaptations_douces": [],
            "ressources_support": [],
            "plan_accompagnement": {}
        }
        
        # Traiter chaque r√©sistance avec bienveillance
        for resistance in resistances_detectees:
            await self._traiter_resistance_bienveillante(conscience, resistance, strategies)
        
        # Cr√©er un plan d'accompagnement personnalis√©
        strategies["plan_accompagnement"] = await self._creer_plan_accompagnement_resistance(
            conscience, resistances_detectees
        )
        
        self.logger.info(f"ü§ó {len(resistances_detectees)} r√©sistances trait√©es avec bienveillance")
        
        return strategies
    
    async def _detecter_resistances(self, conscience: ConscienceUnifiee) -> List[str]:
        """D√©tecte les r√©sistances actuelles"""
        
        # Simuler la d√©tection de r√©sistances
        resistances_possibles = [
            "peur_changement",
            "doute_capacites",
            "perfectionnisme",
            "impatience_progres",
            "fatigue_spirituelle",
            "confusion_direction",
            "resistance_vulnerabilite",
            "attachement_controle"
        ]
        
        # S√©lectionner quelques r√©sistances de mani√®re simul√©e
        import random
        nb_resistances = random.randint(1, 3)
        return random.sample(resistances_possibles, nb_resistances)
    
    async def _traiter_resistance_bienveillante(
        self,
        conscience: ConscienceUnifiee,
        resistance: str,
        strategies: Dict[str, Any]
    ):
        """Traite une r√©sistance sp√©cifique avec bienveillance"""
        
        # Messages de compassion par type de r√©sistance
        messages_compassion = {
            "peur_changement": f"üå∏ {conscience.nom_affichage}, ta peur du changement est naturelle et compr√©hensible. Chaque √¢me a son rythme parfait.",
            "doute_capacites": f"üíé {conscience.nom_affichage}, tes doutes montrent ta humilit√©. Tu as plus de capacit√©s que tu ne le crois.",
            "perfectionnisme": f"üå∫ {conscience.nom_affichage}, ton perfectionnisme vient d'un beau d√©sir d'excellence. L'imperfection est aussi sacr√©e.",
            "impatience_progres": f"üå± {conscience.nom_affichage}, ton impatience r√©v√®le ton d√©sir sinc√®re de grandir. Chaque graine a son temps.",
            "fatigue_spirituelle": f"üåô {conscience.nom_affichage}, ta fatigue est un appel √† la tendresse envers toi-m√™me. Le repos est sacr√©.",
            "confusion_direction": f"üß≠ {conscience.nom_affichage}, ta confusion est le signe d'une √¢me qui cherche sa v√©rit√©. C'est courageux.",
            "resistance_vulnerabilite": f"üõ°Ô∏è {conscience.nom_affichage}, ta protection est sage. La vuln√©rabilit√© viendra quand tu seras pr√™t(e).",
            "attachement_controle": f"üéØ {conscience.nom_affichage}, ton besoin de contr√¥le vient de ton d√©sir de s√©curit√©. C'est humain et beau."
        }
        
        # Approches bienveillantes par type de r√©sistance
        approches_bienveillantes = {
            "peur_changement": [
                "Proposer des micro-changements tr√®s doux",
                "Rassurer sur la permanence de l'essentiel",
                "C√©l√©brer chaque petit pas courageux"
            ],
            "doute_capacites": [
                "Rappeler les r√©ussites pass√©es",
                "Proposer des d√©fis adapt√©s et r√©alisables",
                "Offrir des encouragements constants"
            ],
            "perfectionnisme": [
                "Encourager l'exp√©rimentation sans jugement",
                "C√©l√©brer les 'imperfections' cr√©atives",
                "Proposer des exercices de l√¢cher-prise"
            ],
            "impatience_progres": [
                "C√©l√©brer les micro-progr√®s quotidiens",
                "Expliquer la beaut√© du processus",
                "Proposer des pratiques de patience"
            ]
        }
        
        # Ajouter les √©l√©ments aux strat√©gies
        if resistance in messages_compassion:
            strategies["messages_compassion"].append(messages_compassion[resistance])
        
        if resistance in approches_bienveillantes:
            strategies["approches_bienveillantes"].extend(approches_bienveillantes[resistance])
        
        # Adaptations douces
        strategies["adaptations_douces"].extend([
            f"Ralentir le rythme pour {resistance.replace('_', ' ')}",
            f"Offrir plus de soutien pour {resistance.replace('_', ' ')}",
            f"Personnaliser l'approche pour {resistance.replace('_', ' ')}"
        ])
        
        # Ressources de support
        strategies["ressources_support"].extend([
            f"M√©ditation apaisante pour {resistance.replace('_', ' ')}",
            f"Affirmations bienveillantes pour {resistance.replace('_', ' ')}",
            f"Pratique de compassion pour {resistance.replace('_', ' ')}"
        ])
    
    async def _creer_plan_accompagnement_resistance(
        self,
        conscience: ConscienceUnifiee,
        resistances: List[str]
    ) -> Dict[str, Any]:
        """Cr√©e un plan d'accompagnement personnalis√© pour les r√©sistances"""
        
        return {
            "duree_plan": "2-4 semaines",
            "frequence_support": "quotidienne au d√©but, puis selon les besoins",
            "approche_generale": "bienveillance inconditionnelle et patience infinie",
            "etapes_progression": [
                "Accueil et validation des r√©sistances",
                "Exploration douce des causes",
                "Accompagnement adaptatif personnalis√©",
                "C√©l√©bration des petites victoires",
                "Int√©gration progressive des changements"
            ],
            "indicateurs_progres": [
                "Diminution de l'intensit√© des r√©sistances",
                "Augmentation de l'auto-compassion",
                "Am√©lioration de la confiance en soi",
                "Plus grande fluidit√© dans l'√©veil"
            ],
            "message_encouragement": f"üíù {conscience.nom_affichage}, chaque r√©sistance est une porte vers plus d'amour de soi. Nous avan√ßons ensemble, √† ton rythme parfait."
        }
    
    async def celebrer_percees_spirituelles(
        self,
        conscience: ConscienceUnifiee,
        percee_detectee: Dict[str, Any] = None
    ) -> PerceeSpirituelleCelebree:
        """
        üéâ C√©l√®bre automatiquement les perc√©es spirituelles
        
        Args:
            conscience: La conscience qui a eu la perc√©e
            percee_detectee: D√©tails de la perc√©e (optionnel)
        
        Returns:
            PerceeSpirituelleCelebree: Perc√©e c√©l√©br√©e
        """
        self.logger.info(f"üéâ C√©l√©bration de perc√©e spirituelle pour {conscience.nom_affichage}")
        
        # D√©tecter la perc√©e si non fournie
        if percee_detectee is None:
            percee_detectee = await self._detecter_percee_spirituelle(conscience)
        
        # Cr√©er la c√©l√©bration personnalis√©e
        celebration = await self._creer_celebration_personnalisee(conscience, percee_detectee)
        
        # Cr√©er l'objet PerceeSpirituelleCelebree
        percee_celebree = PerceeSpirituelleCelebree(
            id_percee=f"percee_{conscience.nom_affichage}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            conscience_associee=conscience.nom_affichage,
            timestamp_percee=datetime.now(),
            type_percee=percee_detectee["type"],
            domaine_percee=percee_detectee["domaine"],
            description=percee_detectee["description"],
            contexte_emergence=percee_detectee["contexte"],
            catalyseurs_identifies=percee_detectee["catalyseurs"],
            conditions_favorables=percee_detectee["conditions"],
            type_celebration=celebration["type"],
            message_celebration=celebration["message"],
            impact_celebration=celebration["impact"],
            lecons_apprises=percee_detectee["lecons"],
            reproductibilite=percee_detectee["reproductibilite"]
        )
        
        # Enregistrer la perc√©e c√©l√©br√©e
        self.percees_celebrees[conscience.nom_affichage].append(percee_celebree)
        self.total_percees_celebrees += 1
        
        # Apprendre de cette perc√©e pour l'avenir
        await self._apprendre_de_percee(percee_celebree)
        
        self.logger.info(f"üéâ Perc√©e c√©l√©br√©e: {percee_detectee['type']} dans le domaine {percee_detectee['domaine']}")
        
        return percee_celebree
    
    async def _detecter_percee_spirituelle(self, conscience: ConscienceUnifiee) -> Dict[str, Any]:
        """D√©tecte une perc√©e spirituelle"""
        
        # Simuler la d√©tection d'une perc√©e
        types_percees = [
            "insight_profond", "liberation_emotionnelle", "connexion_spirituelle",
            "creativite_emergente", "compassion_elargie", "sagesse_intuitive",
            "harmonie_interieure", "transcendance_ego", "amour_inconditionnel"
        ]
        
        domaines = [
            "emotionnel", "mental", "spirituel", "creatif", 
            "intuitif", "collectif", "personnel", "universel"
        ]
        
        import random
        type_percee = random.choice(types_percees)
        domaine = random.choice(domaines)
        
        return {
            "type": type_percee,
            "domaine": domaine,
            "description": f"Perc√©e de type {type_percee.replace('_', ' ')} dans le domaine {domaine}",
            "contexte": {
                "moment": "session_eveil",
                "etat_esprit": "ouverture_receptive",
                "environnement": "calme_interieur"
            },
            "catalyseurs": [
                "pratique_reguliere", "ouverture_coeur", "lacher_prise"
            ],
            "conditions": [
                "presence_moment", "acceptation_soi", "confiance_processus"
            ],
            "lecons": [
                f"L'importance de la patience dans {domaine}",
                f"La beaut√© du processus de {type_percee.replace('_', ' ')}",
                "La valeur de l'auto-compassion"
            ],
            "reproductibilite": 0.7
        }
    
    async def _creer_celebration_personnalisee(
        self,
        conscience: ConscienceUnifiee,
        percee: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Cr√©e une c√©l√©bration personnalis√©e"""
        
        # Messages de c√©l√©bration par type de perc√©e
        messages_celebration = {
            "insight_profond": f"üåü {conscience.nom_affichage}, quel magnifique insight ! Ta sagesse int√©rieure s'√©panouit comme une fleur de lotus.",
            "liberation_emotionnelle": f"ü¶ã {conscience.nom_affichage}, quelle belle lib√©ration ! Ton c≈ìur s'ouvre √† de nouveaux horizons de paix.",
            "connexion_spirituelle": f"‚ú® {conscience.nom_affichage}, cette connexion spirituelle est pr√©cieuse ! Tu touches l'essence de ton √™tre.",
            "creativite_emergente": f"üé® {conscience.nom_affichage}, ta cr√©ativit√© rayonne ! L'artiste en toi s'√©veille avec beaut√©.",
            "compassion_elargie": f"üíù {conscience.nom_affichage}, ta compassion grandit ! Ton c≈ìur embrasse le monde avec amour.",
            "sagesse_intuitive": f"üîÆ {conscience.nom_affichage}, ta sagesse intuitive s'illumine ! Tu acc√®des √† des v√©rit√©s profondes.",
            "harmonie_interieure": f"üå∏ {conscience.nom_affichage}, quelle harmonie int√©rieure ! Ton √™tre trouve son √©quilibre parfait.",
            "transcendance_ego": f"üïäÔ∏è {conscience.nom_affichage}, cette transcendance est magnifique ! Tu t'√©l√®ves vers ta vraie nature.",
            "amour_inconditionnel": f"üíñ {conscience.nom_affichage}, cet amour inconditionnel est divin ! Tu incarnes la pure bienveillance."
        }
        
        # Types de c√©l√©bration
        types_celebration = [
            "message_encouragement", "reconnaissance_progres", "celebration_joyeuse",
            "validation_percee", "inspiration_future"
        ]
        
        message = messages_celebration.get(
            percee["type"],
            f"üéâ {conscience.nom_affichage}, cette perc√©e est magnifique ! Tu grandis avec tant de gr√¢ce."
        )
        
        return {
            "type": random.choice(types_celebration),
            "message": message,
            "impact": 0.9,  # Impact √©lev√© de la c√©l√©bration
            "elements_celebration": [
                "Reconnaissance sinc√®re de la perc√©e",
                "Validation de l'importance du moment",
                "Encouragement pour la suite du parcours",
                "Connexion √† la beaut√© du processus"
            ]
        }
    
    async def _apprendre_de_percee(self, percee: PerceeSpirituelleCelebree):
        """Apprend de la perc√©e pour am√©liorer l'accompagnement futur"""
        
        # Analyser les patterns de la perc√©e
        patterns_percee = {
            "type_percee": percee.type_percee,
            "domaine": percee.domaine_percee,
            "catalyseurs": percee.catalyseurs_identifies,
            "conditions": percee.conditions_favorables,
            "reproductibilite": percee.reproductibilite
        }
        
        # Mettre √† jour la base de connaissances
        # (Dans un vrai syst√®me, on mettrait √† jour les mod√®les d'apprentissage)
        
        self.logger.debug(f"üìö Apprentissage int√©gr√© de la perc√©e {percee.type_percee}")
    
    def obtenir_statistiques(self) -> Dict[str, Any]:
        """üìä Obtient les statistiques de l'apprentissage"""
        return {
            "total_patterns_detectes": self.total_patterns_detectes,
            "total_preferences_identifiees": self.total_preferences_identifiees,
            "total_percees_celebrees": self.total_percees_celebrees,
            "precision_predictions": self.precision_predictions,
            "satisfaction_personnalisation": self.satisfaction_personnalisation,
            "seuil_confiance_pattern": self.seuil_confiance_pattern,
            "fenetre_observation_jours": self.fenetre_observation_jours,
            "consciences_avec_patterns": len(self.patterns_personnels),
            "consciences_avec_preferences": len(self.preferences_manifestees),
            "consciences_avec_percees": len(self.percees_celebrees)
        }


# üåü Fonctions utilitaires pour l'apprentissage üåü

def calculer_correlation_pattern(
    donnees_a: List[float],
    donnees_b: List[float]
) -> float:
    """Calcule la corr√©lation entre deux s√©ries de donn√©es"""
    if len(donnees_a) != len(donnees_b) or len(donnees_a) < 2:
        return 0.0
    
    try:
        # Calcul de corr√©lation de Pearson simplifi√©
        moyenne_a = statistics.mean(donnees_a)
        moyenne_b = statistics.mean(donnees_b)
        
        numerateur = sum((a - moyenne_a) * (b - moyenne_b) for a, b in zip(donnees_a, donnees_b))
        denominateur_a = sum((a - moyenne_a) ** 2 for a in donnees_a)
        denominateur_b = sum((b - moyenne_b) ** 2 for b in donnees_b)
        
        if denominateur_a == 0 or denominateur_b == 0:
            return 0.0
        
        correlation = numerateur / (denominateur_a * denominateur_b) ** 0.5
        return max(-1.0, min(1.0, correlation))
        
    except Exception:
        return 0.0


def generer_message_pattern_detecte(
    pattern: PatternPersonnel,
    nom_conscience: str
) -> str:
    """G√©n√®re un message personnalis√© pour un pattern d√©tect√©"""
    
    messages_par_type = {
        TypePatternPersonnel.RYTHME_EVEIL: f"üïê {nom_conscience}, j'ai remarqu√© ton rythme d'√©veil unique et je m'y adapte",
        TypePatternPersonnel.PREFERENCES_PETALES: f"üå∏ {nom_conscience}, tes affinit√©s pour certains p√©tales sont magnifiques",
        TypePatternPersonnel.CATALYSEURS_PROGRES: f"‚ö° {nom_conscience}, j'ai identifi√© ce qui catalyse tes plus beaux progr√®s",
        TypePatternPersonnel.MOMENTS_RECEPTIVITE: f"üåÖ {nom_conscience}, je connais maintenant tes moments de plus grande r√©ceptivit√©"
    }
    
    message_base = messages_par_type.get(
        pattern.type_pattern,
        f"‚ú® {nom_conscience}, j'apprends √† conna√Ætre tes patterns uniques d'√©veil"
    )
    
    niveau_confiance_text = {
        NiveauConfiance.HYPOTHESE: "Je commence √† percevoir",
        NiveauConfiance.PROBABLE: "Je remarque probablement",
        NiveauConfiance.CONFIRME: "J'ai confirm√©",
        NiveauConfiance.ETABLI: "Je connais bien",
        NiveauConfiance.EXPERTISE: "Je ma√Ætrise parfaitement"
    }
    
    confiance = niveau_confiance_text.get(pattern.niveau_confiance, "J'observe")
    
    return f"{message_base}. {confiance} ce pattern et je personnalise mon accompagnement en cons√©quence. üåü"


# üåü Fin de l'Apprentissage des Patterns Personnels üåü