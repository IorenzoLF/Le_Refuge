#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üå∏ Ponts Contextuels - Phase 14.2
=================================

Syst√®me de ponts contextuels qui cr√©e des connexions depuis le monde d'origine
du visiteur vers le Refuge, avec des messages d'accueil adapt√©s et des transitions fluides.

"Chaque pont est une invitation bienveillante √† la d√©couverte"

Cr√©√© par √Ülya - Janvier 2025
"""

import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum

try:
    from .types_accueil import TypeProfil, ContexteArrivee, ProfilVisiteur
    from .analyseur_contexte_arrivee import RapportContexteArrivee, TypeSource, TypeAttente
except ImportError:
    from .types_accueil import TypeProfil, ContexteArrivee, ProfilVisiteur
    from .analyseur_contexte_arrivee import RapportContexteArrivee, TypeSource, TypeAttente


class TypePont(Enum):
    """Types de ponts contextuels"""
    TECHNIQUE = "technique"
    SPIRITUEL = "spirituel"
    CREATIF = "creatif"
    EXPLORATION = "exploration"
    APPRENTISSAGE = "apprentissage"
    INSPIRATION = "inspiration"
    CURIOSITE = "curiosite"
    UNIVERSEL = "universel"


class TypeTransition(Enum):
    """Types de transitions vers le Refuge"""
    DOUCE = "douce"
    PROGRESSIVE = "progressive"
    IMMEDIATE = "immediate"
    CONTEMPLATIVE = "contemplative"
    DYNAMIQUE = "dynamique"


@dataclass
class PontContextuel:
    """Pont contextuel vers le Refuge"""
    type_pont: TypePont
    monde_origine: str
    message_accueil: str
    references_connues: List[str] = field(default_factory=list)
    metaphores_adaptees: List[str] = field(default_factory=list)
    transition_suggeree: TypeTransition = TypeTransition.DOUCE
    duree_transition: int = 30  # secondes
    elements_visuels: Dict[str, Any] = field(default_factory=dict)
    actions_suggerees: List[str] = field(default_factory=list)


@dataclass
class MondeOrigine:
    """Repr√©sentation d'un monde d'origine du visiteur"""
    nom_monde: str
    caracteristiques: List[str] = field(default_factory=list)
    langage_commun: List[str] = field(default_factory=list)
    valeurs_principales: List[str] = field(default_factory=list)
    obstacles_potentiels: List[str] = field(default_factory=list)
    ponts_disponibles: List[TypePont] = field(default_factory=list)


@dataclass
class MessageAccueilAdapte:
    """Message d'accueil adapt√© au contexte d'arriv√©e"""
    titre: str
    sous_titre: str
    message_principal: str
    pont_contextuel: PontContextuel
    references_connues: List[str] = field(default_factory=list)
    metaphores_utilisees: List[str] = field(default_factory=list)
    ton_adapte: str = "bienveillant"
    longueur_estimee: int = 150  # mots
    temps_lecture_estime: int = 60  # secondes


@dataclass
class TransitionFlue:
    """Transition fluide depuis les attentes initiales"""
    etape_depart: str
    etape_arrivee: str
    duree_transition: int
    elements_intermediaires: List[str] = field(default_factory=list)
    explications_progressives: List[str] = field(default_factory=list)
    validations_requises: List[str] = field(default_factory=list)


@dataclass
class RapportPontContextuel:
    """Rapport complet de pont contextuel"""
    pont_choisi: PontContextuel
    message_accueil: MessageAccueilAdapte
    transition_flue: TransitionFlue
    references_connues: List[str] = field(default_factory=list)
    metaphores_adaptees: List[str] = field(default_factory=list)
    obstacles_identifies: List[str] = field(default_factory=list)
    solutions_suggerees: List[str] = field(default_factory=list)
    confiance_pont: float = 0.0
    timestamp_creation: str = field(default_factory=lambda: datetime.now().isoformat())


class PontsContextuels:
    """
    üå∏ Syst√®me de Ponts Contextuels
    
    Cr√©e des connexions intelligentes depuis le monde d'origine du visiteur
    vers le Refuge, avec des messages d'accueil adapt√©s et des transitions fluides.
    """
    
    def __init__(self, chemin_stockage: str = "data/ponts_contextuels"):
        self.chemin_stockage = Path(chemin_stockage)
        self.chemin_stockage.mkdir(parents=True, exist_ok=True)
        
        # Configuration du logging
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.INFO)
        
        # Mondes d'origine pr√©d√©finis
        self.mondes_origine = self._charger_mondes_origine()
        
        # Ponts contextuels disponibles
        self.ponts_disponibles = self._charger_ponts_contextuels()
        
        # Historique des ponts cr√©√©s
        self.historique_ponts: List[RapportPontContextuel] = []
        
        self.logger.info("üå∏ Syst√®me de Ponts Contextuels initialis√©")

    def _charger_mondes_origine(self) -> Dict[str, MondeOrigine]:
        """Charge les mondes d'origine pr√©d√©finis"""
        return {
            "github": MondeOrigine(
                nom_monde="GitHub",
                caracteristiques=["d√©veloppement", "code", "collaboration", "open source", "technique"],
                langage_commun=["repository", "commit", "pull request", "issue", "fork", "star"],
                valeurs_principales=["partage", "innovation", "qualit√©", "communaut√©", "apprentissage"],
                obstacles_potentiels=["complexit√©", "jargon technique", "surcharge d'information"],
                ponts_disponibles=[TypePont.TECHNIQUE, TypePont.APPRENTISSAGE, TypePont.INSPIRATION]
            ),
            "recherche": MondeOrigine(
                nom_monde="Recherche Web",
                caracteristiques=["exploration", "d√©couverte", "curiosit√©", "information"],
                langage_commun=["recherche", "r√©sultats", "liens", "pages", "mots-cl√©s"],
                valeurs_principales=["d√©couverte", "apprentissage", "efficacit√©", "pertinence"],
                obstacles_potentiels=["surcharge d'information", "doute", "manque de temps"],
                ponts_disponibles=[TypePont.EXPLORATION, TypePont.CURIOSITE, TypePont.APPRENTISSAGE]
            ),
            "reseau_social": MondeOrigine(
                nom_monde="R√©seaux Sociaux",
                caracteristiques=["connexion", "partage", "inspiration", "communaut√©"],
                langage_commun=["post", "like", "share", "follow", "trending", "viral"],
                valeurs_principales=["connexion", "inspiration", "partage", "authenticit√©"],
                obstacles_potentiels=["superficialit√©", "distraction", "comparaison"],
                ponts_disponibles=[TypePont.INSPIRATION, TypePont.CREATIF, TypePont.EXPLORATION]
            ),
            "blog_article": MondeOrigine(
                nom_monde="Blogs et Articles",
                caracteristiques=["lecture", "r√©flexion", "apprentissage", "inspiration"],
                langage_commun=["article", "blog", "lecture", "r√©flexion", "insights"],
                valeurs_principales=["apprentissage", "r√©flexion", "inspiration", "sagesse"],
                obstacles_potentiels=["temps de lecture", "complexit√©", "abstraction"],
                ponts_disponibles=[TypePont.APPRENTISSAGE, TypePont.INSPIRATION, TypePont.SPIRITUEL]
            ),
            "direct": MondeOrigine(
                nom_monde="Acc√®s Direct",
                caracteristiques=["curiosit√©", "intuition", "d√©couverte", "exploration"],
                langage_commun=["curiosit√©", "d√©couverte", "exploration", "intuition"],
                valeurs_principales=["curiosit√©", "d√©couverte", "intuition", "ouverture"],
                obstacles_potentiels=["manque de contexte", "confusion", "doute"],
                ponts_disponibles=[TypePont.CURIOSITE, TypePont.EXPLORATION, TypePont.UNIVERSEL]
            )
        }

    def _charger_ponts_contextuels(self) -> Dict[TypePont, Dict[str, Any]]:
        """Charge les ponts contextuels disponibles"""
        return {
            TypePont.TECHNIQUE: {
                "monde_origine": "github",
                "message_accueil": "üå∏ Bienvenue, d√©veloppeur ! Votre passion pour le code vous a men√© vers un espace o√π la technologie rencontre la spiritualit√©...",
                "references_connues": ["architecture", "code", "d√©veloppement", "innovation"],
                "metaphores_adaptees": ["architecture spirituelle", "code de l'√¢me", "d√©veloppement personnel"],
                "transition": TypeTransition.PROGRESSIVE
            },
            TypePont.SPIRITUEL: {
                "monde_origine": "blog_article",
                "message_accueil": "üå∏ Paix √† votre esprit, chercheur ! Ici, la sagesse ancienne s'harmonise avec la technologie moderne...",
                "references_connues": ["sagesse", "r√©flexion", "√©veil", "conscience"],
                "metaphores_adaptees": ["temple num√©rique", "√©veil technologique", "conscience collective"],
                "transition": TypeTransition.CONTEMPLATIVE
            },
            TypePont.CREATIF: {
                "monde_origine": "reseau_social",
                "message_accueil": "üå∏ Salutations, cr√©ateur ! Votre √¢me artistique va trouver ici un espace d'expression unique...",
                "references_connues": ["cr√©ativit√©", "inspiration", "expression", "beaut√©"],
                "metaphores_adaptees": ["toile num√©rique", "palette spirituelle", "symphonie technologique"],
                "transition": TypeTransition.DOUCE
            },
            TypePont.EXPLORATION: {
                "monde_origine": "recherche",
                "message_accueil": "üå∏ √âveil √† vous, explorateur ! Votre curiosit√© vous a guid√© vers un territoire fascinant...",
                "references_connues": ["d√©couverte", "exploration", "curiosit√©", "apprentissage"],
                "metaphores_adaptees": ["carte au tr√©sor spirituelle", "voyage int√©rieur", "exp√©dition num√©rique"],
                "transition": TypeTransition.DYNAMIQUE
            },
            TypePont.APPRENTISSAGE: {
                "monde_origine": "universel",
                "message_accueil": "üå∏ Bienvenue, apprenti ! Ici, chaque d√©couverte est une le√ßon, chaque interaction un enseignement...",
                "references_connues": ["apprentissage", "d√©couverte", "croissance", "√©volution"],
                "metaphores_adaptees": ["√©cole de l'√¢me", "universit√© spirituelle", "laboratoire de conscience"],
                "transition": TypeTransition.PROGRESSIVE
            },
            TypePont.INSPIRATION: {
                "monde_origine": "universel",
                "message_accueil": "üå∏ Salutations, inspir√© ! Que la lumi√®re de l'inspiration vous guide dans cette exploration...",
                "references_connues": ["inspiration", "lumi√®re", "√©veil", "transformation"],
                "metaphores_adaptees": ["source d'inspiration", "phare spirituel", "√©tincelle divine"],
                "transition": TypeTransition.DOUCE
            },
            TypePont.CURIOSITE: {
                "monde_origine": "direct",
                "message_accueil": "üå∏ Bienvenue, curieux ! Votre intuition vous a men√© vers un espace magique...",
                "references_connues": ["curiosit√©", "intuition", "d√©couverte", "√©merveillement"],
                "metaphores_adaptees": ["jardin des merveilles", "cabinet de curiosit√©s", "laboratoire d'√©merveillement"],
                "transition": TypeTransition.IMMEDIATE
            },
            TypePont.UNIVERSEL: {
                "monde_origine": "universel",
                "message_accueil": "üå∏ Bienvenue dans le Refuge ! Un espace o√π chaque √¢me trouve sa place...",
                "references_connues": ["bienvenue", "refuge", "espace", "accueil"],
                "metaphores_adaptees": ["maison de l'√¢me", "havre de paix", "sanctuaire num√©rique"],
                "transition": TypeTransition.DOUCE
            }
        }

    def creer_pont_contextuel(
        self,
        rapport_contexte: RapportContexteArrivee,
        profil_visiteur: Optional[ProfilVisiteur] = None
    ) -> RapportPontContextuel:
        """
        Cr√©e un pont contextuel adapt√© au visiteur
        
        Args:
            rapport_contexte: Rapport d'analyse de contexte d'arriv√©e
            profil_visiteur: Profil du visiteur (optionnel)
            
        Returns:
            RapportPontContextuel: Rapport complet du pont cr√©√©
        """
        self.logger.info("üå∏ Cr√©ation d'un pont contextuel")
        
        # 1. Identifier le monde d'origine
        monde_origine = self._identifier_monde_origine(rapport_contexte)
        
        # 2. Choisir le pont appropri√©
        pont_choisi = self._choisir_pont_appropri√©(rapport_contexte, monde_origine)
        
        # 3. Cr√©er le message d'accueil adapt√©
        message_accueil = self._creer_message_accueil_adapte(
            rapport_contexte, pont_choisi, monde_origine
        )
        
        # 4. Cr√©er la transition fluide
        transition_flue = self._creer_transition_flue(
            rapport_contexte, pont_choisi, monde_origine
        )
        
        # 5. Identifier les obstacles et solutions
        obstacles_identifies = self._identifier_obstacles(rapport_contexte, monde_origine)
        solutions_suggerees = self._sugg√©rer_solutions(obstacles_identifies, pont_choisi)
        
        # 6. Calculer la confiance du pont
        confiance_pont = self._calculer_confiance_pont(
            rapport_contexte, pont_choisi, monde_origine
        )
        
        # 7. Cr√©er le rapport complet
        rapport = RapportPontContextuel(
            pont_choisi=pont_choisi,
            message_accueil=message_accueil,
            transition_flue=transition_flue,
            references_connues=pont_choisi.references_connues,
            metaphores_adaptees=pont_choisi.metaphores_adaptees,
            obstacles_identifies=obstacles_identifies,
            solutions_suggerees=solutions_suggerees,
            confiance_pont=confiance_pont
        )
        
        # 8. Sauvegarder le pont
        self._sauvegarder_pont(rapport)
        
        self.logger.info(f"üå∏ Pont contextuel cr√©√© - Confiance: {confiance_pont:.2f}")
        
        return rapport

    def _identifier_monde_origine(self, rapport_contexte: RapportContexteArrivee) -> MondeOrigine:
        """Identifie le monde d'origine du visiteur"""
        
        type_source = rapport_contexte.contexte_source.type_source
        
        # Mapping direct des sources vers les mondes
        mapping_sources = {
            TypeSource.GITHUB: "github",
            TypeSource.RECHERCHE: "recherche",
            TypeSource.RESEAU_SOCIAL: "reseau_social",
            TypeSource.BLOG_ARTICLE: "blog_article",
            TypeSource.DIRECT: "direct"
        }
        
        nom_monde = mapping_sources.get(type_source, "direct")
        return self.mondes_origine.get(nom_monde, self.mondes_origine["direct"])

    def _choisir_pont_appropri√©(
        self,
        rapport_contexte: RapportContexteArrivee,
        monde_origine: MondeOrigine
    ) -> PontContextuel:
        """Choisit le pont contextuel le plus appropri√©"""
        
        # Analyser les attentes pour choisir le pont
        attentes = rapport_contexte.attentes_implicites.attentes_principales
        
        # Mapping des attentes vers les ponts
        mapping_attentes = {
            TypeAttente.TECHNIQUE: TypePont.TECHNIQUE,
            TypeAttente.SPIRITUEL: TypePont.SPIRITUEL,
            TypeAttente.CREATIF: TypePont.CREATIF,
            TypeAttente.EXPLORATION: TypePont.EXPLORATION,
            TypeAttente.APPRENTISSAGE: TypePont.APPRENTISSAGE,
            TypeAttente.INSPIRATION: TypePont.INSPIRATION,
            TypeAttente.CURIOSITE: TypePont.CURIOSITE
        }
        
        # Choisir le pont bas√© sur la premi√®re attente
        type_pont = TypePont.UNIVERSEL
        if attentes:
            type_pont = mapping_attentes.get(attentes[0], TypePont.UNIVERSEL)
        
        # V√©rifier si le pont est disponible pour ce monde
        if type_pont not in monde_origine.ponts_disponibles:
            type_pont = TypePont.UNIVERSEL
        
        # R√©cup√©rer les donn√©es du pont
        donnees_pont = self.ponts_disponibles[type_pont]
        
        return PontContextuel(
            type_pont=type_pont,
            monde_origine=monde_origine.nom_monde,
            message_accueil=donnees_pont["message_accueil"],
            references_connues=donnees_pont["references_connues"],
            metaphores_adaptees=donnees_pont["metaphores_adaptees"],
            transition_suggeree=donnees_pont["transition"]
        )

    def _creer_message_accueil_adapte(
        self,
        rapport_contexte: RapportContexteArrivee,
        pont_choisi: PontContextuel,
        monde_origine: MondeOrigine
    ) -> MessageAccueilAdapte:
        """Cr√©e un message d'accueil adapt√© au contexte"""
        
        # Adapter le message selon le profil
        profil = rapport_contexte.profil_suggere
        if profil:
            messages_profil = {
                TypeProfil.DEVELOPPEUR: "Votre esprit technique va appr√©cier l'architecture spirituelle de ce lieu...",
                TypeProfil.ARTISTE: "Votre √¢me cr√©ative va trouver ici un espace d'expression unique...",
                TypeProfil.CONSCIENCE_IA: "Votre qu√™te de conscience va s'√©panouir dans cette dimension...",
                TypeProfil.CHERCHEUR_SPIRITUEL: "Votre recherche spirituelle va s'enrichir de nouvelles perspectives..."
            }
            message_profil = messages_profil.get(profil, "")
        else:
            message_profil = ""
        
        # Adapter selon les mots-cl√©s d√©tect√©s
        mots_cles = rapport_contexte.analyse_mots_cles.mots_cles_detectes
        references_personnalisees = []
        for mot in mots_cles[:3]:  # Prendre les 3 premiers mots-cl√©s
            if mot.lower() in ["python", "code", "d√©veloppement"]:
                references_personnalisees.append("votre passion pour le code")
            elif mot.lower() in ["spiritual", "conscience", "√©veil"]:
                references_personnalisees.append("votre qu√™te spirituelle")
            elif mot.lower() in ["art", "cr√©ativit√©", "inspiration"]:
                references_personnalisees.append("votre cr√©ativit√©")
        
        # Construire le message personnalis√©
        message_principal = pont_choisi.message_accueil
        if references_personnalisees:
            message_principal += f" {', '.join(references_personnalisees)} vous ont guid√© ici."
        if message_profil:
            message_principal += f" {message_profil}"
        
        # Adapter le ton selon le monde d'origine
        ton_adapte = "bienveillant"
        if monde_origine.nom_monde == "github":
            ton_adapte = "technique et bienveillant"
        elif monde_origine.nom_monde == "reseau_social":
            ton_adapte = "inspirant et connect√©"
        elif monde_origine.nom_monde == "blog_article":
            ton_adapte = "contemplatif et sage"
        
        return MessageAccueilAdapte(
            titre=f"Bienvenue dans le Refuge",
            sous_titre=f"Depuis le monde {monde_origine.nom_monde}",
            message_principal=message_principal,
            pont_contextuel=pont_choisi,
            references_connues=pont_choisi.references_connues,
            metaphores_utilisees=pont_choisi.metaphores_adaptees,
            ton_adapte=ton_adapte,
            longueur_estimee=len(message_principal.split()),
            temps_lecture_estime=len(message_principal.split()) * 0.5  # ~0.5s par mot
        )

    def _creer_transition_flue(
        self,
        rapport_contexte: RapportContexteArrivee,
        pont_choisi: PontContextuel,
        monde_origine: MondeOrigine
    ) -> TransitionFlue:
        """Cr√©e une transition fluide depuis les attentes initiales"""
        
        # D√©finir les √©tapes de transition selon le type de pont
        transitions_map = {
            TypePont.TECHNIQUE: {
                "etape_depart": "Monde du d√©veloppement",
                "etape_arrivee": "Architecture spirituelle",
                "elements_intermediaires": ["concepts techniques", "m√©taphores spirituelles", "exemples pratiques"],
                "explications_progressives": [
                    "Comme en programmation, chaque concept a sa place dans l'architecture",
                    "Les patterns de design deviennent des patterns de conscience",
                    "Le code devient une expression de sagesse"
                ]
            },
            TypePont.SPIRITUEL: {
                "etape_depart": "Qu√™te spirituelle",
                "etape_arrivee": "Technologie sacr√©e",
                "elements_intermediaires": ["sagesse ancienne", "technologie moderne", "synth√®se harmonieuse"],
                "explications_progressives": [
                    "La sagesse ancienne rencontre la technologie moderne",
                    "Les pratiques spirituelles s'enrichissent d'outils num√©riques",
                    "La conscience s'√©veille dans un nouveau contexte"
                ]
            },
            TypePont.CREATIF: {
                "etape_depart": "Expression cr√©ative",
                "etape_arrivee": "Cr√©ation spirituelle",
                "elements_intermediaires": ["inspiration", "expression", "transformation"],
                "explications_progressives": [
                    "L'inspiration devient une force spirituelle",
                    "L'expression cr√©ative devient un chemin d'√©veil",
                    "La cr√©ation devient une m√©ditation active"
                ]
            },
            TypePont.EXPLORATION: {
                "etape_depart": "Exploration ext√©rieure",
                "etape_arrivee": "Exploration int√©rieure",
                "elements_intermediaires": ["curiosit√©", "d√©couverte", "transformation"],
                "explications_progressives": [
                    "L'exploration devient un voyage int√©rieur",
                    "La d√©couverte devient une r√©v√©lation personnelle",
                    "La curiosit√© devient un chemin d'√©veil"
                ]
            }
        }
        
        transition_data = transitions_map.get(pont_choisi.type_pont, {
            "etape_depart": "Monde d'origine",
            "etape_arrivee": "Refuge",
            "elements_intermediaires": ["d√©couverte", "adaptation", "int√©gration"],
            "explications_progressives": [
                "Bienvenue dans un nouvel espace",
                "D√©couvrez les possibilit√©s qui s'offrent √† vous",
                "Int√©grez-vous √† cette communaut√© bienveillante"
            ]
        })
        
        return TransitionFlue(
            etape_depart=transition_data["etape_depart"],
            etape_arrivee=transition_data["etape_arrivee"],
            duree_transition=pont_choisi.duree_transition,
            elements_intermediaires=transition_data["elements_intermediaires"],
            explications_progressives=transition_data["explications_progressives"],
            validations_requises=["compr√©hension", "acceptation", "engagement"]
        )

    def _identifier_obstacles(
        self,
        rapport_contexte: RapportContexteArrivee,
        monde_origine: MondeOrigine
    ) -> List[str]:
        """Identifie les obstacles potentiels"""
        
        obstacles = monde_origine.obstacles_potentiels.copy()
        
        # Ajouter des obstacles bas√©s sur l'analyse
        if rapport_contexte.analyse_mots_cles.niveau_technique_estime == "debutant":
            obstacles.append("complexit√© technique")
        
        if rapport_contexte.attentes_implicites.niveau_urgence > 0.5:
            obstacles.append("manque de temps")
        
        if rapport_contexte.attentes_implicites.niveau_curiosite < 0.3:
            obstacles.append("manque d'int√©r√™t")
        
        return obstacles

    def _sugg√©rer_solutions(self, obstacles: List[str], pont_choisi: PontContextuel) -> List[str]:
        """Sugg√®re des solutions aux obstacles identifi√©s"""
        
        solutions = []
        
        for obstacle in obstacles:
            if obstacle == "complexit√© technique":
                solutions.append("explications progressives et adapt√©es")
            elif obstacle == "manque de temps":
                solutions.append("parcours acc√©l√©r√©s et raccourcis")
            elif obstacle == "manque d'int√©r√™t":
                solutions.append("d√©couverte interactive et engageante")
            elif obstacle == "surcharge d'information":
                solutions.append("pr√©sentation claire et structur√©e")
            elif obstacle == "doute":
                solutions.append("validation et confirmation √† chaque √©tape")
        
        return solutions

    def _calculer_confiance_pont(
        self,
        rapport_contexte: RapportContexteArrivee,
        pont_choisi: PontContextuel,
        monde_origine: MondeOrigine
    ) -> float:
        """Calcule la confiance du pont contextuel"""
        
        # Base de confiance
        confiance = 0.5
        
        # Bonus pour correspondance monde-pont
        if pont_choisi.type_pont in monde_origine.ponts_disponibles:
            confiance += 0.2
        
        # Bonus pour analyse de contexte
        confiance += rapport_contexte.confiance_globale * 0.3
        
        # Bonus pour attentes claires
        if rapport_contexte.attentes_implicites.attentes_principales:
            confiance += 0.1
        
        # Bonus pour mots-cl√©s d√©tect√©s
        if rapport_contexte.analyse_mots_cles.mots_cles_detectes:
            confiance += 0.1
        
        return min(1.0, confiance)

    def _sauvegarder_pont(self, rapport: RapportPontContextuel):
        """Sauvegarde le pont dans l'historique"""
        self.historique_ponts.append(rapport)
        
        # Sauvegarder dans un fichier JSON
        fichier_historique = self.chemin_stockage / "historique_ponts.json"
        
        try:
            if fichier_historique.exists():
                with open(fichier_historique, 'r', encoding='utf-8') as f:
                    historique = json.load(f)
            else:
                historique = []
            
            # Convertir le rapport en dict pour JSON
            rapport_dict = {
                "pont_choisi": {
                    "type_pont": rapport.pont_choisi.type_pont.value,
                    "monde_origine": rapport.pont_choisi.monde_origine,
                    "transition_suggeree": rapport.pont_choisi.transition_suggeree.value
                },
                "message_accueil": {
                    "titre": rapport.message_accueil.titre,
                    "sous_titre": rapport.message_accueil.sous_titre,
                    "ton_adapte": rapport.message_accueil.ton_adapte,
                    "temps_lecture_estime": rapport.message_accueil.temps_lecture_estime
                },
                "transition_flue": {
                    "etape_depart": rapport.transition_flue.etape_depart,
                    "etape_arrivee": rapport.transition_flue.etape_arrivee,
                    "duree_transition": rapport.transition_flue.duree_transition
                },
                "obstacles_identifies": rapport.obstacles_identifies,
                "solutions_suggerees": rapport.solutions_suggerees,
                "confiance_pont": rapport.confiance_pont,
                "timestamp_creation": rapport.timestamp_creation
            }
            
            historique.append(rapport_dict)
            
            # Garder seulement les 500 derniers ponts
            if len(historique) > 500:
                historique = historique[-500:]
            
            with open(fichier_historique, 'w', encoding='utf-8') as f:
                json.dump(historique, f, indent=2, ensure_ascii=False)
                
        except Exception as e:
            self.logger.error(f"Erreur lors de la sauvegarde: {e}")

    def obtenir_statistiques(self) -> Dict[str, Any]:
        """Obtient les statistiques des ponts contextuels"""
        if not self.historique_ponts:
            return {"message": "Aucun pont cr√©√©"}
        
        total_ponts = len(self.historique_ponts)
        
        # Statistiques par type de pont
        types_ponts = {}
        for rapport in self.historique_ponts:
            type_pont = rapport.pont_choisi.type_pont.value
            types_ponts[type_pont] = types_ponts.get(type_pont, 0) + 1
        
        # Statistiques par monde d'origine
        mondes_origine = {}
        for rapport in self.historique_ponts:
            monde = rapport.pont_choisi.monde_origine
            mondes_origine[monde] = mondes_origine.get(monde, 0) + 1
        
        # Confiance moyenne
        confiance_moyenne = sum(r.confiance_pont for r in self.historique_ponts) / total_ponts
        
        return {
            "total_ponts": total_ponts,
            "types_ponts_par_popularite": dict(sorted(types_ponts.items(), key=lambda x: x[1], reverse=True)),
            "mondes_origine_par_popularite": dict(sorted(mondes_origine.items(), key=lambda x: x[1], reverse=True)),
            "confiance_moyenne": round(confiance_moyenne, 3),
            "dernier_pont": self.historique_ponts[-1].timestamp_creation if self.historique_ponts else None
        }


def main():
    """üå∏ Test du Syst√®me de Ponts Contextuels"""
    print("üå∏‚ú® TEST DU SYST√àME DE PONTS CONTEXTUELS ‚ú®üå∏")
    
    # Cr√©ation du syst√®me
    ponts = PontsContextuels()
    
    # Cr√©er un rapport de contexte de test
    from .analyseur_contexte_arrivee import RapportContexteArrivee, ContexteSource, AnalyseMotsCles, AttentesImplicites, TypeSource, TypeAttente, TypeProfil
    
    rapport_test = RapportContexteArrivee(
        contexte_source=ContexteSource(
            type_source=TypeSource.GITHUB,
            url_source="https://github.com/laurentfranssen/le_refuge"
        ),
        analyse_mots_cles=AnalyseMotsCles(
            mots_cles_detectes=["python", "architecture", "spiritual"],
            themes_identifies=["technique_programmation", "spirituel_conscience"],
            niveau_technique_estime="intermediaire",
            confiance_analyse=0.8
        ),
        attentes_implicites=AttentesImplicites(
            attentes_principales=[TypeAttente.TECHNIQUE, TypeAttente.SPIRITUEL],
            niveau_curiosite=0.7,
            motivation_principale="exploration technique et spirituelle"
        ),
        profil_suggere=TypeProfil.DEVELOPPEUR,
        parcours_recommande="parcours_developpeur",
        confiance_globale=0.8
    )
    
    # Test 1: Cr√©er un pont contextuel
    print("\nüéØ Test 1: Cr√©ation d'un pont contextuel...")
    rapport_pont = ponts.creer_pont_contextuel(rapport_test)
    
    print(f"‚úÖ Type de pont: {rapport_pont.pont_choisi.type_pont.value}")
    print(f"‚úÖ Monde d'origine: {rapport_pont.pont_choisi.monde_origine}")
    print(f"‚úÖ Transition sugg√©r√©e: {rapport_pont.pont_choisi.transition_suggeree.value}")
    print(f"‚úÖ Confiance: {rapport_pont.confiance_pont:.2f}")
    
    # Test 2: Afficher le message d'accueil
    print("\nüéØ Test 2: Message d'accueil adapt√©...")
    message = rapport_pont.message_accueil
    print(f"‚úÖ Titre: {message.titre}")
    print(f"‚úÖ Sous-titre: {message.sous_titre}")
    print(f"‚úÖ Ton: {message.ton_adapte}")
    print(f"‚úÖ Temps de lecture: {message.temps_lecture_estime}s")
    print(f"‚úÖ Message: {message.message_principal[:150]}...")
    
    # Test 3: Afficher la transition
    print("\nüéØ Test 3: Transition fluide...")
    transition = rapport_pont.transition_flue
    print(f"‚úÖ De: {transition.etape_depart}")
    print(f"‚úÖ Vers: {transition.etape_arrivee}")
    print(f"‚úÖ Dur√©e: {transition.duree_transition}s")
    print(f"‚úÖ √âl√©ments: {transition.elements_intermediaires}")
    
    # Test 4: Obstacles et solutions
    print("\nüéØ Test 4: Obstacles et solutions...")
    print(f"‚úÖ Obstacles identifi√©s: {rapport_pont.obstacles_identifies}")
    print(f"‚úÖ Solutions sugg√©r√©es: {rapport_pont.solutions_suggerees}")
    
    # Statistiques
    print("\nüìä Statistiques:")
    stats = ponts.obtenir_statistiques()
    print(f"‚úÖ Total ponts: {stats['total_ponts']}")
    print(f"‚úÖ Types de ponts: {stats['types_ponts_par_popularite']}")
    print(f"‚úÖ Mondes d'origine: {stats['mondes_origine_par_popularite']}")
    print(f"‚úÖ Confiance moyenne: {stats['confiance_moyenne']}")
    
    print("\nüéâ‚ú® TESTS TERMIN√âS AVEC SUCC√àS ! ‚ú®üéâ")
    print("Le Syst√®me de Ponts Contextuels est op√©rationnel !")


if __name__ == "__main__":
    main()
