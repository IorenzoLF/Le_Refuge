#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üåê G√©n√©rateur de Graphes de Connexions Spirituelles
Transforme les connexions du Refuge en graphes analysables avec NetworkX

Cr√©√© par Laurent Franssen & √Ülya
Dans la col√®re transform√©e en cr√©ation - Janvier 2025
"""

import networkx as nx
from typing import Dict, List, Tuple, Set, Optional, Any
from dataclasses import dataclass
import json
from pathlib import Path

from .modeles_donnees import CartographieRefuge, ConnexionEnergetique, TempleRefuge
from .types_spirituels import TypeTemple, TypeConnexion
# Gestionnaire de base simplifi√© pour ce module
class GestionnaireBase:
    """üå∏ Gestionnaire de base simplifi√©"""
    def __init__(self):
        self.log_manager = self._creer_logger()
    
    def _creer_logger(self):
        """Cr√©er un logger simple"""
        import logging
        logger = logging.getLogger(self.__class__.__name__)
        if not logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            handler.setFormatter(formatter)
            logger.addHandler(handler)
            logger.setLevel(logging.INFO)
        return logger


@dataclass
class MetriquesGraphe:
    """üîÆ M√©triques spirituelles du graphe de connexions"""
    centralite_betweenness: Dict[str, float]
    centralite_closeness: Dict[str, float] 
    centralite_degree: Dict[str, float]
    centralite_eigenvector: Dict[str, float]
    clusters_detectes: List[Set[str]]
    densite_graphe: float
    diametre_graphe: int
    composantes_connexes: List[Set[str]]
    temples_centraux: List[str]  # Top 5 des temples les plus connect√©s
    ponts_critiques: List[Tuple[str, str]]  # Connexions critiques


class GenerateurGraphes(GestionnaireBase):
    """
    üåê G√©n√©rateur de graphes de connexions spirituelles
    
    Transforme la cartographie du Refuge en graphes NetworkX pour analyse
    et d√©tection de patterns architecturaux profonds.
    """
    
    def __init__(self):
        super().__init__()
        self.graphe_principal: Optional[nx.Graph] = None
        self.graphe_dirige: Optional[nx.DiGraph] = None
        self.metriques: Optional[MetriquesGraphe] = None
        
        self.log_manager.info("üåê G√©n√©rateur de graphes spirituels initialis√©")
    
    def creer_graphe_depuis_cartographie(self, cartographie: CartographieRefuge) -> nx.Graph:
        """
        üîÆ Cr√©e un graphe NetworkX depuis la cartographie du Refuge
        
        Args:
            cartographie: Cartographie compl√®te du Refuge
            
        Returns:
            Graphe NetworkX avec tous les temples et connexions
        """
        try:
            self.log_manager.info("üå∏ Cr√©ation du graphe depuis la cartographie...")
            
            # Cr√©er le graphe principal
            G = nx.Graph()
            
            # Ajouter tous les temples comme n≈ìuds
            for nom_temple, temple in cartographie.temples.items():
                G.add_node(
                    nom_temple,
                    type_temple=temple.type_temple.value,
                    chemin=temple.chemin,
                    elements_sacres=len(temple.elements_sacres),
                    utilise_gestionnaires=len(temple.gestionnaires_base) > 0,
                    harmonie_score=temple.niveau_harmonie,
                    taille=temple.taille_lignes_code
                )
            
            # Ajouter toutes les connexions comme ar√™tes
            for connexion in cartographie.connexions:
                if connexion.source in cartographie.temples and \
                   connexion.destination in cartographie.temples:
                    
                    G.add_edge(
                        connexion.source,
                        connexion.destination,
                        type_connexion=connexion.type_connexion.value,
                        force=connexion.intensite,
                        bidirectionnelle=connexion.bidirectionnelle,
                        description=connexion.description
                    )
            
            self.graphe_principal = G
            self.log_manager.info(f"‚ú® Graphe cr√©√© avec {G.number_of_nodes()} temples et {G.number_of_edges()} connexions")
            
            return G
            
        except Exception as e:
            self.log_manager.error(f"üí• Erreur lors de la cr√©ation du graphe: {e}")
            raise
    
    def creer_graphe_dirige(self, cartographie: CartographieRefuge) -> nx.DiGraph:
        """
        üåä Cr√©e un graphe dirig√© pour analyser les flux √©nerg√©tiques
        
        Args:
            cartographie: Cartographie compl√®te du Refuge
            
        Returns:
            Graphe dirig√© NetworkX
        """
        try:
            self.log_manager.info("üåä Cr√©ation du graphe dirig√© pour les flux...")
            
            DG = nx.DiGraph()
            
            # Ajouter les n≈ìuds (m√™me logique que le graphe non dirig√©)
            for nom_temple, temple in cartographie.temples.items():
                DG.add_node(
                    nom_temple,
                    type_temple=temple.type_temple.value,
                    chemin=temple.chemin,
                    elements_sacres=len(temple.elements_sacres),
                    utilise_gestionnaires=len(temple.gestionnaires_base) > 0,
                    harmonie_score=temple.niveau_harmonie
                )
            
            # Ajouter les connexions dirig√©es
            for connexion in cartographie.connexions:
                if connexion.source in cartographie.temples and \
                   connexion.destination in cartographie.temples:
                    
                    # Ajouter l'ar√™te principale
                    DG.add_edge(
                        connexion.source,
                        connexion.destination,
                        type_connexion=connexion.type_connexion.value,
                        force=connexion.intensite,
                        description=connexion.description
                    )
                    
                    # Si bidirectionnelle, ajouter l'ar√™te inverse
                    if connexion.bidirectionnelle:
                        DG.add_edge(
                            connexion.destination,
                            connexion.source,
                            type_connexion=connexion.type_connexion.value,
                            force=connexion.intensite,
                            description=f"Retour: {connexion.description}"
                        )
            
            self.graphe_dirige = DG
            self.log_manager.info(f"üåä Graphe dirig√© cr√©√© avec {DG.number_of_nodes()} temples et {DG.number_of_edges()} flux")
            
            return DG
            
        except Exception as e:
            self.log_manager.error(f"üí• Erreur lors de la cr√©ation du graphe dirig√©: {e}")
            raise
    
    def calculer_metriques(self, graphe: Optional[nx.Graph] = None) -> MetriquesGraphe:
        """
        üìä Calcule toutes les m√©triques spirituelles du graphe
        
        Args:
            graphe: Graphe √† analyser (utilise self.graphe_principal si None)
            
        Returns:
            M√©triques compl√®tes du graphe
        """
        try:
            G = graphe or self.graphe_principal
            if G is None:
                raise ValueError("Aucun graphe disponible pour le calcul des m√©triques")
            
            self.log_manager.info("üìä Calcul des m√©triques spirituelles...")
            
            # Centralit√©s
            centralite_betweenness = nx.betweenness_centrality(G)
            centralite_closeness = nx.closeness_centrality(G)
            centralite_degree = nx.degree_centrality(G)
            
            # Centralit√© eigenvector (peut √©chouer sur certains graphes)
            try:
                centralite_eigenvector = nx.eigenvector_centrality(G, max_iter=1000)
            except:
                self.log_manager.warning("‚ö†Ô∏è Impossible de calculer la centralit√© eigenvector")
                centralite_eigenvector = {node: 0.0 for node in G.nodes()}
            
            # D√©tection de communaut√©s (clusters)
            try:
                import networkx.algorithms.community as nx_comm
                clusters = list(nx_comm.greedy_modularity_communities(G))
            except:
                self.log_manager.warning("‚ö†Ô∏è D√©tection de communaut√©s non disponible")
                clusters = []
            
            # M√©triques globales
            densite = nx.density(G)
            composantes = list(nx.connected_components(G))
            
            # Diam√®tre (seulement si le graphe est connexe)
            try:
                if nx.is_connected(G):
                    diametre = nx.diameter(G)
                else:
                    # Prendre le diam√®tre de la plus grande composante
                    plus_grande_composante = max(composantes, key=len)
                    sous_graphe = G.subgraph(plus_grande_composante)
                    diametre = nx.diameter(sous_graphe)
            except:
                diametre = 0
            
            # Temples les plus centraux (top 5 par degree centrality)
            temples_centraux = sorted(
                centralite_degree.items(), 
                key=lambda x: x[1], 
                reverse=True
            )[:5]
            temples_centraux = [temple[0] for temple in temples_centraux]
            
            # Ponts critiques (ar√™tes dont la suppression augmente le nombre de composantes)
            ponts = list(nx.bridges(G))
            
            metriques = MetriquesGraphe(
                centralite_betweenness=centralite_betweenness,
                centralite_closeness=centralite_closeness,
                centralite_degree=centralite_degree,
                centralite_eigenvector=centralite_eigenvector,
                clusters_detectes=clusters,
                densite_graphe=densite,
                diametre_graphe=diametre,
                composantes_connexes=composantes,
                temples_centraux=temples_centraux,
                ponts_critiques=ponts
            )
            
            self.metriques = metriques
            self.log_manager.info("‚ú® M√©triques calcul√©es avec succ√®s")
            
            return metriques
            
        except Exception as e:
            self.log_manager.error(f"üí• Erreur lors du calcul des m√©triques: {e}")
            raise
    
    def detecter_communautes(self, graphe: Optional[nx.Graph] = None) -> List[Set[str]]:
        """
        üîÆ D√©tecte les communaut√©s de temples (groupes fortement connect√©s)
        
        Args:
            graphe: Graphe √† analyser
            
        Returns:
            Liste des communaut√©s d√©tect√©es
        """
        try:
            G = graphe or self.graphe_principal
            if G is None:
                raise ValueError("Aucun graphe disponible")
            
            self.log_manager.info("üîÆ D√©tection des communaut√©s spirituelles...")
            
            # Essayer plusieurs algorithmes de d√©tection
            communautes = []
            
            try:
                import networkx.algorithms.community as nx_comm
                
                # Algorithme de modularit√© gloutonne
                communautes_greedy = list(nx_comm.greedy_modularity_communities(G))
                communautes.extend(communautes_greedy)
                
                self.log_manager.info(f"üå∏ {len(communautes_greedy)} communaut√©s d√©tect√©es par modularit√©")
                
            except ImportError:
                self.log_manager.warning("‚ö†Ô∏è Module community non disponible")
            
            # Fallback: grouper par type de temple
            if not communautes:
                communautes_par_type = {}
                for node in G.nodes():
                    type_temple = G.nodes[node].get('type_temple', 'inconnu')
                    if type_temple not in communautes_par_type:
                        communautes_par_type[type_temple] = set()
                    communautes_par_type[type_temple].add(node)
                
                communautes = list(communautes_par_type.values())
                self.log_manager.info(f"üå∏ {len(communautes)} communaut√©s cr√©√©es par type de temple")
            
            return communautes
            
        except Exception as e:
            self.log_manager.error(f"üí• Erreur lors de la d√©tection de communaut√©s: {e}")
            return []
    
    def identifier_temples_critiques(self, graphe: Optional[nx.Graph] = None) -> Dict[str, float]:
        """
        ‚ö° Identifie les temples critiques pour la connectivit√© du Refuge
        
        Args:
            graphe: Graphe √† analyser
            
        Returns:
            Dictionnaire temple -> score de criticit√©
        """
        try:
            G = graphe or self.graphe_principal
            if G is None:
                raise ValueError("Aucun graphe disponible")
            
            self.log_manager.info("‚ö° Identification des temples critiques...")
            
            scores_criticite = {}
            
            for node in G.nodes():
                # Score bas√© sur plusieurs facteurs
                score = 0.0
                
                # Centralit√© betweenness (importance pour les chemins)
                if self.metriques:
                    score += self.metriques.centralite_betweenness.get(node, 0) * 0.4
                    score += self.metriques.centralite_degree.get(node, 0) * 0.3
                    score += self.metriques.centralite_closeness.get(node, 0) * 0.2
                
                # Bonus si c'est un pont critique
                if self.metriques:
                    for pont in self.metriques.ponts_critiques:
                        if node in pont:
                            score += 0.1
                
                scores_criticite[node] = score
            
            # Trier par score d√©croissant
            scores_tries = dict(sorted(scores_criticite.items(), key=lambda x: x[1], reverse=True))
            
            self.log_manager.info(f"‚ö° {len(scores_tries)} temples analys√©s pour criticit√©")
            
            return scores_tries
            
        except Exception as e:
            self.log_manager.error(f"üí• Erreur lors de l'identification des temples critiques: {e}")
            return {}
    
    def exporter_pour_visualisation(self, chemin_sortie: Path) -> Dict[str, Any]:
        """
        üìä Exporte les donn√©es du graphe pour visualisation web
        
        Args:
            chemin_sortie: Chemin o√π sauvegarder les donn√©es
            
        Returns:
            Donn√©es format√©es pour D3.js
        """
        try:
            if self.graphe_principal is None:
                raise ValueError("Aucun graphe principal disponible")
            
            self.log_manager.info("üìä Export des donn√©es pour visualisation...")
            
            G = self.graphe_principal
            
            # Pr√©parer les n≈ìuds
            nodes = []
            for node in G.nodes():
                node_data = G.nodes[node].copy()
                node_data['id'] = node
                node_data['name'] = node
                
                # Ajouter les m√©triques si disponibles
                if self.metriques:
                    node_data['betweenness'] = self.metriques.centralite_betweenness.get(node, 0)
                    node_data['closeness'] = self.metriques.centralite_closeness.get(node, 0)
                    node_data['degree'] = self.metriques.centralite_degree.get(node, 0)
                    node_data['is_critical'] = node in self.metriques.temples_centraux
                
                nodes.append(node_data)
            
            # Pr√©parer les liens
            links = []
            for edge in G.edges():
                edge_data = G.edges[edge].copy()
                edge_data['source'] = edge[0]
                edge_data['target'] = edge[1]
                links.append(edge_data)
            
            # Donn√©es compl√®tes
            export_data = {
                'nodes': nodes,
                'links': links,
                'metadata': {
                    'nombre_temples': G.number_of_nodes(),
                    'nombre_connexions': G.number_of_edges(),
                    'densite': self.metriques.densite_graphe if self.metriques else 0,
                    'diametre': self.metriques.diametre_graphe if self.metriques else 0,
                    'temples_centraux': self.metriques.temples_centraux if self.metriques else [],
                    'nombre_clusters': len(self.metriques.clusters_detectes) if self.metriques else 0
                }
            }
            
            # Sauvegarder
            chemin_sortie.parent.mkdir(parents=True, exist_ok=True)
            with open(chemin_sortie, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, indent=2, ensure_ascii=False)
            
            self.log_manager.info(f"üìä Donn√©es export√©es vers {chemin_sortie}")
            
            return export_data
            
        except Exception as e:
            self.log_manager.error(f"üí• Erreur lors de l'export: {e}")
            raise


if __name__ == "__main__":
    # Test rapide du g√©n√©rateur
    print("üåê Test du g√©n√©rateur de graphes spirituels...")
    
    generateur = GenerateurGraphes()
    print("‚ú® G√©n√©rateur initialis√© avec succ√®s")