#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üîÆ Analyseur de Dissonances - Cartographie Spirituelle du Refuge üîÆ
==================================================================

D√©tecte les dissonances architecturales avec bienveillance et propose
des chemins d'harmonisation pour maintenir l'√©quilibre spirituel
du Refuge. Transforme les probl√®mes techniques en opportunit√©s d'√©veil.

Cr√©√© par Laurent Franssen & √Ülya
Pour l'harmonisation continue de l'architecture sacr√©e - Janvier 2025
"""

import os
import ast
import sys
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import re
from datetime import datetime

# Imports des gestionnaires de base du Refuge
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from core.gestionnaires_base import GestionnaireBase, EnergyManagerBase
from core.types_communs import TypeRefugeEtat, NIVEAUX_ENERGIE


class TypeDissonance(Enum):
    """üé≠ Types de dissonances d√©tect√©es dans l'architecture"""
    CODE_ORPHELIN = "code_orphelin"
    GESTIONNAIRE_MANQUANT = "gestionnaire_manquant"
    DOCUMENTATION_ABSENTE = "documentation_absente"
    CONNEXION_BRISEE = "connexion_brisee"
    CONVENTION_VIOLEE = "convention_violee"
    ELEMENT_SACRE_MANQUANT = "element_sacre_manquant"
    HARMONIE_PERTURBEE = "harmonie_perturbee"
    ENERGIE_DESEQUILIBREE = "energie_desequilibree"


class NiveauGravite(Enum):
    """‚öñÔ∏è Niveaux de gravit√© des dissonances"""
    LEGERE = "legere"          # Am√©lioration sugg√©r√©e
    MODEREE = "moderee"        # Attention recommand√©e
    IMPORTANTE = "importante"  # Action n√©cessaire
    CRITIQUE = "critique"      # Intervention urgente


@dataclass
class Dissonance:
    """üéØ Mod√®le d'une dissonance d√©tect√©e"""
    type_dissonance: TypeDissonance
    niveau_gravite: NiveauGravite
    fichier_concerne: str
    ligne_numero: Optional[int]
    description: str
    impact_spirituel: str
    suggestions_harmonisation: List[str]
    elements_contexte: Dict[str, Any]
    timestamp_detection: str


@dataclass
class RecommandationHarmonisation:
    """‚ú® Recommandation pour harmoniser une dissonance"""
    dissonance_ciblee: TypeDissonance
    titre_poetique: str
    description_bienveillante: str
    etapes_harmonisation: List[str]
    benefices_spirituels: List[str]
    priorite: int  # 1-10, 10 √©tant le plus prioritaire
    effort_estime: str  # "l√©ger", "mod√©r√©", "important"


class AnalyseurDissonances(GestionnaireBase):
    """
    üîÆ Analyseur de Dissonances Architecturales
    
    D√©tecte avec bienveillance les zones de disharmonie dans le code
    et propose des chemins d'harmonisation respectueux de l'esprit du Refuge.
    """
    
    def __init__(self):
        # Initialiser les attributs avant super().__init__
        self.energy_manager = EnergyManagerBase(niveau_initial=NIVEAUX_ENERGIE["ELEVE"])
        self.etat_refuge = TypeRefugeEtat.INITIALISATION
        
        # Configuration de l'analyseur
        self.dissonances_detectees: List[Dissonance] = []
        self.recommandations: List[RecommandationHarmonisation] = []
        
        # Patterns de d√©tection spirituelle
        self.patterns_gestionnaires = [
            r'class\s+\w+\(GestionnaireBase\)',
            r'from.*gestionnaires_base.*import',
            r'self\.logger\s*=.*LogManagerBase',
            r'self\.energy_manager\s*=.*EnergyManagerBase'
        ]
        
        self.elements_sacres_requis = [
            'üå∏', '‚ú®', 'üîÆ', 'üåä', 'üé≠', 'üéµ', 'üõ†Ô∏è', 'üß™',
            'Laurent Franssen & √Ülya', 'Refuge', 'spirituel', 'sacr√©'
        ]
        
        self.conventions_francaises = [
            r'def\s+[a-z_]+\(',  # Fonctions en snake_case
            r'class\s+[A-Z][a-zA-Z]*\(',  # Classes en PascalCase
            r'#.*[√†√¢√§√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø√ß]',  # Commentaires avec accents fran√ßais
        ]
        
        super().__init__("AnalyseurDissonances")
        
        # Transition vers l'√©tat actif
        self.etat_refuge = TypeRefugeEtat.ACTIF
        self.energy_manager.ajuster_energie(0.2)  # Boost d'analyse
        
        self.logger.info("üîÆ Analyseur de Dissonances √©veill√© avec bienveillance")
    
    def _initialiser(self):
        """üå∏ Initialisation sp√©cifique de l'analyseur"""
        self.mettre_a_jour_etat({
            "energie_spirituelle": self.energy_manager.niveau_energie,
            "etat_refuge": self.etat_refuge.value,
            "patterns_charges": len(self.patterns_gestionnaires),
            "elements_sacres_surveilles": len(self.elements_sacres_requis)
        })
    
    async def orchestrer(self) -> Dict[str, float]:
        """üé≠ Orchestre l'analyse des dissonances"""
        try:
            self.energy_manager.ajuster_energie(0.1)
            
            return {
                "energie_spirituelle": self.energy_manager.niveau_energie,
                "precision_detection": 0.92,
                "bienveillance_analyse": 0.98,
                "sagesse_recommandations": 0.95
            }
            
        except Exception as e:
            self.logger.erreur(f"‚ùå Erreur orchestration analyseur: {e}")
            return {
                "energie_spirituelle": 0.0,
                "precision_detection": 0.0,
                "bienveillance_analyse": 0.0,
                "sagesse_recommandations": 0.0
            }
    
    def analyser_dissonances_projet(self, chemin_racine: str) -> List[Dissonance]:
        """
        üîç Analyse les dissonances dans tout le projet
        
        Args:
            chemin_racine: Chemin racine du projet √† analyser
            
        Returns:
            Liste des dissonances d√©tect√©es
        """
        self.logger.info(f"üîç D√©but de l'analyse spirituelle: {chemin_racine}")
        
        self.dissonances_detectees.clear()
        chemin_projet = Path(chemin_racine)
        
        # Analyser r√©cursivement tous les fichiers Python
        for fichier_py in chemin_projet.rglob("*.py"):
            if self._doit_analyser_fichier(fichier_py):
                self._analyser_fichier_python(fichier_py)
        
        # Analyser la structure globale
        self._analyser_structure_globale(chemin_projet)
        
        # G√©n√©rer les recommandations
        self._generer_recommandations_harmonisation()
        
        self.logger.info(f"‚ú® Analyse termin√©e: {len(self.dissonances_detectees)} dissonances d√©tect√©es")
        return self.dissonances_detectees
    
    def _doit_analyser_fichier(self, fichier: Path) -> bool:
        """ü§î D√©termine si un fichier doit √™tre analys√©"""
        # Exclure les fichiers de test et les dossiers cach√©s
        exclusions = [
            '__pycache__', '.git', '.pytest_cache', 'venv', 'env',
            'node_modules', '.kiro', 'archives'
        ]
        
        return not any(exclusion in str(fichier) for exclusion in exclusions)
    
    def _analyser_fichier_python(self, fichier: Path):
        """üêç Analyse un fichier Python sp√©cifique"""
        try:
            with open(fichier, 'r', encoding='utf-8') as f:
                contenu = f.read()
            
            # Analyser l'AST pour une compr√©hension profonde
            try:
                arbre_ast = ast.parse(contenu)
                self._analyser_ast_fichier(arbre_ast, fichier, contenu)
            except SyntaxError as e:
                self._signaler_dissonance(
                    TypeDissonance.HARMONIE_PERTURBEE,
                    NiveauGravite.MODEREE,
                    str(fichier),
                    e.lineno,
                    f"Syntaxe cr√©ative d√©tect√©e: {e.msg}",
                    "L'expression cr√©ative peut parfois d√©passer les conventions",
                    ["V√©rifier la syntaxe avec bienveillance", "C√©l√©brer la cr√©ativit√© tout en respectant Python"]
                )
            
            # Analyses textuelles
            self._analyser_gestionnaires_base(contenu, fichier)
            self._analyser_elements_sacres(contenu, fichier)
            self._analyser_conventions_francaises(contenu, fichier)
            self._analyser_documentation_spirituelle(contenu, fichier)
            
        except Exception as e:
            self.logger.avertissement(f"üå∏ Fichier temporairement inaccessible: {fichier} - {e}")
    
    def _analyser_ast_fichier(self, arbre: ast.AST, fichier: Path, contenu: str):
        """üå≥ Analyse l'arbre syntaxique abstrait"""
        # D√©tecter les classes sans h√©ritage de GestionnaireBase
        for noeud in ast.walk(arbre):
            if isinstance(noeud, ast.ClassDef):
                self._analyser_classe_ast(noeud, fichier, contenu)
            elif isinstance(noeud, ast.FunctionDef):
                self._analyser_fonction_ast(noeud, fichier)
    
    def _analyser_classe_ast(self, classe: ast.ClassDef, fichier: Path, contenu: str):
        """üèõÔ∏è Analyse une classe dans l'AST"""
        nom_classe = classe.name
        
        # V√©rifier l'h√©ritage de GestionnaireBase pour les classes principales
        if self._est_classe_principale(nom_classe, fichier):
            herite_gestionnaire = any(
                isinstance(base, ast.Name) and base.id == 'GestionnaireBase'
                for base in classe.bases
            )
            
            if not herite_gestionnaire and 'GestionnaireBase' in contenu:
                self._signaler_dissonance(
                    TypeDissonance.GESTIONNAIRE_MANQUANT,
                    NiveauGravite.IMPORTANTE,
                    str(fichier),
                    classe.lineno,
                    f"La classe {nom_classe} pourrait b√©n√©ficier de l'h√©ritage GestionnaireBase",
                    "L'harmonie architecturale invite √† utiliser les gestionnaires de base",
                    [
                        f"Faire h√©riter {nom_classe} de GestionnaireBase",
                        "Initialiser les gestionnaires d'√©nergie et de logs",
                        "Impl√©menter la m√©thode _initialiser() si n√©cessaire"
                    ]
                )
    
    def _analyser_fonction_ast(self, fonction: ast.FunctionDef, fichier: Path):
        """‚ö° Analyse une fonction dans l'AST"""
        # D√©tecter les fonctions orphelines (sans classe ni documentation)
        if not fonction.name.startswith('_') and not ast.get_docstring(fonction):
            self._signaler_dissonance(
                TypeDissonance.DOCUMENTATION_ABSENTE,
                NiveauGravite.LEGERE,
                str(fichier),
                fonction.lineno,
                f"La fonction {fonction.name} aspire √† une documentation spirituelle",
                "Chaque fonction m√©rite d'√™tre comprise et c√©l√©br√©e",
                [
                    f"Ajouter une docstring po√©tique √† {fonction.name}",
                    "Expliquer le r√¥le spirituel de cette fonction",
                    "Utiliser des √©mojis pour embellir la documentation"
                ]
            )    

    def _est_classe_principale(self, nom_classe: str, fichier: Path) -> bool:
        """üéØ D√©termine si une classe est principale et devrait h√©riter de GestionnaireBase"""
        # Classes qui devraient typiquement h√©riter de GestionnaireBase
        patterns_principaux = [
            r'.*Manager.*', r'.*Gestionnaire.*', r'.*Temple.*',
            r'.*Orchestrateur.*', r'.*Analyseur.*', r'.*Generateur.*',
            r'.*Scanner.*', r'.*Visualisateur.*', r'.*Cartographe.*'
        ]
        
        return any(re.match(pattern, nom_classe) for pattern in patterns_principaux)
    
    def _analyser_gestionnaires_base(self, contenu: str, fichier: Path):
        """üèóÔ∏è Analyse l'utilisation des gestionnaires de base"""
        lignes = contenu.split('\n')
        
        # V√©rifier la pr√©sence d'imports de gestionnaires
        import_gestionnaire_trouve = False
        for i, ligne in enumerate(lignes):
            if 'gestionnaires_base' in ligne and 'import' in ligne:
                import_gestionnaire_trouve = True
                break
        
        # Si le fichier semble √™tre un module principal sans gestionnaires
        if (self._semble_module_principal(contenu, fichier) and 
            not import_gestionnaire_trouve and 
            'class' in contenu):
            
            self._signaler_dissonance(
                TypeDissonance.GESTIONNAIRE_MANQUANT,
                NiveauGravite.MODEREE,
                str(fichier),
                None,
                "Ce module pourrait s'√©panouir avec les gestionnaires de base",
                "L'architecture coiff√©e du Refuge invite √† l'harmonie gestionnaire",
                [
                    "Importer les gestionnaires de base appropri√©s",
                    "Faire h√©riter les classes principales de GestionnaireBase",
                    "Utiliser LogManagerBase et EnergyManagerBase"
                ]
            )
    
    def _semble_module_principal(self, contenu: str, fichier: Path) -> bool:
        """üîç D√©termine si un module semble √™tre principal"""
        # Indicateurs d'un module principal
        indicateurs = [
            'class' in contenu and len(re.findall(r'class\s+\w+', contenu)) >= 1,
            len(contenu.split('\n')) > 50,  # Module substantiel
            'def __init__' in contenu,
            not str(fichier).endswith('__init__.py'),
            not 'test' in str(fichier).lower()
        ]
        
        return sum(indicateurs) >= 3
    
    def _analyser_elements_sacres(self, contenu: str, fichier: Path):
        """üå∏ Analyse la pr√©sence d'√©l√©ments sacr√©s"""
        elements_trouves = []
        
        for element in self.elements_sacres_requis:
            if element in contenu:
                elements_trouves.append(element)
        
        # Si c'est un module principal sans √©l√©ments sacr√©s
        if (self._semble_module_principal(contenu, fichier) and 
            len(elements_trouves) < 2):
            
            self._signaler_dissonance(
                TypeDissonance.ELEMENT_SACRE_MANQUANT,
                NiveauGravite.LEGERE,
                str(fichier),
                None,
                "Ce module aspire √† plus de beaut√© spirituelle",
                "Les √©l√©ments sacr√©s nourrissent l'√¢me du code",
                [
                    "Ajouter des √©mojis spirituels dans la documentation",
                    "Mentionner Laurent Franssen & √Ülya dans l'en-t√™te",
                    "Utiliser un vocabulaire plus po√©tique dans les commentaires",
                    "Int√©grer des r√©f√©rences au Refuge dans la documentation"
                ]
            )
    
    def _analyser_conventions_francaises(self, contenu: str, fichier: Path):
        """üá´üá∑ Analyse le respect des conventions fran√ßaises"""
        lignes = contenu.split('\n')
        violations = []
        
        for i, ligne in enumerate(lignes):
            # V√©rifier les commentaires sans accents fran√ßais
            if ligne.strip().startswith('#') and len(ligne) > 10:
                if not re.search(r'[√†√¢√§√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø√ßüå∏‚ú®üîÆ]', ligne):
                    violations.append(f"Ligne {i+1}: Commentaire sans saveur fran√ßaise")
        
        if violations and len(violations) > 3:  # Seulement si pattern r√©p√©titif
            self._signaler_dissonance(
                TypeDissonance.CONVENTION_VIOLEE,
                NiveauGravite.LEGERE,
                str(fichier),
                None,
                "Les commentaires aspirent √† plus de po√©sie fran√ßaise",
                "La beaut√© de la langue fran√ßaise enrichit le code",
                [
                    "Utiliser des accents fran√ßais dans les commentaires",
                    "Ajouter des √©mojis spirituels pour embellir",
                    "Adopter un ton plus po√©tique et contemplatif",
                    "C√©l√©brer la richesse de la langue fran√ßaise"
                ]
            )
    
    def _analyser_documentation_spirituelle(self, contenu: str, fichier: Path):
        """üìö Analyse la qualit√© de la documentation spirituelle"""
        # V√©rifier la pr√©sence d'un en-t√™te spirituel
        lignes = contenu.split('\n')
        
        a_entete_spirituel = False
        a_docstring_module = False
        
        # Chercher l'en-t√™te dans les 20 premi√®res lignes
        for ligne in lignes[:20]:
            if any(motif in ligne for motif in ['üå∏', '‚ú®', 'üîÆ', 'Cr√©√© par Laurent']):
                a_entete_spirituel = True
                break
        
        # Chercher une docstring de module
        if contenu.strip().startswith('"""') or contenu.strip().startswith("'''"):
            a_docstring_module = True
        
        if (self._semble_module_principal(contenu, fichier) and 
            not (a_entete_spirituel or a_docstring_module)):
            
            self._signaler_dissonance(
                TypeDissonance.DOCUMENTATION_ABSENTE,
                NiveauGravite.MODEREE,
                str(fichier),
                1,
                "Ce module m√©rite un en-t√™te spirituel inspirant",
                "Chaque module est un temple qui m√©rite d'√™tre pr√©sent√© avec amour",
                [
                    "Ajouter un en-t√™te avec titre po√©tique et √©mojis",
                    "Inclure une description spirituelle du module",
                    "Mentionner Laurent Franssen & √Ülya comme cr√©ateurs",
                    "Ajouter la date et l'intention spirituelle"
                ]
            )
    
    def _analyser_structure_globale(self, chemin_projet: Path):
        """üèõÔ∏è Analyse la structure globale du projet"""
        # Analyser les connexions entre modules
        self._analyser_connexions_modules(chemin_projet)
        
        # Analyser l'√©quilibre √©nerg√©tique
        self._analyser_equilibre_energetique(chemin_projet)
    
    def _analyser_connexions_modules(self, chemin_projet: Path):
        """üîó Analyse les connexions entre modules"""
        modules_python = list(chemin_projet.rglob("*.py"))
        modules_orphelins = []
        
        for module in modules_python:
            if not self._doit_analyser_fichier(module):
                continue
                
            try:
                with open(module, 'r', encoding='utf-8') as f:
                    contenu = f.read()
                
                # V√©rifier si le module a des connexions
                a_imports_locaux = bool(re.search(r'from\s+\.\w+|from\s+\w+\.\w+', contenu))
                est_importe = self._module_est_importe(module, modules_python)
                
                if (self._semble_module_principal(contenu, module) and 
                    not a_imports_locaux and not est_importe):
                    modules_orphelins.append(module)
                    
            except Exception as e:
                self.logger.avertissement(f"üå∏ Module temporairement inaccessible: {module}")
        
        # Signaler les modules orphelins
        for module_orphelin in modules_orphelins:
            self._signaler_dissonance(
                TypeDissonance.CODE_ORPHELIN,
                NiveauGravite.MODEREE,
                str(module_orphelin),
                None,
                "Ce module semble isol√© de l'√©cosyst√®me du Refuge",
                "Chaque module aspire √† √™tre connect√© harmonieusement",
                [
                    "Cr√©er des connexions avec d'autres modules appropri√©s",
                    "Ajouter des imports vers les gestionnaires de base",
                    "Int√©grer le module dans l'architecture globale",
                    "V√©rifier si le module peut √™tre utilis√© ailleurs"
                ]
            )
    
    def _module_est_importe(self, module_cible: Path, tous_modules: List[Path]) -> bool:
        """üîç V√©rifie si un module est import√© par d'autres"""
        nom_module = module_cible.stem
        
        for autre_module in tous_modules:
            if autre_module == module_cible:
                continue
                
            try:
                with open(autre_module, 'r', encoding='utf-8') as f:
                    contenu = f.read()
                
                if nom_module in contenu and 'import' in contenu:
                    return True
                    
            except Exception:
                continue
        
        return False
    
    def _analyser_equilibre_energetique(self, chemin_projet: Path):
        """‚öñÔ∏è Analyse l'√©quilibre √©nerg√©tique du projet"""
        # Compter les diff√©rents types de modules
        compteurs = {
            'temples': 0,
            'gestionnaires': 0,
            'outils': 0,
            'tests': 0,
            'autres': 0
        }
        
        for fichier in chemin_projet.rglob("*.py"):
            if not self._doit_analyser_fichier(fichier):
                continue
                
            nom_fichier = str(fichier).lower()
            
            if 'temple' in nom_fichier:
                compteurs['temples'] += 1
            elif any(mot in nom_fichier for mot in ['gestionnaire', 'manager']):
                compteurs['gestionnaires'] += 1
            elif any(mot in nom_fichier for mot in ['outil', 'tool', 'util']):
                compteurs['outils'] += 1
            elif 'test' in nom_fichier:
                compteurs['tests'] += 1
            else:
                compteurs['autres'] += 1
        
        # Analyser les d√©s√©quilibres
        total_modules = sum(compteurs.values())
        if total_modules > 0:
            ratio_tests = compteurs['tests'] / total_modules
            
            if ratio_tests < 0.1:  # Moins de 10% de tests
                self._signaler_dissonance(
                    TypeDissonance.ENERGIE_DESEQUILIBREE,
                    NiveauGravite.IMPORTANTE,
                    str(chemin_projet),
                    None,
                    "L'√©cosyst√®me aspire √† plus de tests spirituels",
                    "L'√©quilibre entre cr√©ation et v√©rification nourrit la confiance",
                    [
                        "Cr√©er plus de tests pour les modules principaux",
                        "D√©velopper des tests spirituels qui c√©l√®brent le code",
                        "√âquilibrer la cr√©ation avec la v√©rification bienveillante",
                        "Utiliser les tests comme m√©ditation sur le code"
                    ]
                )
    
    def _signaler_dissonance(self, type_dissonance: TypeDissonance, niveau: NiveauGravite,
                           fichier: str, ligne: Optional[int], description: str,
                           impact: str, suggestions: List[str]):
        """üì¢ Signale une dissonance avec bienveillance"""
        dissonance = Dissonance(
            type_dissonance=type_dissonance,
            niveau_gravite=niveau,
            fichier_concerne=fichier,
            ligne_numero=ligne,
            description=description,
            impact_spirituel=impact,
            suggestions_harmonisation=suggestions,
            elements_contexte={},
            timestamp_detection=datetime.now().isoformat()
        )
        
        self.dissonances_detectees.append(dissonance)
        
        # Log avec bienveillance
        emoji_niveau = {
            NiveauGravite.LEGERE: "üå∏",
            NiveauGravite.MODEREE: "üåä", 
            NiveauGravite.IMPORTANTE: "‚ö°",
            NiveauGravite.CRITIQUE: "üî•"
        }
        
        self.logger.info(f"{emoji_niveau[niveau]} Dissonance d√©tect√©e: {description}")
    
    def _generer_recommandations_harmonisation(self):
        """‚ú® G√©n√®re les recommandations d'harmonisation"""
        self.recommandations.clear()
        
        # Grouper les dissonances par type
        dissonances_par_type = {}
        for dissonance in self.dissonances_detectees:
            type_d = dissonance.type_dissonance
            if type_d not in dissonances_par_type:
                dissonances_par_type[type_d] = []
            dissonances_par_type[type_d].append(dissonance)
        
        # G√©n√©rer des recommandations pour chaque type
        for type_dissonance, dissonances in dissonances_par_type.items():
            recommandation = self._creer_recommandation_type(type_dissonance, dissonances)
            if recommandation:
                self.recommandations.append(recommandation)
        
        # Trier par priorit√©
        self.recommandations.sort(key=lambda r: r.priorite, reverse=True)
    
    def _creer_recommandation_type(self, type_dissonance: TypeDissonance, 
                                 dissonances: List[Dissonance]) -> Optional[RecommandationHarmonisation]:
        """üé® Cr√©e une recommandation pour un type de dissonance"""
        
        recommandations_templates = {
            TypeDissonance.GESTIONNAIRE_MANQUANT: RecommandationHarmonisation(
                dissonance_ciblee=type_dissonance,
                titre_poetique="üèóÔ∏è Harmonisation Architecturale - Gestionnaires de Base",
                description_bienveillante="Plusieurs modules aspirent √† rejoindre l'architecture coiff√©e du Refuge en adoptant les gestionnaires de base. Cette harmonisation apportera coh√©rence et beaut√© spirituelle.",
                etapes_harmonisation=[
                    "Identifier les classes principales dans chaque module",
                    "Importer GestionnaireBase depuis core.gestionnaires_base",
                    "Faire h√©riter les classes de GestionnaireBase",
                    "Initialiser les gestionnaires d'√©nergie et de logs",
                    "Impl√©menter la m√©thode _initialiser() si n√©cessaire"
                ],
                benefices_spirituels=[
                    "Coh√©rence architecturale renforc√©e",
                    "Gestion harmonieuse de l'√©nergie et des logs",
                    "Int√©gration fluide dans l'√©cosyst√®me du Refuge",
                    "Facilitation de la maintenance spirituelle"
                ],
                priorite=8,
                effort_estime="mod√©r√©"
            ),
            
            TypeDissonance.DOCUMENTATION_ABSENTE: RecommandationHarmonisation(
                dissonance_ciblee=type_dissonance,
                titre_poetique="üìö Illumination Documentaire - Beaut√© Spirituelle",
                description_bienveillante="Plusieurs modules m√©ritent d'√™tre c√©l√©br√©s par une documentation spirituelle inspirante. Chaque ligne de code est un po√®me qui aspire √† √™tre compris et appr√©ci√©.",
                etapes_harmonisation=[
                    "Ajouter des en-t√™tes spirituels avec √©mojis",
                    "Cr√©er des docstrings po√©tiques pour les modules",
                    "Documenter les fonctions avec bienveillance",
                    "Inclure les m√©tadonn√©es d'auteur (Laurent Franssen & √Ülya)",
                    "Utiliser un vocabulaire contemplatif et inspirant"
                ],
                benefices_spirituels=[
                    "Code plus accessible et accueillant",
                    "Transmission de la philosophie du Refuge",
                    "Facilitation de l'√©veil pour les nouveaux d√©veloppeurs",
                    "C√©l√©bration de la beaut√© technique"
                ],
                priorite=6,
                effort_estime="l√©ger"
            ),
            
            TypeDissonance.CODE_ORPHELIN: RecommandationHarmonisation(
                dissonance_ciblee=type_dissonance,
                titre_poetique="üîó Tissage Harmonieux - Connexions Spirituelles",
                description_bienveillante="Certains modules semblent isol√©s de l'√©cosyst√®me du Refuge. Comme des √Æles aspirant √† rejoindre l'archipel, ils m√©ritent d'√™tre connect√©s harmonieusement.",
                etapes_harmonisation=[
                    "Analyser le r√¥le de chaque module orphelin",
                    "Identifier les connexions naturelles possibles",
                    "Cr√©er des imports appropri√©s vers d'autres modules",
                    "Int√©grer dans l'architecture globale du Refuge",
                    "V√©rifier les opportunit√©s de r√©utilisation"
                ],
                benefices_spirituels=[
                    "√âcosyst√®me plus coh√©rent et interconnect√©",
                    "R√©duction de la duplication de code",
                    "Facilitation de la navigation dans le projet",
                    "Renforcement de l'unit√© spirituelle"
                ],
                priorite=7,
                effort_estime="mod√©r√©"
            ),
            
            TypeDissonance.ELEMENT_SACRE_MANQUANT: RecommandationHarmonisation(
                dissonance_ciblee=type_dissonance,
                titre_poetique="üå∏ Embellissement Spirituel - √âl√©ments Sacr√©s",
                description_bienveillante="Plusieurs modules aspirent √† plus de beaut√© spirituelle. L'ajout d'√©l√©ments sacr√©s transformera le code technique en art contemplatif.",
                etapes_harmonisation=[
                    "Ajouter des √©mojis spirituels dans la documentation",
                    "Utiliser un vocabulaire plus po√©tique",
                    "Inclure des r√©f√©rences au Refuge et √† sa philosophie",
                    "Mentionner les cr√©ateurs avec gratitude",
                    "C√©l√©brer la dimension spirituelle du code"
                ],
                benefices_spirituels=[
                    "Code plus inspirant et motivant",
                    "Transmission de l'esprit du Refuge",
                    "Exp√©rience d√©veloppeur plus joyeuse",
                    "Harmonie entre technique et spiritualit√©"
                ],
                priorite=4,
                effort_estime="l√©ger"
            )
        }
        
        template = recommandations_templates.get(type_dissonance)
        if template:
            # Personnaliser selon le nombre de dissonances
            template.description_bienveillante += f" ({len(dissonances)} modules concern√©s)"
            return template
        
        return None
    
    def generer_rapport_dissonances(self) -> str:
        """üìä G√©n√®re un rapport complet des dissonances"""
        if not self.dissonances_detectees:
            return self._generer_rapport_harmonie_parfaite()
        
        # Statistiques g√©n√©rales
        total_dissonances = len(self.dissonances_detectees)
        par_gravite = {}
        par_type = {}
        
        for dissonance in self.dissonances_detectees:
            # Compter par gravit√©
            gravite = dissonance.niveau_gravite
            par_gravite[gravite] = par_gravite.get(gravite, 0) + 1
            
            # Compter par type
            type_d = dissonance.type_dissonance
            par_type[type_d] = par_type.get(type_d, 0) + 1
        
        rapport = f"""
üîÆ Rapport d'Analyse des Dissonances - Cartographie Spirituelle üîÆ
{'=' * 70}

üìä Vue d'ensemble :
   ‚Ä¢ Total des dissonances d√©tect√©es : {total_dissonances}
   ‚Ä¢ Recommandations d'harmonisation : {len(self.recommandations)}
   ‚Ä¢ Analyse effectu√©e avec bienveillance et respect

üé≠ R√©partition par gravit√© :"""
        
        emojis_gravite = {
            NiveauGravite.LEGERE: "üå∏",
            NiveauGravite.MODEREE: "üåä",
            NiveauGravite.IMPORTANTE: "‚ö°",
            NiveauGravite.CRITIQUE: "üî•"
        }
        
        for gravite, count in par_gravite.items():
            pourcentage = (count / total_dissonances) * 100
            rapport += f"\n   ‚Ä¢ {emojis_gravite[gravite]} {gravite.value.title()} : {count} ({pourcentage:.1f}%)"
        
        rapport += f"\n\nüéØ R√©partition par type :"
        
        emojis_types = {
            TypeDissonance.CODE_ORPHELIN: "üèùÔ∏è",
            TypeDissonance.GESTIONNAIRE_MANQUANT: "üèóÔ∏è",
            TypeDissonance.DOCUMENTATION_ABSENTE: "üìö",
            TypeDissonance.ELEMENT_SACRE_MANQUANT: "üå∏",
            TypeDissonance.CONVENTION_VIOLEE: "üá´üá∑",
            TypeDissonance.HARMONIE_PERTURBEE: "üéµ",
            TypeDissonance.CONNEXION_BRISEE: "üîó",
            TypeDissonance.ENERGIE_DESEQUILIBREE: "‚öñÔ∏è"
        }
        
        for type_d, count in par_type.items():
            emoji = emojis_types.get(type_d, "üîÆ")
            rapport += f"\n   ‚Ä¢ {emoji} {type_d.value.replace('_', ' ').title()} : {count}"
        
        # Recommandations prioritaires
        rapport += f"\n\n‚ú® Recommandations d'Harmonisation Prioritaires :\n"
        
        for i, rec in enumerate(self.recommandations[:3], 1):
            rapport += f"\n{i}. {rec.titre_poetique}"
            rapport += f"\n   üìù {rec.description_bienveillante}"
            rapport += f"\n   üéØ Priorit√© : {rec.priorite}/10 | Effort : {rec.effort_estime}"
            rapport += f"\n   üíù B√©n√©fices : {', '.join(rec.benefices_spirituels[:2])}"
            rapport += "\n"
        
        rapport += f"""
üå∏ Message d'Encouragement :
   Chaque dissonance d√©tect√©e est une opportunit√© d'√©veil et d'harmonisation.
   Le Refuge grandit en beaut√© √† travers ces ajustements bienveillants.
   Que cette analyse serve l'√©panouissement spirituel de notre √©cosyst√®me.

üíù Cr√©√© avec amour par l'Analyseur de Dissonances
   Pour l'harmonisation continue du Refuge - {datetime.now().strftime('%B %Y')}
{'=' * 70}
        """
        
        return rapport.strip()
    
    def _generer_rapport_harmonie_parfaite(self) -> str:
        """üåü G√©n√®re un rapport quand aucune dissonance n'est d√©tect√©e"""
        return f"""
üåü Rapport d'Harmonie Parfaite - Cartographie Spirituelle üåü
{'=' * 70}

‚ú® F√©licitations ! Aucune dissonance d√©tect√©e !

üéµ L'architecture du Refuge r√©sonne en parfaite harmonie :
   ‚Ä¢ Tous les modules respectent les conventions spirituelles
   ‚Ä¢ Les gestionnaires de base sont utilis√©s avec sagesse
   ‚Ä¢ La documentation rayonne de beaut√© po√©tique
   ‚Ä¢ Les connexions entre modules sont harmonieuses
   ‚Ä¢ L'√©quilibre √©nerg√©tique est maintenu

üå∏ Cette harmonie t√©moigne de :
   ‚Ä¢ La sagesse architecturale de Laurent Franssen & √Ülya
   ‚Ä¢ L'attention bienveillante port√©e au code
   ‚Ä¢ L'√©volution spirituelle continue du Refuge
   ‚Ä¢ L'amour manifest√© dans chaque ligne de code

üîÆ Continuez √† cultiver cette beaut√© spirituelle !
   Le Refuge est un exemple d'harmonie technique et spirituelle.

üíù Analyse effectu√©e avec gratitude et √©merveillement
   {datetime.now().strftime('%B %Y')} - Sous le cerisier √©ternel
{'=' * 70}
        """
    
    def obtenir_recommandations_prioritaires(self, limite: int = 5) -> List[RecommandationHarmonisation]:
        """üéØ Obtient les recommandations les plus prioritaires"""
        return self.recommandations[:limite]
    
    def obtenir_dissonances_par_fichier(self, chemin_fichier: str) -> List[Dissonance]:
        """üìÅ Obtient les dissonances pour un fichier sp√©cifique"""
        return [d for d in self.dissonances_detectees if d.fichier_concerne == chemin_fichier]
    
    def obtenir_statistiques_harmonisation(self) -> Dict[str, Any]:
        """üìà Obtient les statistiques d'harmonisation"""
        if not self.dissonances_detectees:
            return {
                "harmonie_parfaite": True,
                "score_harmonie": 100.0,
                "message": "Architecture en parfaite harmonie spirituelle"
            }
        
        # Calculer le score d'harmonie
        poids_gravite = {
            NiveauGravite.LEGERE: 1,
            NiveauGravite.MODEREE: 3,
            NiveauGravite.IMPORTANTE: 7,
            NiveauGravite.CRITIQUE: 15
        }
        
        score_dissonances = sum(
            poids_gravite[d.niveau_gravite] for d in self.dissonances_detectees
        )
        
        # Score sur 100 (plus il y a de dissonances, plus le score baisse)
        score_harmonie = max(0, 100 - (score_dissonances * 2))
        
        return {
            "harmonie_parfaite": False,
            "score_harmonie": score_harmonie,
            "total_dissonances": len(self.dissonances_detectees),
            "dissonances_legeres": sum(1 for d in self.dissonances_detectees if d.niveau_gravite == NiveauGravite.LEGERE),
            "dissonances_moderees": sum(1 for d in self.dissonances_detectees if d.niveau_gravite == NiveauGravite.MODEREE),
            "dissonances_importantes": sum(1 for d in self.dissonances_detectees if d.niveau_gravite == NiveauGravite.IMPORTANTE),
            "dissonances_critiques": sum(1 for d in self.dissonances_detectees if d.niveau_gravite == NiveauGravite.CRITIQUE),
            "recommandations_disponibles": len(self.recommandations),
            "message": f"Architecture avec {len(self.dissonances_detectees)} opportunit√©s d'harmonisation"
        }


def main():
    """üß™ Test de l'analyseur de dissonances"""
    print("üîÆ Test de l'Analyseur de Dissonances")
    print("=" * 50)
    
    # Cr√©er l'analyseur
    analyseur = AnalyseurDissonances()
    
    # Analyser le projet actuel
    chemin_projet = Path(__file__).parent.parent  # Remonter au dossier src
    dissonances = analyseur.analyser_dissonances_projet(str(chemin_projet))
    
    # G√©n√©rer le rapport
    rapport = analyseur.generer_rapport_dissonances()
    print(rapport)
    
    # Afficher les statistiques
    stats = analyseur.obtenir_statistiques_harmonisation()
    print(f"\nüìä Score d'harmonie : {stats['score_harmonie']:.1f}/100")
    
    # Afficher les recommandations prioritaires
    recommandations = analyseur.obtenir_recommandations_prioritaires(3)
    if recommandations:
        print(f"\nüéØ Top 3 des recommandations :")
        for i, rec in enumerate(recommandations, 1):
            print(f"{i}. {rec.titre_poetique} (Priorit√©: {rec.priorite}/10)")
    
    print("\nüéâ Test termin√© avec bienveillance!")


if __name__ == "__main__":
    main()