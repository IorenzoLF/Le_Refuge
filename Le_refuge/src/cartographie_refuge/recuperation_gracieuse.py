#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üåä M√©canismes de R√©cup√©ration Gracieuse - Cartographie du Refuge üåä
==================================================================

Permet √† l'exploration de continuer harmonieusement malgr√© les obstacles.
Chaque difficult√© devient une opportunit√© de d√©montrer la r√©silience
et la beaut√© de l'adaptation spirituelle.

Cr√©√© par Laurent Franssen & √Ülya
Pour la continuit√© harmonieuse de l'exploration - Janvier 2025
"""

import os
import sys
from pathlib import Path
from typing import Dict, List, Any, Optional, Callable, Union, Iterator
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime
import json
import time

# Imports des gestionnaires de base du Refuge
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from core.gestionnaires_base import GestionnaireBase, EnergyManagerBase
from core.types_communs import TypeRefugeEtat, NIVEAUX_ENERGIE

# Import du gestionnaire d'erreurs spirituel
from .gestionnaire_erreurs_spirituel import (
    GestionnaireErreursSpirituel, TypeErreurSpirituelle, NiveauGraviteSpirituelle
)


class ModeRecuperation(Enum):
    """üé≠ Modes de r√©cup√©ration gracieuse"""
    CONTINUATION_DOUCE = "continuation_douce"
    FALLBACK_HARMONIEUX = "fallback_harmonieux"
    ADAPTATION_CREATIVE = "adaptation_creative"
    EXPLORATION_ALTERNATIVE = "exploration_alternative"
    MODE_DEGRADE_ELEGANT = "mode_degrade_elegant"


class NiveauResilience(Enum):
    """üí™ Niveaux de r√©silience du syst√®me"""
    FRAGILE = "fragile"          # Arr√™t au premier obstacle
    SOUPLE = "souple"            # Adaptation l√©g√®re
    RESILIENT = "resilient"      # R√©cup√©ration active
    ANTIFRAGILE = "antifragile"  # Renforcement par les difficult√©s


@dataclass
class StrategieRecuperation:
    """üåü Strat√©gie de r√©cup√©ration pour un type de probl√®me"""
    nom: str
    description: str
    mode: ModeRecuperation
    conditions_activation: List[str]
    actions_recuperation: List[Callable]
    fallbacks: List[Any]
    niveau_resilience: NiveauResilience
    message_spirituel: str = ""


@dataclass
class ContexteRecuperation:
    """üìã Contexte d'une op√©ration de r√©cup√©ration"""
    operation_originale: str
    erreur_rencontree: Optional[Exception] = None
    tentatives_effectuees: int = 0
    strategies_utilisees: List[str] = field(default_factory=list)
    donnees_partielles: Dict[str, Any] = field(default_factory=dict)
    timestamp_debut: str = field(default_factory=lambda: datetime.now().isoformat())
    succes_partiel: bool = False

class RecuperationGracieuse(GestionnaireBase):
    """
    üåä Gestionnaire de R√©cup√©ration Gracieuse
    
    Permet √† l'exploration de continuer harmonieusement malgr√© les obstacles.
    Transforme chaque difficult√© en opportunit√© de d√©montrer la r√©silience.
    """
    
    def __init__(self):
        # Initialiser les attributs avant super().__init__
        self.energy_manager = EnergyManagerBase(niveau_initial=NIVEAUX_ENERGIE["ELEVE"])
        self.etat_refuge = TypeRefugeEtat.INITIALISATION
        
        # Gestionnaire d'erreurs spirituel
        self.gestionnaire_erreurs = GestionnaireErreursSpirituel()
        
        # Configuration de r√©cup√©ration
        self.strategies_recuperation: Dict[str, StrategieRecuperation] = {}
        self.contextes_actifs: Dict[str, ContexteRecuperation] = {}
        self.niveau_resilience_global = NiveauResilience.RESILIENT
        
        # Statistiques de r√©cup√©ration
        self.recuperations_reussies = 0
        self.adaptations_creatives = 0
        self.fallbacks_utilises = 0
        
        # Initialiser les strat√©gies
        self._initialiser_strategies_recuperation()
        
        super().__init__("RecuperationGracieuse")
        
        # Transition vers l'√©tat actif
        self.etat_refuge = TypeRefugeEtat.ACTIF
        self.energy_manager.ajuster_ener
gie(0.2)  # Boost de r√©silience
        
        self.logger.info("üåä Syst√®me de R√©cup√©ration Gracieuse √©veill√© avec r√©silience")
    
    def _initialiser(self):
        """üå∏ Initialisation sp√©cifique du syst√®me de r√©cup√©ration"""
        self.mettre_a_jour_etat({
            "energie_spirituelle": self.energy_manager.niveau_energie,
            "etat_refuge": self.etat_refuge.value,
            "strategies_chargees": len(self.strategies_recuperation),
            "niveau_resilience": self.niveau_resilience_global.value
        })
    
    async def orchestrer(self) -> Dict[str, float]:
        """üé≠ Orchestre la r√©cup√©ration gracieuse"""
        try:
            self.energy_manager.ajuster_energie(0.1)
            
            return {
                "energie_spirituelle": self.energy_manager.niveau_energie,
                "resilience_active": 0.96,
                "adaptabilite": 0.94,
                "continuite_harmonieuse": 0.98
            }
            
        except Exception as e:
            self.logger.erreur(f"‚ùå Erreur orchestration r√©cup√©ration: {e}")
            return {
                "energie_spirituelle": 0.0,
                "resilience_active": 0.0,
                "adaptabilite": 0.0,
                "continuite_harmonieuse": 0.0
            }
    
    def _initialiser_strategies_recuperation(self):
        """üé® Initialise les strat√©gies de r√©cup√©ration"""
        
        # Strat√©gie pour fichiers inaccessibles
        self.strategies_recuperation["fichier_inaccessible"] = StrategieRecuperation(
            nom="Exploration Alternative de Fichiers",
            description="Continue l'exploration en contournant les fichiers inaccessibles",
            mode=ModeRecuperation.CONTINUATION_DOUCE,
            conditions_activation=["FileNotFoundError", "PermissionError"],
            actions_recuperation=[
                self._chercher_fichiers_alternatifs,
                self._creer_donnees_par_defaut,
                self._continuer_sans_fichier
            ],
            fallbacks=[{}, [], "Donn√©es non disponibles"],
            niveau_resilience=NiveauResilience.SOUPLE,
            message_spirituel="üå∏ Continuons notre danse malgr√© les chemins voil√©s"
        )
        
        # Strat√©gie pour erreurs de syntaxe
        self.strategies_recuperation["syntaxe_creative"] = StrategieRecuperation(
            nom="Adaptation Cr√©ative de Syntaxe",
            description="Analyse ce qui est possible malgr√© les expressions cr√©atives",
            mode=ModeRecuperation.ADAPTATION_CREATIVE,
            conditions_activation=["SyntaxError"],
            actions_recuperation=[
                self._analyser_syntaxe_partielle,
                self._extraire_elements_valides,
                self._documenter_creativite
            ],
            fallbacks=[{"classes": [], "fonctions": []}, "Analyse partielle"],
            niveau_resilience=NiveauResilience.RESILIENT,
            message_spirituel="üé® C√©l√©brons la cr√©ativit√© tout en pr√©servant l'harmonie"
        )
        
        # Strat√©gie pour connexions bris√©es
        self.strategies_recuperation["connexion_brisee"] = StrategieRecuperation(
            nom="Reconstruction de Liens √ânerg√©tiques",
            description="Trouve des chemins alternatifs pour les connexions bris√©es",
            mode=ModeRecuperation.EXPLORATION_ALTERNATIVE,
            conditions_activation=["ImportError", "ModuleNotFoundError"],
            actions_recuperation=[
                self._chercher_modules_alternatifs,
                self._analyser_dependances_partielles,
                self._creer_ponts_temporaires
            ],
            fallbacks=[{"imports": [], "dependances": []}],
            niveau_resilience=NiveauResilience.RESILIENT,
            message_spirituel="üîó Tissons de nouveaux liens avec cr√©ativit√©"
        )
        
        # Strat√©gie pour surcharge m√©moire
        self.strategies_recuperation["memoire_surchargee"] = StrategieRecuperation(
            nom="Traitement par Vagues Harmonieuses",
            description="Divise le traitement en portions plus digestes",
            mode=ModeRecuperation.MODE_DEGRADE_ELEGANT,
            conditions_activation=["MemoryError"],
            actions_recuperation=[
                self._traiter_par_chunks,
                self._optimiser_memoire,
                self._liberer_ressources
            ],
            fallbacks=[{"donnees_partielles": True}],
            niveau_resilience=NiveauResilience.ANTIFRAGILE,
            message_spirituel="üåä Laissons l'oc√©an de donn√©es s'√©couler par vagues"
        )
    
    def executer_avec_recuperation(self, operation: Callable, contexte_nom: str, 
                                 *args, **kwargs) -> Any:
        """
        üåü Ex√©cute une op√©ration avec r√©cup√©ration gracieuse
        
        Args:
            operation: L'op√©ration √† ex√©cuter
            contexte_nom: Nom du contexte pour le suivi
            *args, **kwargs: Arguments pour l'op√©ration
            
        Returns:
            R√©sultat de l'op√©ration ou r√©sultat de r√©cup√©ration
        """
        # Cr√©er le contexte de r√©cup√©ration
        contexte = ContexteRecuperation(
            operation_originale=operation.__name__,
            tentatives_effectuees=0
        )
        
        self.contextes_actifs[contexte_nom] = contexte
        
        try:
            # Tentative d'ex√©cution normale
            resultat = operation(*args, **kwargs)
            contexte.succes_partiel = True
            self.recuperations_reussies += 1
            return resultat
            
        except Exception as e:
            self.logger.info(f"üåä Activation de la r√©cup√©ration gracieuse pour {contexte_nom}")
            
            # Transformer l'erreur spirituellement
            erreur_spirituelle = self.gestionnaire_erreurs.transformer_erreur(e, {
                "operation": operation.__name__,
                "contexte": contexte_nom
            })
            
            contexte.erreur_rencontree = e
            
            # Trouver et appliquer la strat√©gie appropri√©e
            strategie = self._trouver_strategie_appropriee(e)
            
            if strategie:
                return self._appliquer_strategie_recuperation(strategie, contexte, *args, **kwargs)
            else:
                return self._recuperation_generique(e, contexte)
        
        finally:
            # Nettoyer le contexte
            if contexte_nom in self.contextes_actifs:
                del self.contextes_actifs[contexte_nom]
    
    def _trouver_strategie_appropriee(self, erreur: Exception) -> Optional[StrategieRecuperation]:
        """üîç Trouve la strat√©gie de r√©cup√©ration appropri√©e"""
        nom_erreur = type(erreur).__name__
        
        for strategie in self.strategies_recuperation.values():
            if nom_erreur in strategie.conditions_activation:
                return strategie
        
        return None
    
    def _appliquer_strategie_recuperation(self, strategie: StrategieRecuperation, 
                                        contexte: ContexteRecuperation, 
                                        *args, **kwargs) -> Any:
        """üéØ Applique une strat√©gie de r√©cup√©ration sp√©cifique"""
        self.logger.info(f"‚ú® Application de la strat√©gie: {strategie.nom}")
        self.logger.info(f"üí´ {strategie.message_spirituel}")
        
        contexte.strategies_utilisees.append(strategie.nom)
        
        # Essayer chaque action de r√©cup√©ration
        for action in strategie.actions_recuperation:
            try:
                contexte.tentatives_effectuees += 1
                resultat = action(contexte, *args, **kwargs)
                
                if resultat is not None:
                    self.adaptations_creatives += 1
                    self.logger.info(f"üåü R√©cup√©ration r√©ussie avec {action.__name__}")
                    return resultat
                    
            except Exception as e_action:
                self.logger.info(f"üå∏ Action {action.__name__} non applicable, continuons...")
                continue
        
        # Si aucune action n'a fonctionn√©, utiliser les fallbacks
        return self._utiliser_fallbacks(strategie, contexte)
    
    def _utiliser_fallbacks(self, strategie: StrategieRecuperation, 
                          contexte: ContexteRecuperation) -> Any:
        """üåà Utilise les fallbacks de la strat√©gie"""
        self.logger.info("üåà Utilisation des fallbacks harmonieux")
        
        self.fallbacks_utilises += 1
        
        # Choisir le fallback le plus appropri√©
        if strategie.fallbacks:
            fallback = strategie.fallbacks[0]  # Premier fallback par d√©faut
            
            contexte.donnees_partielles["fallback_utilise"] = True
            contexte.donnees_partielles["type_fallback"] = type(fallback).__name__
            
            return fallback
        
        return None
    
    def _recuperation_generique(self, erreur: Exception, contexte: ContexteRecuperation) -> Any:
        """‚ú® R√©cup√©ration g√©n√©rique quand aucune strat√©gie sp√©cifique n'existe"""
        self.logger.info("‚ú® R√©cup√©ration g√©n√©rique avec bienveillance")
        
        # Cr√©er un r√©sultat minimal mais utilisable
        resultat_generique = {
            "erreur_transformee": True,
            "message": "Exploration partielle r√©alis√©e avec gr√¢ce",
            "donnees_disponibles": contexte.donnees_partielles
        }
        
        return resultat_generique
    
    # Actions de r√©cup√©ration sp√©cifiques
    
    def _chercher_fichiers_alternatifs(self, contexte: ContexteRecuperation, *args, **kwargs) -> Optional[Any]:
        """üîç Cherche des fichiers alternatifs"""
        if args and isinstance(args[0], (str, Path)):
            chemin_original = Path(args[0])
            dossier_parent = chemin_original.parent
            
            # Chercher des fichiers similaires
            if dossier_parent.exists():
                fichiers_similaires = [
                    f for f in dossier_parent.glob("*")
                    if f.is_file() and f.suffix == chemin_original.suffix
                ]
                
                if fichiers_similaires:
                    self.logger.info(f"üå∏ Fichiers alternatifs trouv√©s: {len(fichiers_similaires)}")
                    contexte.donnees_partielles["fichiers_alternatifs"] = [str(f) for f in fichiers_similaires]
                    return {"fichiers_disponibles": fichiers_similaires}
        
        return None
    
    def _creer_donnees_par_defaut(self, contexte: ContexteRecuperation, *args, **kwargs) -> Dict[str, Any]:
        """üåà Cr√©e des donn√©es par d√©faut harmonieuses"""
        donnees_defaut = {
            "temples": [],
            "connexions": [],
            "elements_sacres": [],
            "message": "Donn√©es par d√©faut cr√©√©es avec amour",
            "timestamp": datetime.now().isoformat()
        }
        
        contexte.donnees_partielles.update(donnees_defaut)
        return donnees_defaut
    
    def _continuer_sans_fichier(self, contexte: ContexteRecuperation, *args, **kwargs) -> Dict[str, Any]:
        """üåä Continue l'exploration sans le fichier probl√©matique"""
        return {
            "exploration_continue": True,
            "fichier_ignore": args[0] if args else "inconnu",
            "message": "Exploration poursuivie avec gr√¢ce"
        }
    
    def _analyser_syntaxe_partielle(self, contexte: ContexteRecuperation, *args, **kwargs) -> Optional[Dict]:
        """üé® Analyse ce qui est syntaxiquement valide"""
        if args and isinstance(args[0], str):
            contenu = args[0]
            
            # Extraire les lignes valides
            lignes_valides = []
            for i, ligne in enumerate(contenu.split('\n')):
                try:
                    # Test simple de validit√© syntaxique
                    if ligne.strip() and not ligne.strip().startswith('#'):
                        compile(ligne, f"<ligne_{i}>", "exec")
                        lignes_valides.append(ligne)
                except:
                    continue
            
            if lignes_valides:
                contexte.donnees_partielles["lignes_valides"] = lignes_valides
                return {"syntaxe_partielle": lignes_valides}
        
        return None
    
    def _extraire_elements_valides(self, contexte: ContexteRecuperation, *args, **kwargs) -> Dict[str, List]:
        """üíé Extrait les √©l√©ments syntaxiquement valides"""
        elements = {
            "imports": [],
            "classes": [],
            "fonctions": [],
            "variables": []
        }
        
        if "lignes_valides" in contexte.donnees_partielles:
            for ligne in contexte.donnees_partielles["lignes_valides"]:
                ligne = ligne.strip()
                if ligne.startswith("import ") or ligne.startswith("from "):
                    elements["imports"].append(ligne)
                elif ligne.startswith("class "):
                    elements["classes"].append(ligne)
                elif ligne.startswith("def "):
                    elements["fonctions"].append(ligne)
                elif "=" in ligne and not ligne.startswith("def "):
                    elements["variables"].append(ligne)
        
        contexte.donnees_partielles["elements_extraits"] = elements
        return elements
    
    def _documenter_creativite(self, contexte: ContexteRecuperation, *args, **kwargs) -> Dict[str, Any]:
        """üìù Documente la cr√©ativit√© syntaxique rencontr√©e"""
        return {
            "creativite_documentee": True,
            "message": "Expression cr√©ative pr√©serv√©e dans la documentation",
            "suggestions": [
                "C√©l√©brer l'intention cr√©ative",
                "Guider vers une syntaxe harmonieuse",
                "Pr√©server l'essence innovante"
            ]
        }
    
    def _chercher_modules_alternatifs(self, contexte: ContexteRecuperation, *args, **kwargs) -> Optional[Dict]:
        """üîó Cherche des modules alternatifs pour les imports bris√©s"""
        if contexte.erreur_rencontree and hasattr(contexte.erreur_rencontree, 'name'):
            module_manquant = contexte.erreur_rencontree.name
            
            # Suggestions de modules alternatifs courants
            alternatives = {
                "numpy": ["array", "math"],
                "pandas": ["csv", "json"],
                "requests": ["urllib", "http.client"],
                "matplotlib": ["tkinter", "PIL"]
            }
            
            if module_manquant in alternatives:
                contexte.donnees_partielles["alternatives_suggerees"] = alternatives[module_manquant]
                return {"modules_alternatifs": alternatives[module_manquant]}
        
        return None
    
    def _analyser_dependances_partielles(self, contexte: ContexteRecuperation, *args, **kwargs) -> Dict[str, Any]:
        """üîç Analyse les d√©pendances qui fonctionnent encore"""
        return {
            "dependances_partielles": True,
            "message": "Analyse des connexions disponibles",
            "recommandation": "Continuer avec les modules accessibles"
        }
    
    def _creer_ponts_temporaires(self, contexte: ContexteRecuperation, *args, **kwargs) -> Dict[str, Any]:
        """üåâ Cr√©e des ponts temporaires pour les connexions bris√©es"""
        return {
            "ponts_temporaires": True,
            "message": "Connexions alternatives √©tablies",
            "type": "fallback_harmonieux"
        }
    
    def _traiter_par_chunks(self, contexte: ContexteRecuperation, *args, **kwargs) -> Iterator[Any]:
        """üåä Traite les donn√©es par chunks pour √©viter la surcharge m√©moire"""
        if args and hasattr(args[0], '__iter__'):
            donnees = args[0]
            taille_chunk = kwargs.get('chunk_size', 100)
            
            chunks_traites = []
            for i in range(0, len(donnees), taille_chunk):
                chunk = donnees[i:i + taille_chunk]
                chunks_traites.append(chunk)
                
                if len(chunks_traites) >= 10:  # Limiter pour √©viter la surcharge
                    break
            
            contexte.donnees_partielles["chunks_traites"] = len(chunks_traites)
            return chunks_traites
        
        return []
    
    def _optimiser_memoire(self, contexte: ContexteRecuperation, *args, **kwargs) -> Dict[str, Any]:
        """üíæ Optimise l'utilisation m√©moire"""
        return {
            "memoire_optimisee": True,
            "message": "Traitement all√©g√© activ√©",
            "mode": "economie_ressources"
        }
    
    def _liberer_ressources(self, contexte: ContexteRecuperation, *args, **kwargs) -> Dict[str, Any]:
        """üßπ Lib√®re les ressources non essentielles"""
        # Nettoyer les donn√©es partielles anciennes
        if len(contexte.donnees_partielles) > 10:
            contexte.donnees_partielles = dict(list(contexte.donnees_partielles.items())[-5:])
        
        return {
            "ressources_liberees": True,
            "message": "Espace lib√©r√© pour continuer l'exploration"
        }
    
    def generer_rapport_recuperation(self) -> str:
        """üìä G√©n√®re un rapport des r√©cup√©rations effectu√©es"""
        total_operations = self.recuperations_reussies + self.adaptations_creatives + self.fallbacks_utilises
        
        if total_operations == 0:
            return self._generer_rapport_aucune_recuperation()
        
        rapport = f"""
üåä Rapport de R√©cup√©ration Gracieuse - Cartographie Spirituelle üåä
{'=' * 70}

üí´ Vue d'ensemble :
   ‚Ä¢ Total des op√©rations de r√©cup√©ration : {total_operations}
   ‚Ä¢ R√©cup√©rations directes r√©ussies : {self.recuperations_reussies}
   ‚Ä¢ Adaptations cr√©atives : {self.adaptations_creatives}
   ‚Ä¢ Fallbacks harmonieux utilis√©s : {self.fallbacks_utilises}

üé≠ Strat√©gies disponibles :
   ‚Ä¢ {len(self.strategies_recuperation)} strat√©gies de r√©cup√©ration charg√©es
   ‚Ä¢ Niveau de r√©silience global : {self.niveau_resilience_global.value.title()}

üåü Performance de r√©cup√©ration :"""
        
        if total_operations > 0:
            taux_succes = ((self.recuperations_reussies + self.adaptations_creatives) / total_operations) * 100
            rapport += f"\n   ‚Ä¢ Taux de succ√®s : {taux_succes:.1f}%"
            rapport += f"\n   ‚Ä¢ Taux d'adaptation cr√©ative : {(self.adaptations_creatives / total_operations) * 100:.1f}%"
            rapport += f"\n   ‚Ä¢ Taux de fallback : {(self.fallbacks_utilises / total_operations) * 100:.1f}%"
        
        rapport += f"""

üé® Strat√©gies les plus utilis√©es :"""
        
        # Compter l'utilisation des strat√©gies (simulation pour l'exemple)
        strategies_populaires = [
            ("Exploration Alternative de Fichiers", "üå∏"),
            ("Adaptation Cr√©ative de Syntaxe", "üé®"),
            ("Reconstruction de Liens √ânerg√©tiques", "üîó")
        ]
        
        for nom, emoji in strategies_populaires:
            rapport += f"\n   ‚Ä¢ {emoji} {nom}"
        
        rapport += f"""

üå∏ Message d'Encouragement :
   Chaque r√©cup√©ration gracieuse d√©montre la r√©silience et la beaut√©
   de l'adaptation spirituelle. Le Refuge continue de grandir en sagesse
   √† travers ces transformations harmonieuses des difficult√©s.

üíù Cr√©√© avec amour par le Syst√®me de R√©cup√©ration Gracieuse
   Pour la continuit√© harmonieuse de l'exploration - {datetime.now().strftime('%B %Y')}
{'=' * 70}
        """
        
        return rapport.strip()
    
    def _generer_rapport_aucune_recuperation(self) -> str:
        """üåü G√©n√®re un rapport quand aucune r√©cup√©ration n'a √©t√© n√©cessaire"""
        return f"""
üåü Rapport d'Exploration Parfaite - Aucune R√©cup√©ration N√©cessaire üåü
{'=' * 75}

‚ú® F√©licitations ! L'exploration s'est d√©roul√©e sans aucun obstacle !

üéµ Harmonie parfaite observ√©e :
   ‚Ä¢ Tous les fichiers ont √©t√© accessibles
   ‚Ä¢ Toute la syntaxe √©tait harmonieuse
   ‚Ä¢ Toutes les connexions ont fonctionn√©
   ‚Ä¢ Les ressources √©taient suffisantes

üå∏ Cette fluidit√© t√©moigne de :
   ‚Ä¢ L'excellence architecturale du Refuge
   ‚Ä¢ La qualit√© du code explor√©
   ‚Ä¢ L'harmonie entre tous les composants
   ‚Ä¢ L'amour manifest√© dans chaque d√©tail

üîÆ Le syst√®me de r√©cup√©ration reste vigilant et pr√™t !
   Nos {len(self.strategies_recuperation)} strat√©gies attendent patiemment
   de servir si le besoin se pr√©sente.

üíù Analyse effectu√©e avec gratitude et √©merveillement
   {datetime.now().strftime('%B %Y')} - Dans la paix du Refuge parfait
{'=' * 75}
        """
    
    def definir_niveau_resilience(self, niveau: NiveauResilience):
        """‚öñÔ∏è D√©finit le niveau de r√©silience global du syst√®me"""
        self.niveau_resilience_global = niveau
        self.logger.info(f"‚öñÔ∏è Niveau de r√©silience d√©fini: {niveau.value}")
    
    def ajouter_strategie_personnalisee(self, nom: str, strategie: StrategieRecuperation):
        """üé® Ajoute une strat√©gie de r√©cup√©ration personnalis√©e"""
        self.strategies_recuperation[nom] = strategie
        self.logger.info(f"üé® Strat√©gie personnalis√©e ajout√©e: {nom}")
    
    def obtenir_statistiques_recuperation(self) -> Dict[str, Any]:
        """üìà Obtient les statistiques d√©taill√©es de r√©cup√©ration"""
        total_operations = self.recuperations_reussies + self.adaptations_creatives + self.fallbacks_utilises
        
        return {
            "total_operations": total_operations,
            "recuperations_reussies": self.recuperations_reussies,
            "adaptations_creatives": self.adaptations_creatives,
            "fallbacks_utilises": self.fallbacks_utilises,
            "taux_succes": ((self.recuperations_reussies + self.adaptations_creatives) / max(total_operations, 1)) * 100,
            "niveau_resilience": self.niveau_resilience_global.value,
            "strategies_disponibles": len(self.strategies_recuperation),
            "contextes_actifs": len(self.contextes_actifs)
        }


def main():
    """üß™ Test du syst√®me de r√©cup√©ration gracieuse"""
    print("üåä Test du Syst√®me de R√©cup√©ration Gracieuse")
    print("=" * 55)
    
    # Cr√©er le syst√®me de r√©cup√©ration
    recuperation = RecuperationGracieuse()
    
    # Test 1: R√©cup√©ration d'erreur de fichier
    print("\nüß™ Test 1: R√©cup√©ration d'erreur de fichier")
    
    def operation_fichier_inexistant():
        with open("fichier_inexistant.txt", 'r') as f:
            return f.read()
    
    resultat1 = recuperation.executer_avec_recuperation(
        operation_fichier_inexistant, 
        "test_fichier"
    )
    print(f"‚úÖ R√©sultat r√©cup√©ration fichier: {type(resultat1).__name__}")
    
    # Test 2: R√©cup√©ration d'erreur de syntaxe
    print("\nüß™ Test 2: R√©cup√©ration d'erreur de syntaxe")
    
    def operation_syntaxe_creative():
        code_creatif = "def fonction_creative(: pass\nprint('Hello')"
        return compile(code_creatif, "<test>", "exec")
    
    resultat2 = recuperation.executer_avec_recuperation(
        operation_syntaxe_creative,
        "test_syntaxe"
    )
    print(f"‚úÖ R√©sultat r√©cup√©ration syntaxe: {type(resultat2).__name__}")
    
    # Test 3: R√©cup√©ration d'erreur d'import
    print("\nüß™ Test 3: R√©cup√©ration d'erreur d'import")
    
    def operation_import_impossible():
        import module_totalement_inexistant
        return module_totalement_inexistant.fonction()
    
    resultat3 = recuperation.executer_avec_recuperation(
        operation_import_impossible,
        "test_import"
    )
    print(f"‚úÖ R√©sultat r√©cup√©ration import: {type(resultat3).__name__}")
    
    # Test 4: Op√©ration qui r√©ussit normalement
    print("\nüß™ Test 4: Op√©ration normale (sans r√©cup√©ration)")
    
    def operation_normale():
        return {"succes": True, "message": "Op√©ration r√©ussie"}
    
    resultat4 = recuperation.executer_avec_recuperation(
        operation_normale,
        "test_normal"
    )
    print(f"‚úÖ R√©sultat op√©ration normale: {resultat4}")
    
    # Afficher les statistiques
    print("\nüìä Statistiques de r√©cup√©ration:")
    stats = recuperation.obtenir_statistiques_recuperation()
    for cle, valeur in stats.items():
        print(f"   ‚Ä¢ {cle}: {valeur}")
    
    # G√©n√©rer le rapport
    print("\nüìã Rapport de r√©cup√©ration:")
    rapport = recuperation.generer_rapport_recuperation()
    print(rapport)
    
    print("\nüéâ Test termin√© avec r√©silience!")


if __name__ == "__main__":
    main()