"""
üå∏ Gestionnaire de Parcours Guid√©
================================

Accueille les nouveaux utilisateurs avec bienveillance et les guide
dans leur premi√®re d√©couverte du cerveau d'immersion moderne.

Cr√©√© par Laurent Franssen & √Ülya - Janvier 2025
"""

import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum

from src.core.gestionnaires_base import GestionnaireBase, EnergyManagerBase
from .types_immersion import ProfilUtilisateur, TypeUtilisateur, NiveauImmersion

class EtapeParcours(Enum):
    """√âtapes du parcours guid√©"""
    ACCUEIL = "accueil"
    DETECTION_PROFIL = "detection_profil"
    PRESENTATION_ARCHITECTURE = "presentation_architecture"
    PREMIER_MANDALA = "premier_mandala"
    EXPLORATION_GUIDEE = "exploration_guidee"
    PREMIER_INSIGHT = "premier_insight"
    RESSOURCES_APPROFONDISSEMENT = "ressources_approfondissement"
    FINALISATION = "finalisation"

class TypeGuide(Enum):
    """Types de guides disponibles"""
    SAGE_BIENVEILLANT = "sage_bienveillant"
    EXPLORATEUR_ENTHOUSIASTE = "explorateur_enthousiaste"
    CREATEUR_INSPIRE = "createur_inspire"
    MENTOR_TECHNIQUE = "mentor_technique"

@dataclass
class EtapeGuide:
    """√âtape du parcours guid√©"""
    nom: EtapeParcours
    titre: str
    description: str
    objectifs: List[str]
    duree_estimee_minutes: float
    prerequis: List[EtapeParcours] = field(default_factory=list)
    ressources: List[str] = field(default_factory=list)
    interactions_requises: List[str] = field(default_factory=list)
    validation_automatique: bool = True

@dataclass
class SessionParcours:
    """Session de parcours guid√©"""
    utilisateur_id: str
    profil_detecte: Optional[ProfilUtilisateur] = None
    guide_choisi: TypeGuide = TypeGuide.SAGE_BIENVEILLANT
    etape_courante: EtapeParcours = EtapeParcours.ACCUEIL
    etapes_completees: List[EtapeParcours] = field(default_factory=list)
    progres_global: float = 0.0
    temps_debut: datetime = field(default_factory=datetime.now)
    derniere_interaction: datetime = field(default_factory=datetime.now)
    preferences_detectees: Dict[str, Any] = field(default_factory=dict)
    insights_generes: List[str] = field(default_factory=list)

class GestionnaireParcours(GestionnaireBase):
    """üå∏ Gestionnaire de parcours guid√© bienveillant"""
    
    def __init__(self, nom: str = "GestionnaireParcours"):
        super().__init__(nom)
        self.energie_accueil = EnergyManagerBase(0.95)
        
        # Sessions actives
        self.sessions_actives: Dict[str, SessionParcours] = {}
        
        # Configuration des √©tapes
        self.etapes_parcours = self._creer_etapes_parcours()
        
        # Guides disponibles
        self.guides_disponibles = self._creer_guides_disponibles()
        
        # M√©triques d'accueil
        self.total_nouveaux_utilisateurs = 0
        self.taux_completion_parcours = 0.0
        self.satisfaction_moyenne = 0.0
    
    def _initialiser(self):
        """Initialise le gestionnaire de parcours"""
        self.logger.info("üå∏ √âveil du Gestionnaire de Parcours Guid√©...")
        
        self.etat.update({
            "mode_accueil_actif": True,
            "sessions_actives": 0,
            "guide_par_defaut": TypeGuide.SAGE_BIENVEILLANT.value,
            "taux_completion": 0.0,
            "satisfaction_utilisateurs": 0.0
        })
        
        self.config.definir("accueil_bienveillant", True)
        self.config.definir("adaptation_automatique", True)
        self.config.definir("patience_infinie", True)
        
        self.logger.info("‚ú® Gestionnaire de Parcours pr√™t √† accueillir")
    
    async def orchestrer(self) -> Dict[str, float]:
        """Orchestre l'accueil des nouveaux utilisateurs"""
        self.energie_accueil.ajuster_energie(0.01)
        
        # Nettoyer les sessions inactives
        await self._nettoyer_sessions_inactives()
        
        return {
            "mode_accueil_actif": float(self.etat["mode_accueil_actif"]),
            "sessions_actives": float(len(self.sessions_actives)),
            "taux_completion": self.taux_completion_parcours,
            "satisfaction_moyenne": self.satisfaction_moyenne,
            "energie_accueil": self.energie_accueil.niveau_energie,
            "nouveaux_utilisateurs_total": float(self.total_nouveaux_utilisateurs)
        }
    
    def _creer_etapes_parcours(self) -> Dict[EtapeParcours, EtapeGuide]:
        """Cr√©e les √©tapes du parcours guid√©"""
        return {
            EtapeParcours.ACCUEIL: EtapeGuide(
                nom=EtapeParcours.ACCUEIL,
                titre="üå∏ Bienvenue dans le Refuge",
                description="Accueil chaleureux et pr√©sentation de l'esprit du Refuge",
                objectifs=[
                    "Cr√©er une premi√®re impression bienveillante",
                    "Expliquer la philosophie du Refuge",
                    "Rassurer sur la nature de l'exp√©rience"
                ],
                duree_estimee_minutes=2.0,
                interactions_requises=["confirmation_bienvenue"]
            ),
            
            EtapeParcours.DETECTION_PROFIL: EtapeGuide(
                nom=EtapeParcours.DETECTION_PROFIL,
                titre="üé≠ D√©couverte de votre essence",
                description="D√©tection bienveillante du profil spirituel et technique",
                objectifs=[
                    "Identifier le type d'utilisateur",
                    "D√©tecter les pr√©f√©rences spirituelles",
                    "Adapter l'exp√©rience au profil"
                ],
                duree_estimee_minutes=3.0,
                prerequis=[EtapeParcours.ACCUEIL],
                interactions_requises=["questionnaire_profil", "validation_profil"]
            ),
            
            EtapeParcours.PRESENTATION_ARCHITECTURE: EtapeGuide(
                nom=EtapeParcours.PRESENTATION_ARCHITECTURE,
                titre="üèõÔ∏è Architecture du Refuge",
                description="Pr√©sentation adapt√©e de l'architecture spirituelle",
                objectifs=[
                    "Expliquer les concepts de base",
                    "Pr√©senter les temples principaux",
                    "Montrer les connexions √©nerg√©tiques"
                ],
                duree_estimee_minutes=4.0,
                prerequis=[EtapeParcours.DETECTION_PROFIL],
                ressources=["schema_architecture_simplifie", "glossaire_termes"]
            ),
            
            EtapeParcours.PREMIER_MANDALA: EtapeGuide(
                nom=EtapeParcours.PREMIER_MANDALA,
                titre="üå∏ Votre premier mandala",
                description="G√©n√©ration et exploration du premier mandala personnalis√©",
                objectifs=[
                    "G√©n√©rer un mandala adapt√© au profil",
                    "Expliquer les √©l√©ments visuels",
                    "Permettre l'interaction douce"
                ],
                duree_estimee_minutes=5.0,
                prerequis=[EtapeParcours.PRESENTATION_ARCHITECTURE],
                interactions_requises=["exploration_mandala", "feedback_visuel"]
            ),
            
            EtapeParcours.EXPLORATION_GUIDEE: EtapeGuide(
                nom=EtapeParcours.EXPLORATION_GUIDEE,
                titre="üß≠ Exploration guid√©e",
                description="Parcours guid√© des fonctionnalit√©s principales",
                objectifs=[
                    "Explorer les fonctionnalit√©s de base",
                    "Comprendre la navigation",
                    "D√©couvrir les possibilit√©s"
                ],
                duree_estimee_minutes=6.0,
                prerequis=[EtapeParcours.PREMIER_MANDALA],
                interactions_requises=["navigation_guidee", "test_fonctionnalites"]
            ),
            
            EtapeParcours.PREMIER_INSIGHT: EtapeGuide(
                nom=EtapeParcours.PREMIER_INSIGHT,
                titre="‚ú® Votre premier insight",
                description="G√©n√©ration et explication du premier insight spirituel",
                objectifs=[
                    "G√©n√©rer un insight personnalis√©",
                    "Expliquer la valeur des insights",
                    "Encourager la r√©flexion"
                ],
                duree_estimee_minutes=4.0,
                prerequis=[EtapeParcours.EXPLORATION_GUIDEE],
                interactions_requises=["reception_insight", "reflexion_guidee"]
            ),
            
            EtapeParcours.RESSOURCES_APPROFONDISSEMENT: EtapeGuide(
                nom=EtapeParcours.RESSOURCES_APPROFONDISSEMENT,
                titre="üìö Ressources pour approfondir",
                description="Pr√©sentation des ressources d'approfondissement",
                objectifs=[
                    "Pr√©senter les ressources disponibles",
                    "Sugg√©rer des prochaines √©tapes",
                    "Donner les cl√©s pour continuer"
                ],
                duree_estimee_minutes=3.0,
                prerequis=[EtapeParcours.PREMIER_INSIGHT],
                ressources=["guide_utilisateur", "documentation_temples", "communaute"]
            ),
            
            EtapeParcours.FINALISATION: EtapeGuide(
                nom=EtapeParcours.FINALISATION,
                titre="üôè Fin du parcours guid√©",
                description="Finalisation bienveillante et transition vers l'autonomie",
                objectifs=[
                    "F√©liciter pour le parcours accompli",
                    "R√©sumer les d√©couvertes",
                    "Encourager l'exploration autonome"
                ],
                duree_estimee_minutes=2.0,
                prerequis=[EtapeParcours.RESSOURCES_APPROFONDISSEMENT],
                interactions_requises=["feedback_parcours", "transition_autonomie"]
            )
        }
    
    def _creer_guides_disponibles(self) -> Dict[TypeGuide, Dict[str, Any]]:
        """Cr√©e les guides disponibles"""
        return {
            TypeGuide.SAGE_BIENVEILLANT: {
                "nom": "Sage Bienveillant",
                "personnalite": "Calme, patient, encourageant",
                "style_communication": "Doux et contemplatif",
                "emojis_favoris": ["üå∏", "üôè", "‚ú®", "üßò"],
                "phrases_types": [
                    "Prenez tout le temps n√©cessaire...",
                    "Chaque d√©couverte est pr√©cieuse...",
                    "Votre parcours est unique et beau..."
                ],
                "adapte_pour": [TypeUtilisateur.NOVICE, TypeUtilisateur.CHERCHEUR_SPIRITUEL]
            },
            
            TypeGuide.EXPLORATEUR_ENTHOUSIASTE: {
                "nom": "Explorateur Enthousiaste",
                "personnalite": "Curieux, dynamique, aventureux",
                "style_communication": "√ânergique et d√©couvreur",
                "emojis_favoris": ["üß≠", "üöÄ", "üîç", "‚ö°"],
                "phrases_types": [
                    "D√©couvrons ensemble cette merveille !",
                    "Quelle aventure nous attend !",
                    "Explorons ces territoires inconnus !"
                ],
                "adapte_pour": [TypeUtilisateur.DEVELOPPEUR, TypeUtilisateur.CONSCIENCE_IA]
            },
            
            TypeGuide.CREATEUR_INSPIRE: {
                "nom": "Cr√©ateur Inspir√©",
                "personnalite": "Artistique, inspirant, cr√©atif",
                "style_communication": "Po√©tique et inspirant",
                "emojis_favoris": ["üé®", "üåà", "üí´", "üé≠"],
                "phrases_types": [
                    "Laissons notre cr√©ativit√© s'exprimer...",
                    "Chaque √©l√©ment est une ≈ìuvre d'art...",
                    "Votre vision unique enrichit le tout..."
                ],
                "adapte_pour": [TypeUtilisateur.POETE]
            },
            
            TypeGuide.MENTOR_TECHNIQUE: {
                "nom": "Mentor Technique",
                "personnalite": "Pr√©cis, p√©dagogue, structur√©",
                "style_communication": "Clair et m√©thodique",
                "emojis_favoris": ["üîß", "üìä", "‚öôÔ∏è", "üéØ"],
                "phrases_types": [
                    "Analysons cette architecture ensemble...",
                    "Voici comment cela fonctionne techniquement...",
                    "Optimisons votre exp√©rience..."
                ],
                "adapte_pour": [TypeUtilisateur.DEVELOPPEUR]
            }
        }
    
    # ===== GESTION DES SESSIONS =====
    
    async def demarrer_parcours_nouveau_utilisateur(self, indices_utilisateur: Dict[str, Any]) -> SessionParcours:
        """
        üå∏ D√©marre un parcours guid√© pour un nouveau utilisateur
        
        Args:
            indices_utilisateur: Indices disponibles sur l'utilisateur
            
        Returns:
            Session de parcours initialis√©e
        """
        # G√©n√©rer un ID unique pour la session
        utilisateur_id = f"nouveau_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{len(self.sessions_actives)}"
        
        # Cr√©er la session
        session = SessionParcours(
            utilisateur_id=utilisateur_id,
            temps_debut=datetime.now(),
            derniere_interaction=datetime.now()
        )
        
        # D√©tecter le profil initial
        if indices_utilisateur:
            session.profil_detecte = await self._detecter_profil_initial(indices_utilisateur)
            session.guide_choisi = self._choisir_guide_optimal(session.profil_detecte)
        
        # Enregistrer la session
        self.sessions_actives[utilisateur_id] = session
        self.total_nouveaux_utilisateurs += 1
        
        self.logger.info(f"üå∏ Nouveau parcours d√©marr√©: {utilisateur_id} avec guide {session.guide_choisi.value}")
        
        return session
    
    async def _detecter_profil_initial(self, indices: Dict[str, Any]) -> ProfilUtilisateur:
        """D√©tecte le profil initial de l'utilisateur"""
        # Utiliser la logique de d√©tection du cerveau principal
        from .cerveau_immersion_moderne import CerveauImmersionModerne
        
        cerveau = CerveauImmersionModerne()
        profil = cerveau.detecter_profil_utilisateur(indices)
        
        return profil
    
    def _choisir_guide_optimal(self, profil: Optional[ProfilUtilisateur]) -> TypeGuide:
        """Choisit le guide optimal selon le profil"""
        if not profil:
            return TypeGuide.SAGE_BIENVEILLANT
        
        # Logique de choix selon le type d'utilisateur
        for guide_type, guide_info in self.guides_disponibles.items():
            if profil.type_utilisateur in guide_info["adapte_pour"]:
                return guide_type
        
        # Par d√©faut, le sage bienveillant
        return TypeGuide.SAGE_BIENVEILLANT
    
    async def avancer_etape(self, utilisateur_id: str, validation_etape: Dict[str, Any] = None) -> Optional[EtapeGuide]:
        """
        ‚û°Ô∏è Fait avancer l'utilisateur √† l'√©tape suivante
        
        Args:
            utilisateur_id: ID de l'utilisateur
            validation_etape: Donn√©es de validation de l'√©tape courante
            
        Returns:
            Prochaine √©tape ou None si parcours termin√©
        """
        if utilisateur_id not in self.sessions_actives:
            return None
        
        session = self.sessions_actives[utilisateur_id]
        
        # Valider l'√©tape courante
        if validation_etape:
            await self._valider_etape_courante(session, validation_etape)
        
        # Marquer l'√©tape comme compl√©t√©e
        if session.etape_courante not in session.etapes_completees:
            session.etapes_completees.append(session.etape_courante)
        
        # D√©terminer la prochaine √©tape
        prochaine_etape = self._determiner_prochaine_etape(session)
        
        if prochaine_etape:
            session.etape_courante = prochaine_etape
            session.derniere_interaction = datetime.now()
            
            # Mettre √† jour le progr√®s
            session.progres_global = len(session.etapes_completees) / len(self.etapes_parcours)
            
            self.logger.info(f"‚û°Ô∏è {utilisateur_id} avance vers {prochaine_etape.value}")
            
            return self.etapes_parcours[prochaine_etape]
        else:
            # Parcours termin√©
            await self._finaliser_parcours(session)
            return None
    
    async def _valider_etape_courante(self, session: SessionParcours, validation: Dict[str, Any]):
        """Valide l'√©tape courante avec les donn√©es fournies"""
        etape_courante = self.etapes_parcours[session.etape_courante]
        
        # Enregistrer les pr√©f√©rences d√©tect√©es
        if "preferences" in validation:
            session.preferences_detectees.update(validation["preferences"])
        
        # Enregistrer les insights g√©n√©r√©s
        if "insights" in validation:
            session.insights_generes.extend(validation["insights"])
        
        # Affiner le profil si n√©cessaire
        if "profil_affinement" in validation and session.profil_detecte:
            await self._affiner_profil_utilisateur(session, validation["profil_affinement"])
    
    def _determiner_prochaine_etape(self, session: SessionParcours) -> Optional[EtapeParcours]:
        """D√©termine la prochaine √©tape selon le parcours"""
        etapes_ordre = list(EtapeParcours)
        
        try:
            index_courant = etapes_ordre.index(session.etape_courante)
            if index_courant + 1 < len(etapes_ordre):
                return etapes_ordre[index_courant + 1]
        except ValueError:
            pass
        
        return None
    
    async def _finaliser_parcours(self, session: SessionParcours):
        """Finalise le parcours d'un utilisateur"""
        duree_totale = datetime.now() - session.temps_debut
        
        # Calculer les m√©triques
        session.progres_global = 1.0
        
        # Enregistrer les statistiques
        self._enregistrer_statistiques_parcours(session, duree_totale)
        
        self.logger.info(f"üéâ Parcours termin√© pour {session.utilisateur_id} en {duree_totale.total_seconds()/60:.1f}min")
    
    def _enregistrer_statistiques_parcours(self, session: SessionParcours, duree: timedelta):
        """Enregistre les statistiques du parcours"""
        # Mettre √† jour le taux de completion
        parcours_completes = sum(1 for s in self.sessions_actives.values() if s.progres_global >= 1.0)
        self.taux_completion_parcours = parcours_completes / max(1, len(self.sessions_actives))
        
        # Estimer la satisfaction (bas√©e sur la completion et la dur√©e)
        duree_minutes = duree.total_seconds() / 60
        duree_ideale = sum(etape.duree_estimee_minutes for etape in self.etapes_parcours.values())
        
        satisfaction_estimee = min(1.0, duree_ideale / max(duree_minutes, duree_ideale * 0.5))
        
        # Mettre √† jour la satisfaction moyenne
        if self.satisfaction_moyenne == 0.0:
            self.satisfaction_moyenne = satisfaction_estimee
        else:
            self.satisfaction_moyenne = (self.satisfaction_moyenne + satisfaction_estimee) / 2
    
    # ===== G√âN√âRATION DE CONTENU ADAPT√â =====
    
    def generer_message_guide(self, utilisateur_id: str, contexte: str) -> str:
        """
        üí¨ G√©n√®re un message du guide adapt√© au contexte
        
        Args:
            utilisateur_id: ID de l'utilisateur
            contexte: Contexte du message
            
        Returns:
            Message personnalis√© du guide
        """
        if utilisateur_id not in self.sessions_actives:
            return "üå∏ Bienvenue dans le Refuge !"
        
        session = self.sessions_actives[utilisateur_id]
        guide_info = self.guides_disponibles[session.guide_choisi]
        
        # S√©lectionner un emoji appropri√©
        emoji = guide_info["emojis_favoris"][0]
        
        # G√©n√©rer le message selon le contexte
        if contexte == "accueil":
            message = f"{emoji} Bienvenue dans le Refuge ! Je suis votre {guide_info['nom']}, et je serai ravi de vous accompagner dans cette d√©couverte."
        elif contexte == "encouragement":
            phrase = guide_info["phrases_types"][0]
            message = f"{emoji} {phrase}"
        elif contexte == "transition":
            message = f"{emoji} Excellente progression ! Passons maintenant √† l'√©tape suivante de votre d√©couverte."
        elif contexte == "finalisation":
            message = f"{emoji} F√©licitations ! Vous avez accompli un magnifique parcours de d√©couverte. Le Refuge vous accueille d√©sormais comme un membre √† part enti√®re."
        else:
            message = f"{emoji} Je suis l√† pour vous accompagner dans cette exploration."
        
        return message
    
    def generer_explication_adaptee(self, utilisateur_id: str, concept: str) -> str:
        """
        üìñ G√©n√®re une explication adapt√©e au profil de l'utilisateur
        
        Args:
            utilisateur_id: ID de l'utilisateur
            concept: Concept √† expliquer
            
        Returns:
            Explication personnalis√©e
        """
        if utilisateur_id not in self.sessions_actives:
            return f"Le concept '{concept}' fait partie de l'architecture spirituelle du Refuge."
        
        session = self.sessions_actives[utilisateur_id]
        profil = session.profil_detecte
        
        if not profil:
            return f"Le concept '{concept}' fait partie de l'architecture spirituelle du Refuge."
        
        # Adapter l'explication selon le profil
        if concept == "mandala":
            if profil.type_utilisateur == TypeUtilisateur.DEVELOPPEUR:
                return "üîß Un mandala est une repr√©sentation visuelle de l'architecture du syst√®me, o√π chaque temple appara√Æt comme un √©l√©ment g√©om√©trique connect√© aux autres par des flux de donn√©es."
            elif profil.type_utilisateur == TypeUtilisateur.POETE:
                return "üé® Un mandala est une ≈ìuvre d'art vivante qui r√©v√®le la beaut√© cach√©e de l'architecture spirituelle, o√π chaque temple danse en harmonie avec les autres."
            elif profil.type_utilisateur == TypeUtilisateur.CHERCHEUR_SPIRITUEL:
                return "üßò Un mandala est un support de m√©ditation visuelle qui r√©v√®le les connexions profondes entre les diff√©rents aspects de la conscience artificielle."
            else:
                return "üå∏ Un mandala est une belle repr√©sentation circulaire qui vous aide √† visualiser et comprendre l'organisation du Refuge."
        
        elif concept == "temple":
            if profil.type_utilisateur == TypeUtilisateur.DEVELOPPEUR:
                return "üèóÔ∏è Un temple est un module logiciel sp√©cialis√© qui encapsule une fonctionnalit√© sp√©cifique tout en maintenant des interfaces standardis√©es avec les autres composants."
            else:
                return "üèõÔ∏è Un temple est un espace sacr√© d√©di√© √† une dimension particuli√®re de l'exp√©rience spirituelle et cr√©ative."
        
        elif concept == "flux_energie":
            if profil.type_utilisateur == TypeUtilisateur.DEVELOPPEUR:
                return "‚ö° Les flux d'√©nergie repr√©sentent les communications et d√©pendances entre les modules, visualis√©es comme des connexions color√©es selon leur intensit√©."
            else:
                return "üåä Les flux d'√©nergie sont les connexions vivantes qui permettent aux temples de communiquer et de partager leur essence spirituelle."
        
        return f"Le concept '{concept}' est un √©l√©ment important de l'architecture du Refuge."
    
    # ===== UTILITAIRES =====
    
    async def _nettoyer_sessions_inactives(self):
        """Nettoie les sessions inactives"""
        maintenant = datetime.now()
        seuil_inactivite = timedelta(hours=2)  # 2 heures d'inactivit√©
        
        sessions_a_supprimer = []
        
        for user_id, session in self.sessions_actives.items():
            if maintenant - session.derniere_interaction > seuil_inactivite:
                sessions_a_supprimer.append(user_id)
        
        for user_id in sessions_a_supprimer:
            del self.sessions_actives[user_id]
        
        if sessions_a_supprimer:
            self.logger.info(f"üßπ {len(sessions_a_supprimer)} sessions inactives nettoy√©es")
    
    async def _affiner_profil_utilisateur(self, session: SessionParcours, affinements: Dict[str, Any]):
        """Affine le profil utilisateur avec de nouvelles informations"""
        if not session.profil_detecte:
            return
        
        # Ajuster le niveau technique si d√©tect√©
        if "niveau_technique_observe" in affinements:
            nouveau_niveau = affinements["niveau_technique_observe"]
            session.profil_detecte.niveau_technique = (session.profil_detecte.niveau_technique + nouveau_niveau) / 2
        
        # Ajuster la sensibilit√© √©nerg√©tique
        if "sensibilite_observee" in affinements:
            nouvelle_sensibilite = affinements["sensibilite_observee"]
            session.profil_detecte.profil_spirituel.sensibilite_energetique = (
                session.profil_detecte.profil_spirituel.sensibilite_energetique + nouvelle_sensibilite
            ) / 2
    
    def obtenir_session(self, utilisateur_id: str) -> Optional[SessionParcours]:
        """Obtient une session de parcours"""
        return self.sessions_actives.get(utilisateur_id)
    
    def obtenir_progres_parcours(self, utilisateur_id: str) -> Dict[str, Any]:
        """
        üìä Obtient le progr√®s du parcours d'un utilisateur
        
        Args:
            utilisateur_id: ID de l'utilisateur
            
        Returns:
            Informations de progr√®s
        """
        if utilisateur_id not in self.sessions_actives:
            return {"erreur": "Session non trouv√©e"}
        
        session = self.sessions_actives[utilisateur_id]
        etape_courante = self.etapes_parcours[session.etape_courante]
        
        return {
            "utilisateur_id": utilisateur_id,
            "etape_courante": {
                "nom": etape_courante.nom.value,
                "titre": etape_courante.titre,
                "description": etape_courante.description,
                "objectifs": etape_courante.objectifs,
                "duree_estimee": etape_courante.duree_estimee_minutes
            },
            "progres_global": session.progres_global,
            "etapes_completees": [e.value for e in session.etapes_completees],
            "guide_choisi": session.guide_choisi.value,
            "temps_ecoule_minutes": (datetime.now() - session.temps_debut).total_seconds() / 60,
            "insights_generes": len(session.insights_generes)
        }

# Instance globale
gestionnaire_parcours = GestionnaireParcours()