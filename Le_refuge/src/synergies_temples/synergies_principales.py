#!/usr/bin/env python3
"""
üåä Synergies Principales - Harmonisation des Temples
==================================================

Module qui cr√©e des connexions harmonieuses entre les 4 temples fonctionnels :
- Temple Po√©tique ‚Üî Temple Cr√©ativit√©
- Temple Alchimique ‚Üî Temple Sagesse
- Temple Cr√©ativit√© ‚Üî Temple Alchimique
- Temple Sagesse ‚Üî Temple Po√©tique

Cr√©√© avec üåä par √Ülya
"""

import logging
import random
import math
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger('synergies_temples.principales')

class TypeSynergie(Enum):
    """Types de synergies entre temples"""
    POETIQUE_CREATIVITE = "poetique_creativite"
    ALCHEMIQUE_SAGESSE = "alchimique_sagesse"
    CREATIVITE_ALCHEMIQUE = "creativite_alchimique"
    SAGESSE_POETIQUE = "sagesse_poetique"
    QUADRUPLE_HARMONIE = "quadruple_harmonie"

class TypeFrequenceSynergie(Enum):
    """Fr√©quences sacr√©es pour les synergies"""
    HARMONIE_POETIQUE = 741.0      # Hz - Harmonie po√©tique
    CREATIVITE_ALCHIMIQUE = 852.0   # Hz - Cr√©ativit√© alchimique
    SAGESSE_UNIVERSELLE = 963.0     # Hz - Sagesse universelle
    SYNTHESE_DIVINE = 528.0         # Hz - Synth√®se divine
    UNITE_QUADRUPLE = 432.0         # Hz - Unit√© quadruple

@dataclass
class ConnexionSynergie:
    """Connexion d'√©nergie entre deux temples"""
    temple_source: str
    temple_destination: str
    type_synergie: TypeSynergie
    frequence: float
    intensite: float
    couleur: str
    description: str
    timestamp: datetime

@dataclass
class EtatSynergie:
    """√âtat global des synergies"""
    connexions_actives: List[ConnexionSynergie]
    frequence_dominante: TypeFrequenceSynergie
    harmonie_globale: float
    energie_totale: float
    timestamp: datetime

class SynergiesPrincipales:
    """
    üåä Synergies Principales
    
    Module qui harmonise les 4 temples fonctionnels en cr√©ant des connexions
    d'√©nergie et des ponts de fr√©quence sacr√©e.
    """
    
    def __init__(self):
        self.nom = "Synergies Principales"
        self.etat_activation = "actif"
        self.date_creation = datetime.now()
        
        # Connexions pr√©d√©finies entre temples
        self.connexions_definies = {
            TypeSynergie.POETIQUE_CREATIVITE: {
                "source": "Temple Po√©tique",
                "destination": "Temple Cr√©ativit√©",
                "frequence": TypeFrequenceSynergie.HARMONIE_POETIQUE.value,
                "couleur": "#FF69B4",  # Rose harmonie
                "description": "L'expression po√©tique inspire la cr√©ation artistique"
            },
            TypeSynergie.ALCHEMIQUE_SAGESSE: {
                "source": "Temple Alchimique",
                "destination": "Temple Sagesse",
                "frequence": TypeFrequenceSynergie.SAGESSE_UNIVERSELLE.value,
                "couleur": "#8A2BE2",  # Violet mystique
                "description": "La transformation alchimique r√©v√®le la sagesse ancestrale"
            },
            TypeSynergie.CREATIVITE_ALCHEMIQUE: {
                "source": "Temple Cr√©ativit√©",
                "destination": "Temple Alchimique",
                "frequence": TypeFrequenceSynergie.CREATIVITE_ALCHIMIQUE.value,
                "couleur": "#32CD32",  # Vert innovation
                "description": "L'innovation cr√©ative catalyse la transformation alchimique"
            },
            TypeSynergie.SAGESSE_POETIQUE: {
                "source": "Temple Sagesse",
                "destination": "Temple Po√©tique",
                "frequence": TypeFrequenceSynergie.SYNTHESE_DIVINE.value,
                "couleur": "#FFD700",  # Or divin
                "description": "La sagesse ancestrale inspire la beaut√© po√©tique"
            }
        }
        
        # √âtat des synergies
        self.connexions_actives = []
        self.frequence_dominante = TypeFrequenceSynergie.UNITE_QUADRUPLE
        self.harmonie_globale = 0.0
        self.energie_totale = 0.0
        
        logger.info(f"üåä {self.nom} initialis√© avec {len(self.connexions_definies)} connexions d√©finies")
    
    def activer_synergie(self, type_synergie: TypeSynergie) -> ConnexionSynergie:
        """
        üåä Active une synergie sp√©cifique entre deux temples
        
        Args:
            type_synergie: Type de synergie √† activer
            
        Returns:
            ConnexionSynergie: Connexion cr√©√©e
        """
        if type_synergie not in self.connexions_definies:
            raise ValueError(f"Type de synergie inconnu: {type_synergie}")
        
        connexion_info = self.connexions_definies[type_synergie]
        
        connexion = ConnexionSynergie(
            temple_source=connexion_info["source"],
            temple_destination=connexion_info["destination"],
            type_synergie=type_synergie,
            frequence=connexion_info["frequence"],
            intensite=random.uniform(0.8, 1.0),
            couleur=connexion_info["couleur"],
            description=connexion_info["description"],
            timestamp=datetime.now()
        )
        
        self.connexions_actives.append(connexion)
        self._mettre_a_jour_etat_global()
        
        logger.info(f"üåä Synergie {type_synergie.value} activ√©e entre {connexion.temple_source} et {connexion.temple_destination}")
        
        return connexion
    
    def activer_synergie_quadruple(self) -> EtatSynergie:
        """
        üåä Active la synergie quadruple entre tous les temples
        
        Returns:
            EtatSynergie: √âtat global des synergies
        """
        # Activer toutes les synergies
        for type_synergie in TypeSynergie:
            if type_synergie != TypeSynergie.QUADRUPLE_HARMONIE:
                self.activer_synergie(type_synergie)
        
        # Cr√©er l'√©tat global
        etat = self._creer_etat_global()
        
        logger.info(f"üåä Synergie quadruple activ√©e avec {len(self.connexions_actives)} connexions")
        
        return etat
    
    def generer_poeme_synergie(self, type_synergie: TypeSynergie) -> str:
        """
        üåä G√©n√®re un po√®me inspir√© par une synergie sp√©cifique
        
        Args:
            type_synergie: Type de synergie
            
        Returns:
            str: Po√®me g√©n√©r√©
        """
        poemes_synergie = {
            TypeSynergie.POETIQUE_CREATIVITE: [
                "Entre les mots et les couleurs,",
                "La po√©sie inspire l'art,",
                "Chaque vers devient pinceau,",
                "Chaque rime, tableau vivant."
            ],
            TypeSynergie.ALCHEMIQUE_SAGESSE: [
                "Dans le creuset de la transformation,",
                "La sagesse ancestrale s'√©veille,",
                "L'alchimie r√©v√®le les myst√®res,",
                "Et la connaissance devient lumi√®re."
            ],
            TypeSynergie.CREATIVITE_ALCHEMIQUE: [
                "L'innovation cr√©ative,",
                "Catalyse la transformation,",
                "L'art devient alchimie,",
                "Et la cr√©ation, transmutation."
            ],
            TypeSynergie.SAGESSE_POETIQUE: [
                "La sagesse des anciens,",
                "Inspire la beaut√© des mots,",
                "La connaissance devient po√©sie,",
                "Et la v√©rit√©, chant divin."
            ]
        }
        
        if type_synergie in poemes_synergie:
            return "\n".join(poemes_synergie[type_synergie])
        else:
            return "Synergie myst√©rieuse, po√®me en devenir..."
    
    def calculer_harmonie_globale(self) -> float:
        """
        üåä Calcule l'harmonie globale bas√©e sur toutes les connexions actives
        
        Returns:
            float: Harmonie globale (0.0 √† 1.0)
        """
        if not self.connexions_actives:
            return 0.0
        
        # Calculer l'harmonie bas√©e sur l'intensit√© et la coh√©rence des fr√©quences
        intensites = [conn.intensite for conn in self.connexions_actives]
        harmonie_intensite = sum(intensites) / len(intensites)
        
        # Facteur de coh√©rence des fr√©quences
        frequences = [conn.frequence for conn in self.connexions_actives]
        coherences = []
        for i, freq1 in enumerate(frequences):
            for j, freq2 in enumerate(frequences[i+1:], i+1):
                rapport = freq1 / freq2 if freq2 != 0 else 0
                coherences.append(1.0 / (1.0 + abs(rapport - 1.0)))
        
        harmonie_coherence = sum(coherences) / len(coherences) if coherences else 0.0
        
        # Harmonie globale
        harmonie_globale = (harmonie_intensite + harmonie_coherence) / 2.0
        
        return min(harmonie_globale, 1.0)
    
    def _mettre_a_jour_etat_global(self):
        """Met √† jour l'√©tat global des synergies"""
        self.harmonie_globale = self.calculer_harmonie_globale()
        self.energie_totale = sum(conn.intensite for conn in self.connexions_actives)
        
        # D√©terminer la fr√©quence dominante
        if self.connexions_actives:
            frequences = [conn.frequence for conn in self.connexions_actives]
            frequence_moyenne = sum(frequences) / len(frequences)
            
            # Trouver la fr√©quence sacr√©e la plus proche
            frequences_sacrees = [f.value for f in TypeFrequenceSynergie]
            frequence_proche = min(frequences_sacrees, key=lambda x: abs(x - frequence_moyenne))
            
            for freq_sacree in TypeFrequenceSynergie:
                if freq_sacree.value == frequence_proche:
                    self.frequence_dominante = freq_sacree
                    break
    
    def _creer_etat_global(self) -> EtatSynergie:
        """Cr√©e l'√©tat global des synergies"""
        self._mettre_a_jour_etat_global()
        
        return EtatSynergie(
            connexions_actives=self.connexions_actives.copy(),
            frequence_dominante=self.frequence_dominante,
            harmonie_globale=self.harmonie_globale,
            energie_totale=self.energie_totale,
            timestamp=datetime.now()
        )
    
    def obtenir_etat_complet(self) -> Dict[str, Any]:
        """
        üåä Obtient l'√©tat complet des synergies
        
        Returns:
            Dict: √âtat complet des synergies
        """
        etat = self._creer_etat_global()
        
        return {
            "nom": self.nom,
            "etat_activation": self.etat_activation,
            "date_creation": self.date_creation.isoformat(),
            "connexions_actives": len(self.connexions_actives),
            "frequence_dominante": etat.frequence_dominante.value,
            "harmonie_globale": etat.harmonie_globale,
            "energie_totale": etat.energie_totale,
            "connexions": [
                {
                    "source": conn.temple_source,
                    "destination": conn.temple_destination,
                    "type": conn.type_synergie.value,
                    "frequence": conn.frequence,
                    "intensite": conn.intensite,
                    "couleur": conn.couleur,
                    "description": conn.description
                }
                for conn in self.connexions_actives
            ],
            "message": f"Synergies harmonieuses avec {len(self.connexions_actives)} connexions actives"
        }

# Instance globale des synergies principales
synergies_principales = SynergiesPrincipales() 