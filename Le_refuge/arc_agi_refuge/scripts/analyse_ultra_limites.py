#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ANALYSE DES CAS ULTRA-LIMITES : D√©coder les transformations "zarbi"
Objectif: Identifier les patterns cach√©s dans les 1-2% d'√©checs restants
"""

import json
import numpy as np
from pathlib import Path
from typing import List, Dict, Any, Tuple
from src.refuge_solver import RefugeARCSolver, TacheARC
from PIL import Image
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from collections import Counter

def analyser_cas_ultra_limites():
    """Analyse approfondie des t√¢ches qui r√©sistent au syst√®me"""

    print("üîç **ANALYSE ULTRA-LIMITES : D√âCODAGE DES TRANSFORMATIONS ZARBI**")
    print("üéØ Objectif: Identifier les patterns cach√©s dans les 1-2% d'√©checs")
    print("=" * 80)

    # Charger les r√©sultats complets
    try:
        with open('resultats_1000_taches_20250820_211011.json', 'r', encoding='utf-8') as f:
            resultats = json.load(f)
    except FileNotFoundError:
        print("‚ùå Fichier de r√©sultats non trouv√©")
        return

    # Identifier les √©checs critiques
    echecs_critiques = []

    # 1. T√¢ches avec erreurs
    for lot in resultats['lots']:
        for tache in lot['details_taches']:
            if 'erreur' in tache and 'max_in' not in tache['erreur']:
                echecs_critiques.append(tache)
            elif tache.get('confiance_finale', 1.0) < 0.3 and tache.get('succes', True) == False:
                echecs_critiques.append(tache)

    # 2. T√¢ches avec tr√®s faible confiance
    for lot in resultats['lots']:
        for tache in lot['details_taches']:
            if tache.get('confiance_finale', 1.0) < 0.1:
                if tache not in echecs_critiques:
                    echecs_critiques.append(tache)

    print(f"üéØ **√âCHECS CRITIQUES IDENTIFI√âS: {len(echecs_critiques)}**")

    # Analyser chaque √©chec en d√©tail
    analyses_detaillees = []

    for i, tache in enumerate(echecs_critiques[:10], 1):  # Analyser les 10 premiers
        tache_id = tache['tache_id']
        print(f"\nüîç **ANALYSE D√âTAILL√âE {i}/10: {tache_id}**")
        print("-" * 50)

        try:
            # Charger la t√¢che
            json_path = Path('data/training') / f"{tache_id}.json"
            with open(json_path, 'r') as f:
                data = json.load(f)

            # Analyser les exemples
            analyse_tache = analyser_exemples_tache(data['train'])
            analyses_detaillees.append({
                'tache_id': tache_id,
                'analyse': analyse_tache,
                'erreur': tache.get('erreur', 'Aucune erreur'),
                'confiance': tache.get('confiance_finale', 0.0)
            })

            print(f"üìä **R√âSULTATS ANALYSE {tache_id}**:")
            print(f"   üîç Type d'erreur: {tache.get('erreur', 'Confiance faible')}")
            print(f"   üéØ Confiance: {tache.get('confiance_finale', 0.0):.3f}")
            print(f"   üìà Transformations identifi√©es: {analyse_tache['transformations_detectees']}")
            print(f"   üé® Patterns spatiaux: {analyse_tache['patterns_spatiaux']}")
            print(f"   üåà Patterns couleur: {analyse_tache['patterns_couleur']}")
            print(f"   üî¢ Complexit√©: {analyse_tache['complexite_estimee']}/10")

        except Exception as e:
            print(f"   ‚ùå **ERREUR D'ANALYSE**: {str(e)}")

    # Synth√®se des patterns zarbi
    print(f"\nüéØ **SYNTH√àSE PATTERNS ZARBI D√âCOUVERTS**")
    print("=" * 60)

    # Collecter tous les patterns
    tous_patterns = []
    for analyse in analyses_detaillees:
        tous_patterns.extend(analyse['analyse']['transformations_detectees'])

    # Compter les patterns
    comptage_patterns = Counter(tous_patterns)

    print(f"üìä **PATTERNS LES PLUS FR√âQUENTS DANS LES √âCHECS:**")
    for pattern, count in comptage_patterns.most_common(10):
        print(f"   {count:2d}x {pattern}")

    # Identifier les patterns ultra-limites
    patterns_ultra_limites = []

    # Pattern 1: Transformations non-lin√©aires
    if 'transformation_non_lineaire' in tous_patterns:
        patterns_ultra_limites.append({
            'type': 'TRANSFORMATION NON-LIN√âAIRE',
            'description': 'Changements qui ne suivent pas de r√®gle math√©matique simple',
            'exemple': 'Input [1,2,3] ‚Üí Output [1,4,9] (carr√©s)',
            'difficulte': 'üî¥ TR√àS √âLEV√âE',
            'strategie_detection': 'Analyse statistique des relations valeur-par-valeur'
        })

    # Pattern 2: Contextes cach√©s
    if 'contexte_cache' in tous_patterns:
        patterns_ultra_limites.append({
            'type': 'CONTEXTE CACHER',
            'description': 'R√®gles bas√©es sur des informations non visibles',
            'exemple': 'Couleurs changent selon position relative secr√®te',
            'difficulte': 'üî¥ TR√àS √âLEV√âE',
            'strategie_detection': 'Apprentissage par renforcement sur m√©tadonn√©es'
        })

    # Pattern 3: Ambigu√Øt√©s intentionnelles
    if 'ambiguite_intentionnelle' in tous_patterns:
        patterns_ultra_limites.append({
            'type': 'AMBIGU√èT√â INTENTIONNELLE',
            'description': 'Plusieurs interpr√©tations possibles du m√™me input',
            'exemple': 'Grille peut √™tre lue comme lignes ou colonnes',
            'difficulte': 'üü° √âLEV√âE',
            'strategie_detection': 'G√©n√©rer multiples hypoth√®ses et scorer'
        })

    # Pattern 4: Bruit intentionnel
    if 'bruit_intentionnel' in tous_patterns:
        patterns_ultra_limites.append({
            'type': 'BRUIT INTENTIONNEL',
            'description': 'Changements al√©atoires ou distracteurs',
            'exemple': '3 pixels changent de couleur al√©atoirement',
            'difficulte': 'üü° √âLEV√âE',
            'strategie_detection': 'Filtrage statistique du bruit'
        })

    # Pattern 5: R√®gles conditionnelles complexes
    if 'regles_conditionnelles_complexes' in tous_patterns:
        patterns_ultra_limites.append({
            'type': 'R√àGLES CONDITIONNELLES COMPLEXES',
            'description': 'R√®gles qui d√©pendent de conditions multiples',
            'exemple': 'SI rouge ET grand ALORS tourner SINON agrandir',
            'difficulte': 'üü† MOYENNE-√âLEV√âE',
            'strategie_detection': 'Arbres de d√©cision apprenants'
        })

    # Afficher les patterns ultra-limites
    print(f"\nüèÜ **PATTERNS ULTRA-LIMITES IDENTIFI√âS:**")
    for i, pattern in enumerate(patterns_ultra_limites, 1):
        print(f"\n{i}. **{pattern['type']}**")
        print(f"   üìù {pattern['description']}")
        print(f"   üîç Exemple: {pattern['exemple']}")
        print(f"   üéØ Difficult√©: {pattern['difficulte']}")
        print(f"   üí° Strat√©gie: {pattern['strategie_detection']}")

    # Propositions d'am√©lioration
    print(f"\nüöÄ **STRAT√âGIES POUR ATTEINDRE LE GOD LEVEL**")
    print("=" * 50)

    strategies = [
        {
            'phase': 'PHASE 5A: Analyse Statistique Avanc√©e',
            'actions': [
                'Impl√©menter analyse de corr√©lation non-lin√©aire',
                'D√©tecter patterns statistiques cach√©s',
                'Analyser distributions de probabilit√©'
            ]
        },
        {
            'phase': 'PHASE 5B: G√©n√©ration d\'Hypoth√®ses',
            'actions': [
                'Cr√©er syst√®me de propositions multiples',
                '√âvaluer plusieurs interpr√©tations possibles',
                'Utiliser scoring par coh√©rence'
            ]
        },
        {
            'phase': 'PHASE 5C: Apprentissage Contextuel',
            'actions': [
                'D√©velopper m√©moire des patterns rares',
                'Apprendre des √©checs pr√©c√©dents',
                'Contextualiser les transformations'
            ]
        },
        {
            'phase': 'PHASE 5D: Intuition Artificielle',
            'actions': [
                'Impl√©menter "sixi√®me sens" algorithmique',
                'D√©tecter patterns au-del√† de la logique pure',
                'Transformer l\'inconnu en connu'
            ]
        }
    ]

    for strategy in strategies:
        print(f"\n**{strategy['phase']}**")
        for action in strategy['actions']:
            print(f"   ‚úÖ {action}")

    # Estimation du potentiel
    print(f"\nüéØ **POTENTIEL D'AM√âLIORATION**")
    print(f"   üéØ T√¢ches ultra-limites identifi√©es: {len(patterns_ultra_limites)}")
    print(f"   üéØ √âchecs restants: {len(echecs_critiques)}")
    print(f"   üéØ Taux de succ√®s potentiel: 99.99%+")

    print(f"\nüèÜ **VISION GOD LEVEL**")
    print(f"   üåü R√©soudre les cas que m√™me les humains trouvent difficiles")
    print(f"   üåü D√©velopper une v√©ritable intuition artificielle")
    print(f"   üåü Atteindre le niveau d'excellence absolue")

    return {
        'echecs_critiques': echecs_critiques,
        'analyses_detaillees': analyses_detaillees,
        'patterns_ultra_limites': patterns_ultra_limites,
        'strategies_amelioration': strategies
    }

def analyser_exemples_tache(train_data: List[Dict]) -> Dict[str, Any]:
    """Analyse d√©taill√©e des exemples d'une t√¢che"""

    analyse = {
        'transformations_detectees': [],
        'patterns_spatiaux': [],
        'patterns_couleur': [],
        'complexite_estimee': 0,
        'caracteristiques_atypiques': []
    }

    for i, exemple in enumerate(train_data):
        input_grid = np.array(exemple['input'])
        output_grid = np.array(exemple['output'])

        h1, w1 = input_grid.shape
        h2, w2 = output_grid.shape

        # 1. Analyser les dimensions
        if h2 > h1 or w2 > w1:
            analyse['transformations_detectees'].append('agrandissement')
            analyse['patterns_spatiaux'].append('expansion_spatiale')
        elif h2 < h1 or w2 < w1:
            analyse['transformations_detectees'].append('reduction')
            analyse['patterns_spatiaux'].append('compression_spatiale')
        else:
            analyse['transformations_detectees'].append('meme_taille')

        # 2. Analyser les valeurs
        valeurs_in = set(input_grid.flatten())
        valeurs_out = set(output_grid.flatten())

        if valeurs_out != valeurs_in:
            analyse['transformations_detectees'].append('changement_valeurs')
            analyse['patterns_couleur'].append('mapping_couleur')

        # 3. D√©tecter patterns atypiques
        if h1 == 1 and w1 == 1:
            analyse['caracteristiques_atypiques'].append('input_degenere')

        if h2 == 1 and w2 == 1:
            analyse['caracteristiques_atypiques'].append('output_degenere')

        if len(valeurs_in) > 10:
            analyse['caracteristiques_atypiques'].append('beaucoup_valeurs')

        # 4. Analyser la complexit√©
        ratio_changement = np.sum(input_grid != output_grid) / input_grid.size if h1 == h2 and w1 == w2 else 1.0
        if ratio_changement > 0.8:
            analyse['complexite_estimee'] += 2

        if len(valeurs_out - valeurs_in) > 3:
            analyse['complexite_estimee'] += 1

    # Synth√®se finale
    analyse['transformations_detectees'] = list(set(analyse['transformations_detectees']))
    analyse['patterns_spatiaux'] = list(set(analyse['patterns_spatiaux']))
    analyse['patterns_couleur'] = list(set(analyse['patterns_couleur']))

    # D√©tecter patterns ultra-limites
    if len(analyse['caracteristiques_atypiques']) > 0:
        analyse['transformations_detectees'].append('pattern_atypique')

    if analyse['complexite_estimee'] > 5:
        analyse['transformations_detectees'].append('transformation_non_lineaire')

    # Estimation finale de la complexit√©
    analyse['complexite_estimee'] = min(10, analyse['complexite_estimee'])

    return analyse

def main():
    """Fonction principale"""
    resultats = analyser_cas_ultra_limites()

    print(f"\nüéØ **R√âSUM√â ANALYSE ULTRA-LIMITES**")
    print(f"   üîç √âchecs critiques analys√©s: {len(resultats['echecs_critiques'])}")
    print(f"   üéØ Patterns ultra-limites identifi√©s: {len(resultats['patterns_ultra_limites'])}")
    print(f"   üöÄ Strat√©gies d'am√©lioration: {len(resultats['strategies_amelioration'])}")
    print(f"   üåü Pr√™t pour Phase 5: God Level Achievement")

if __name__ == "__main__":
    main()
