#!/usr/bin/env python3
"""
üîç ANALYSE APPROFONDIE DES 58 T√ÇCHES MANQUANTES
Phase 6+ : Diagnostic complet du probl√®me persistant
"""

import os
import json
import traceback
from pathlib import Path
from bibliotheque.developpement.arc_agi_refuge.src.refuge_solver import RefugeARCSolver, TacheARC

def analyser_toutes_les_taches():
    """Analyse compl√®te de toutes les t√¢ches disponibles vs trait√©es"""

    print("üîç ANALYSE COMPL√àTE DES T√ÇCHES")
    print("=" * 80)

    # 1. Identifier toutes les t√¢ches disponibles
    data_dir = Path('data/training')
    taches_totales = []

    if data_dir.exists():
        for fichier in sorted(data_dir.glob('*.json')):
            tache_id = fichier.stem
            taches_totales.append(tache_id)

        print(f"üìä Total de t√¢ches disponibles: {len(taches_totales)}")
        print(f"üìÑ Exemples: {taches_totales[:5]}")
    else:
        print("‚ùå Dossier data/training non trouv√©")
        return

    # 2. Identifier les t√¢ches trait√©es dans les r√©sultats
    taches_traitees = []

    # Chercher dans tous les fichiers de r√©sultats
    fichiers_resultats = [f for f in os.listdir('.') if 'resultats' in f and f.endswith('.json')]

    for fichier in fichiers_resultats:
        try:
            with open(fichier, 'r', encoding='utf-8') as f:
                data = json.load(f)

            # Explorer diff√©rentes structures possibles
            if isinstance(data, dict):
                # Chercher r√©cursivement tous les IDs de t√¢ches
                def extraire_tache_ids(obj, ids_collectes):
                    if isinstance(obj, dict):
                        for key, value in obj.items():
                            if isinstance(key, str) and len(key) == 8 and key.isalnum():
                                ids_collectes.add(key)
                            elif isinstance(value, str) and len(value) == 8 and value.isalnum():
                                ids_collectes.add(value)
                            else:
                                extraire_tache_ids(value, ids_collectes)
                    elif isinstance(obj, list):
                        for item in obj:
                            extraire_tache_ids(item, ids_collectes)

                ids_trouves = set()
                extraire_tache_ids(data, ids_trouves)
                taches_traitees.extend(ids_trouves)

        except Exception as e:
            print(f"‚ö†Ô∏è Erreur lecture {fichier}: {e}")

    taches_traitees = list(set(taches_traitees))  # √âliminer les doublons

    print(f"‚úÖ T√¢ches trait√©es trouv√©es: {len(taches_traitees)}")
    print(f"üìÑ Exemples: {taches_traitees[:5]}")

    # 3. Identifier les t√¢ches manquantes
    taches_manquantes = [t for t in taches_totales if t not in taches_traitees]

    print(f"\nüîç R√âSULTATS:")
    print(f"   üìä T√¢ches totales: {len(taches_totales)}")
    print(f"   ‚úÖ T√¢ches trait√©es: {len(taches_traitees)}")
    print(f"   ‚ùå T√¢ches manquantes: {len(taches_manquantes)}")
    print(f"   üìà Couverture: {len(taches_traitees)/len(taches_totales)*100:.1f}%")

    if taches_manquantes:
        print(f"\nüìã LISTE DES {len(taches_manquantes)} T√ÇCHES MANQUANTES:")
        for i, tache_id in enumerate(taches_manquantes, 1):
            print(f"   {i:2d}. {tache_id}")

        # Sauvegarder la liste compl√®te
        with open('taches_manquantes_final.json', 'w', encoding='utf-8') as f:
            json.dump({
                'total_taches': len(taches_totales),
                'taches_traitees': len(taches_traitees),
                'taches_manquantes': taches_manquantes,
                'pourcentage_couverture': len(taches_traitees)/len(taches_totales)*100
            }, f, indent=2, ensure_ascii=False)

        print(f"\nüíæ Liste sauvegard√©e dans: taches_manquantes_final.json")

        # 4. Analyser quelques t√¢ches manquantes en d√©tail
        analyser_taches_manquantes_detail(taches_manquantes[:10])

        return taches_manquantes
    else:
        print("üéâ Aucune t√¢che manquante trouv√©e!")
        return []

def analyser_taches_manquantes_detail(taches_a_analyser):
    """Analyse d√©taill√©e de quelques t√¢ches manquantes"""

    print(f"\nüî¨ ANALYSE D√âTAILL√âE DES T√ÇCHES MANQUANTES")
    print("=" * 60)

    data_dir = Path('data/training')

    for tache_id in taches_a_analyser:
        fichier_tache = data_dir / f"{tache_id}.json"

        if fichier_tache.exists():
            try:
                with open(fichier_tache, 'r') as f:
                    tache_data = json.load(f)

                print(f"\nüìÑ T√¢che {tache_id}:")

                # Analyse de base
                nb_train = len(tache_data.get('train', []))
                nb_test = len(tache_data.get('test', []))
                print(f"   üìä {nb_train} exemples d'entra√Ænement, {nb_test} tests")

                # Analyse des dimensions
                if nb_train > 0:
                    exemple = tache_data['train'][0]
                    input_grid = exemple.get('input', [])
                    output_grid = exemple.get('output', [])

                    if input_grid and output_grid:
                        h_in, w_in = len(input_grid), len(input_grid[0]) if input_grid else (0, 0)
                        h_out, w_out = len(output_grid), len(output_grid[0]) if output_grid else (0, 0)

                        print(f"   üìê Input: {h_in}x{w_in}, Output: {h_out}x{w_out}")

                        # Analyse des valeurs
                        valeurs_input = [val for row in input_grid for val in row]
                        valeurs_output = [val for row in output_grid for val in row]

                        val_min_in = min(valeurs_input) if valeurs_input else 0
                        val_max_in = max(valeurs_input) if valeurs_input else 0
                        val_min_out = min(valeurs_output) if valeurs_output else 0
                        val_max_out = max(valeurs_output) if valeurs_output else 0

                        print(f"   üéØ Input values: [{val_min_in}, {val_max_in}]")
                        print(f"   üéØ Output values: [{val_min_out}, {val_max_out}]")

                        # Test de chargement avec notre syst√®me
                        try:
                            tache = TacheARC(
                                tache_id=tache_id,
                                train=tache_data.get('train', []),
                                test=tache_data.get('test', [])
                            )
                            print(f"   ‚úÖ Chargement TacheARC: OK")

                            # Test avec le solver
                            solver = RefugeARCSolver()
                            synthese = solver.resoudre_tache(tache)
                            print(f"   ‚úÖ R√©solution: OK - Confiance: {synthese.get('confiance_finale', 0):.2f}")

                        except Exception as e:
                            print(f"   ‚ùå Erreur syst√®me: {str(e)[:100]}...")

            except Exception as e:
                print(f"üìÑ T√¢che {tache_id}: ‚ùå Erreur analyse - {str(e)[:80]}...")

def tester_batch_manquantes(taches_manquantes):
    """Test un batch des t√¢ches manquantes"""

    print(f"\nüß™ TEST BATCH DES T√ÇCHES MANQUANTES")
    print("=" * 60)

    if not taches_manquantes:
        print("Aucune t√¢che manquante √† tester")
        return

    solver = RefugeARCSolver()
    data_dir = Path('data/training')

    succes = 0
    total = min(20, len(taches_manquantes))  # Tester max 20 t√¢ches

    print(f"Test des {total} premi√®res t√¢ches manquantes:")

    for i, tache_id in enumerate(taches_manquantes[:total], 1):
        fichier_tache = data_dir / f"{tache_id}.json"

        if fichier_tache.exists():
            try:
                with open(fichier_tache, 'r') as f:
                    tache_data = json.load(f)

                # Cr√©er et r√©soudre la t√¢che
                tache = TacheARC(
                    tache_id=tache_id,
                    train=tache_data.get('train', []),
                    test=tache_data.get('test', [])
                )

                synthese = solver.resoudre_tache(tache)
                confiance = synthese.get('confiance_finale', 0)
                reussi = synthese.get('succes', False)

                status = "‚úÖ" if reussi else "‚ùå"
                print(f"   {i:2d}. {tache_id}: {status} ({confiance:.2f})")

                if reussi:
                    succes += 1

            except Exception as e:
                print(f"   {i:2d}. {tache_id}: üí• ERREUR - {str(e)[:50]}...")

    print(f"\nüìä R√âSULTATS TEST BATCH:")
    print(f"   üéØ Test√©es: {total}")
    print(f"   ‚úÖ Succ√®s: {succes}")
    print(f"   üìà Taux de succ√®s: {succes/total*100:.1f}%")

def main():
    """Fonction principale"""

    print("üîç DIAGNOSTIC COMPL√àT DES 58 T√ÇCHES MANQUANTES")
    print("üåü Laurent & Sonic: R√©solution du myst√®re persistant")
    print("=" * 80)

    # 1. Analyse compl√®te
    taches_manquantes = analyser_toutes_les_taches()

    # 2. Test batch si des t√¢ches manquantes
    if taches_manquantes:
        tester_batch_manquantes(taches_manquantes)

    # 3. Diagnostic final
    print(f"\nüî¨ DIAGNOSTIC FINAL:")
    print(f"=" * 60)

    if len(taches_manquantes) > 0:
        print(f"‚ùå PROBL√àME CONFIRM√â:")
        print(f"   ‚Ä¢ {len(taches_manquantes)} t√¢ches ne sont pas trait√©es")
        print(f"   ‚Ä¢ Ces t√¢ches existent dans data/training/")
        print(f"   ‚Ä¢ Elles ne sont pas dans les fichiers de r√©sultats")
        print(f"   ‚Ä¢ Le syst√®me semble les ignorer compl√®tement")

        print(f"\nüîß HYPOTH√àSES POSSIBLES:")
        print(f"   1. Erreur dans la boucle de traitement (index, exception silencieuse)")
        print(f"   2. Probl√®me de format de donn√©es")
        print(f"   3. Erreur de parsing des fichiers JSON")
        print(f"   4. Exception non g√©r√©e qui interrompt le traitement")
        print(f"   5. Limitation de m√©moire ou timeout")

        print(f"\nüéØ PROCHAINES √âTAPES:")
        print(f"   1. Analyser le code de traitement_complet_1000_taches.py")
        print(f"   2. Ajouter des logs d√©taill√©s pour identifier o√π √ßa bloque")
        print(f"   3. Tester individuellement les t√¢ches manquantes")
        print(f"   4. V√©rifier les exceptions et erreurs cach√©es")

    else:
        print(f"üéâ AUCUN PROBL√àME D√âTECT√â!")
        print(f"   ‚Ä¢ Toutes les t√¢ches sont trait√©es")
        print(f"   ‚Ä¢ Le syst√®me fonctionne correctement")

    print(f"\nüåü R√âSOLUTION EN COURS...")
    print(f"üîÆ Nous trouverons la source du myst√®re!")

if __name__ == "__main__":
    main()
