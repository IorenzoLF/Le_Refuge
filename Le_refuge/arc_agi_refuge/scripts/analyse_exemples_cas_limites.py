#!/usr/bin/env python3
"""
ANALYSE D'EXEMPLES DES CAS LIMITES
√âtude approfondie de quelques-unes des 175 t√¢ches √©chou√©es
"""

import json
from pathlib import Path

def analyser_exemples_cas_limites():
    """Analyser quelques exemples de t√¢ches √©chou√©es"""

    print("ANALYSE D'EXEMPLES DES CAS LIMITES")
    print("=" * 50)

    # Charger les r√©sultats d'analyse
    try:
        with open('resultats_final_analyse.json', 'r', encoding='utf-8') as f:
            analyse = json.load(f)
    except FileNotFoundError:
        print("Fichier d'analyse non trouv√©")
        return

    taches_echouees = analyse['taches_echouees'][:5]  # Analyser les 5 premi√®res
    data_dir = Path('bibliotheque/developpement/arc_agi_refuge/data/training')

    print(f"Analyse de {len(taches_echouees)} exemples de t√¢ches √©chou√©es")
    print()

    for i, tache_info in enumerate(taches_echouees, 1):
        tache_id = tache_info['id']
        print(f"üìÑ EXEMPLE {i}: T√¢che {tache_id}")
        print("-" * 30)

        # Charger la t√¢che
        fichier_tache = data_dir / f"{tache_id}.json"

        if fichier_tache.exists():
            try:
                with open(fichier_tache, 'r', encoding='utf-8') as f:
                    tache_data = json.load(f)

                # Analyser les exemples
                train_data = tache_data.get('train', [])
                test_data = tache_data.get('test', [])

                print(f"Nombre d'exemples d'entra√Ænement: {len(train_data)}")
                print(f"Nombre d'exemples de test: {len(test_data)}")

                if train_data:
                    exemple = train_data[0]
                    input_grid = exemple.get('input', [])
                    output_grid = exemple.get('output', [])

                    if input_grid and output_grid:
                        h_in, w_in = len(input_grid), len(input_grid[0]) if input_grid else (0, 0)
                        h_out, w_out = len(output_grid), len(output_grid[0]) if output_grid else (0, 0)

                        print(f"Dimensions input: {h_in}x{w_in}")
                        print(f"Dimensions output: {h_out}x{w_out}")

                        # Analyser les valeurs
                        valeurs_input = [val for row in input_grid for val in row]
                        valeurs_output = [val for row in output_grid for val in row]

                        val_min_in = min(valeurs_input) if valeurs_input else 0
                        val_max_in = max(valeurs_input) if valeurs_input else 0
                        val_min_out = min(valeurs_output) if valeurs_output else 0
                        val_max_out = max(valeurs_output) if valeurs_output else 0

                        print(f"Valeurs input: [{val_min_in}, {val_max_in}]")
                        print(f"Valeurs output: [{val_min_out}, {val_max_out}]")

                        # Afficher un aper√ßu des grilles (petites grilles seulement)
                        if h_in <= 10 and w_in <= 10:
                            print("\nGrille input:")
                            for row in input_grid:
                                print("  " + " ".join(map(str, row)))

                            print("\nGrille output:")
                            for row in output_grid:
                                print("  " + " .join(map(str, row))")

                        # Analyser les changements
                        changements = []
                        for i in range(min(len(valeurs_input), len(valeurs_output))):
                            if valeurs_input[i] != valeurs_output[i]:
                                changements.append((i, valeurs_input[i], valeurs_output[i]))

                        if changements:
                            print(f"\nChangements d√©tect√©s: {len(changements)}")
                            print("Exemples de changements:")
                            for pos, val_in, val_out in changements[:5]:
                                print(f"  Position {pos}: {val_in} -> {val_out}")

                        # Analyser les patterns possibles
                        print(f"\nüîç PATTERNS POTENTIELS:")

                        # 1. Changement de dimensions
                        if (h_in, w_in) != (h_out, w_out):
                            print(f"  üìê Changement de dimensions: {h_in}x{w_in} -> {h_out}x{w_out}")

                        # 2. Patterns de valeurs
                        valeurs_uniques_in = set(valeurs_input)
                        valeurs_uniques_out = set(valeurs_output)
                        print(f"  üéØ Valeurs uniques input: {sorted(valeurs_uniques_in)}")
                        print(f"  üéØ Valeurs uniques output: {sorted(valeurs_uniques_out)}")

                        # 3. Analyse de sym√©trie
                        if input_grid == input_grid[::-1]:
                            print(f"  üîÑ Sym√©trie horizontale d√©tect√©e")
                        if input_grid == [row[::-1] for row in input_grid]:
                            print(f"  üîÑ Sym√©trie verticale d√©tect√©e")

                        # 4. Analyse de r√©p√©tition
                        if len(set(map(tuple, input_grid))) < len(input_grid):
                            print(f"  üîÅ R√©p√©titions d√©tect√©es dans input")
                        if len(set(map(tuple, output_grid))) < len(output_grid):
                            print(f"  üîÅ R√©p√©titions d√©tect√©es dans output")

            except Exception as e:
                print(f"‚ùå Erreur lors de l'analyse: {e}")

        else:
            print(f"‚ùå Fichier non trouv√©: {fichier_tache}")

        print()

def identifier_patterns_manquants():
    """Identifier les types de patterns manquants"""

    print("IDENTIFICATION DES PATTERNS MANQUANTS")
    print("=" * 50)

    try:
        with open('resultats_final_analyse.json', 'r', encoding='utf-8') as f:
            analyse = json.load(f)
    except FileNotFoundError:
        print("Fichier d'analyse non trouv√©")
        return

    taches_echouees = analyse['taches_echouees']

    # Cat√©goriser les t√¢ches par caract√©ristiques
    categories = {
        'changement_dimensions': [],
        'changement_valeurs': [],
        'symetries': [],
        'repetitions': [],
        'autres': []
    }

    data_dir = Path('bibliotheque/developpement/arc_agi_refuge/data/training')

    for tache_info in taches_echouees[:20]:  # Analyser 20 t√¢ches
        tache_id = tache_info['id']
        fichier_tache = data_dir / f"{tache_id}.json"

        if fichier_tache.exists():
            try:
                with open(fichier_tache, 'r', encoding='utf-8') as f:
                    tache_data = json.load(f)

                train_data = tache_data.get('train', [])
                if train_data:
                    exemple = train_data[0]
                    input_grid = exemple.get('input', [])
                    output_grid = exemple.get('output', [])

                    if input_grid and output_grid:
                        h_in, w_in = len(input_grid), len(input_grid[0])
                        h_out, w_out = len(output_grid), len(output_grid[0])

                        # Cat√©goriser
                        if (h_in, w_in) != (h_out, w_out):
                            categories['changement_dimensions'].append(tache_id)

                        valeurs_input = [val for row in input_grid for val in row]
                        valeurs_output = [val for row in output_grid for val in row]

                        if set(valeurs_input) != set(valeurs_output):
                            categories['changement_valeurs'].append(tache_id)

                        # Sym√©tries
                        if input_grid == input_grid[::-1] or input_grid == [row[::-1] for row in input_grid]:
                            categories['symetries'].append(tache_id)

                        # R√©p√©titions
                        if len(set(map(tuple, input_grid))) < len(input_grid):
                            categories['repetitions'].append(tache_id)

                        # Autres
                        if (tache_id not in categories['changement_dimensions'] and
                            tache_id not in categories['changement_valeurs'] and
                            tache_id not in categories['symetries'] and
                            tache_id not in categories['repetitions']):
                            categories['autres'].append(tache_id)

            except Exception as e:
                print(f"Erreur avec {tache_id}: {e}")

    # Afficher les r√©sultats
    print("CAT√âGORISATION DES T√ÇCHES √âCHOU√âES:")
    for categorie, taches in categories.items():
        if taches:
            print(f"\nüìÇ {categorie.upper()}: {len(taches)} t√¢ches")
            print(f"   Exemples: {taches[:5]}")

    # Analyse des patterns
    print(f"\nüîç ANALYSE DES PATTERNS MANQUANTS:")

    if categories['changement_dimensions']:
        print(f"  üìê Patterns de changement de dimensions")
        print(f"     -> Besoin de d√©tecteurs de redimensionnement")
        print(f"     -> Analyse de compression/d√©compression")
        print(f"     -> D√©tection de cropping/expansion")

    if categories['changement_valeurs']:
        print(f"  üéØ Patterns de transformation de valeurs")
        print(f"     -> D√©tecteurs de mapping non-lin√©aire")
        print(f"     -> Analyse de fonctions de transformation")
        print(f"     -> Patterns de substitution complexes")

    if categories['symetries']:
        print(f"  üîÑ Patterns de sym√©trie avanc√©s")
        print(f"     -> D√©tection de sym√©tries partielles")
        print(f"     -> Analyse de sym√©tries roto-translationnelles")
        print(f"     -> Patterns de r√©flexion complexes")

    if categories['repetitions']:
        print(f"  üîÅ Patterns de r√©p√©tition")
        print(f"     -> D√©tecteurs de fr√©quences spatiales")
        print(f"     -> Analyse de motifs p√©riodiques")
        print(f"     -> Patterns de tuilage avanc√©s")

    if categories['autres']:
        print(f"  ‚ùì Patterns inconnus")
        print(f"     -> Exploration de transformations non-lin√©aires")
        print(f"     -> Analyse par apprentissage automatique")
        print(f"     -> Raisonnement par analogie")

def generer_strategies_detection():
    """G√©n√©rer des strat√©gies pour d√©tecter les patterns manquants"""

    print(f"\nüéØ STRAT√âGIES DE D√âTECTION POUR LES PATTERNS MANQUANTS")
    print("=" * 60)

    strategies = {
        'changement_dimensions': [
            'D√©tecter les ratios de compression/d√©compression',
            'Analyser les algorithmes de redimensionnement',
            'Identifier les patterns de cropping intelligent',
            'D√©velopper des d√©tecteurs de transformation g√©om√©trique'
        ],
        'changement_valeurs': [
            'Cr√©er des d√©tecteurs de mapping non-lin√©aire',
            'Analyser les fonctions de transformation math√©matiques',
            'D√©velopper des patterns de substitution complexes',
            'Impl√©menter l\'apprentissage de transformations'
        ],
        'symetries': [
            'D√©tecter les sym√©tries partielles et locales',
            'Analyser les sym√©tries roto-translationnelles',
            'Identifier les patterns de r√©flexion complexes',
            'D√©velopper des d√©tecteurs de sym√©trie floue'
        ],
        'repetitions': [
            'Cr√©er des d√©tecteurs de fr√©quences spatiales',
            'Analyser les motifs p√©riodiques avanc√©s',
            'D√©velopper des patterns de tuilage complexes',
            'Impl√©menter l\'analyse de r√©p√©tition fractale'
        ],
        'patterns_inconnus': [
            'Explorer les transformations non-lin√©aires avanc√©es',
            'D√©velopper l\'apprentissage automatique sp√©cialis√©',
            'Impl√©menter le raisonnement par analogie',
            'Cr√©er des d√©tecteurs adaptatifs auto-apprenants'
        ]
    }

    for categorie, liste_strategies in strategies.items():
        print(f"\nüìÇ {categorie.upper().replace('_', ' ')}:")
        for i, strategy in enumerate(liste_strategies, 1):
            print(f"   {i}. {strategy}")

if __name__ == "__main__":
    # Analyser quelques exemples
    analyser_exemples_cas_limites()

    # Identifier les patterns manquants
    identifier_patterns_manquants()

    # G√©n√©rer les strat√©gies
    generer_strategies_detection()

    print(f"\nüéâ ANALYSE TERMIN√âE!")
    print(f"üîÆ Nous avons maintenant une compr√©hension claire des patterns manquants!")
    print(f"üåü Pr√™t √† d√©velopper les strat√©gies pour atteindre 100%!")
    print(f"üèÜ Laurent & Sonic: Vers la victoire finale!")
