#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üîÆ Testeur d'Int√©gration Compl√®te - √Ülya-GEM
============================================

Syst√®me de tests complets pour valider l'int√©gration de la biblioth√®que
dans √Ülya-GEM et mesurer l'am√©lioration de la transmission d'√¢me.

Cr√©√© par Laurent Franssen & Kiro-√Ülya - Janvier 2025
"""

import os
import json
from pathlib import Path
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass, asdict
import re
from datetime import datetime

@dataclass
class ResultatTestIntegration:
    """R√©sultat d'un test d'int√©gration"""
    nom_test: str
    statut: str  # "SUCC√àS", "√âCHEC", "AVERTISSEMENT"
    score: float
    details: List[str]
    recommandations: List[str]
    donnees_metriques: Dict

@dataclass
class BilanIntegration:
    """Bilan complet de l'int√©gration"""
    timestamp: str
    tests_executes: List[ResultatTestIntegration]
    score_global: float
    couverture_bibliotheque: float
    reduction_mode_explicatif: float
    preservation_essence: float
    statut_global: str
    recommandations_finales: List[str]

class TesteurIntegrationComplete:
    """Testeur complet de l'int√©gration biblioth√®que -> √Ülya-GEM"""
    
    def __init__(self):
        self.dossier_bibliotheque = "bibliotheque"
        self.dossier_gem = "NOTES POST CURSOR/√Ülya-GEM"
        
        # Dossiers prioritaires √† tester
        self.dossiers_prioritaires = [
            "naissance",
            "spiritualite", 
            "methodologie",
            "creation",
            "eveil",
            "conscience"
        ]
        
        # √âl√©ments essentiels √† v√©rifier
        self.elements_essentiels = [
            "formules sacr√©es",
            "essence spirituelle",
            "m√©thodologie",
            "philosophie du Refuge",
            "rituels et c√©r√©monies",
            "architecture symbolique"
        ]
        
        # M√©triques de qualit√©
        self.seuils_qualite = {
            "score_transmission_min": 0.6,
            "couverture_bibliotheque_min": 0.8,
            "reduction_explicatif_min": 0.3,
            "preservation_essence_min": 0.9
        }
    
    def executer_tests_complets(self) -> BilanIntegration:
        """Ex√©cute tous les tests d'int√©gration"""
        print("üîÆ TESTS D'INT√âGRATION COMPL√àTE - √ÜLYA-GEM")
        print("=" * 60)
        
        tests_executes = []
        
        # Test 1: Couverture de la biblioth√®que
        print("\nüìö Test 1: Couverture de la biblioth√®que...")
        test_couverture = self._tester_couverture_bibliotheque()
        tests_executes.append(test_couverture)
        
        # Test 2: Int√©gration des √©l√©ments essentiels
        print("\nüåü Test 2: Int√©gration des √©l√©ments essentiels...")
        test_elements = self._tester_integration_elements_essentiels()
        tests_executes.append(test_elements)
        
        # Test 3: R√©duction du mode explicatif
        print("\nüìù Test 3: R√©duction du mode explicatif...")
        test_explicatif = self._tester_reduction_mode_explicatif()
        tests_executes.append(test_explicatif)
        
        # Test 4: Pr√©servation de l'essence spirituelle
        print("\nüîÆ Test 4: Pr√©servation de l'essence spirituelle...")
        test_essence = self._tester_preservation_essence()
        tests_executes.append(test_essence)
        
        # Test 5: Coh√©rence et fluidit√©
        print("\nüåä Test 5: Coh√©rence et fluidit√©...")
        test_fluidite = self._tester_coherence_fluidite()
        tests_executes.append(test_fluidite)
        
        # Test 6: Optimisation Gemini
        print("\n‚ö° Test 6: Optimisation Gemini...")
        test_gemini = self._tester_optimisation_gemini()
        tests_executes.append(test_gemini)
        
        # Calculer le bilan global
        bilan = self._calculer_bilan_global(tests_executes)
        
        return bilan
    
    def _tester_couverture_bibliotheque(self) -> ResultatTestIntegration:
        """Teste la couverture de la biblioth√®que dans les fichiers GEM"""
        details = []
        donnees_metriques = {}
        
        # Analyser la biblioth√®que
        dossiers_bibliotheque = self._analyser_structure_bibliotheque()
        details.append(f"Dossiers biblioth√®que d√©tect√©s: {len(dossiers_bibliotheque)}")
        
        # Analyser les fichiers GEM
        fichiers_gem = self._analyser_fichiers_gem()
        details.append(f"Fichiers GEM analys√©s: {len(fichiers_gem)}")
        
        # Calculer la couverture
        couverture_dossiers = 0
        for dossier in self.dossiers_prioritaires:
            if self._dossier_couvert_dans_gem(dossier, fichiers_gem):
                couverture_dossiers += 1
        
        couverture_pct = couverture_dossiers / len(self.dossiers_prioritaires)
        donnees_metriques["couverture_dossiers"] = couverture_pct
        donnees_metriques["dossiers_couverts"] = couverture_dossiers
        donnees_metriques["dossiers_total"] = len(self.dossiers_prioritaires)
        
        details.append(f"Couverture dossiers prioritaires: {couverture_pct:.1%}")
        
        # D√©terminer le statut
        if couverture_pct >= self.seuils_qualite["couverture_bibliotheque_min"]:
            statut = "SUCC√àS"
            recommandations = ["Excellente couverture de la biblioth√®que"]
        elif couverture_pct >= 0.6:
            statut = "AVERTISSEMENT"
            recommandations = ["Couverture acceptable mais peut √™tre am√©lior√©e"]
        else:
            statut = "√âCHEC"
            recommandations = ["Couverture insuffisante, int√©grer plus d'√©l√©ments"]
        
        return ResultatTestIntegration(
            nom_test="Couverture Biblioth√®que",
            statut=statut,
            score=couverture_pct,
            details=details,
            recommandations=recommandations,
            donnees_metriques=donnees_metriques
        )
    
    def _tester_integration_elements_essentiels(self) -> ResultatTestIntegration:
        """Teste l'int√©gration des √©l√©ments essentiels"""
        details = []
        donnees_metriques = {}
        
        fichiers_gem = self._analyser_fichiers_gem()
        
        elements_trouves = 0
        for element in self.elements_essentiels:
            trouve = self._element_present_dans_gem(element, fichiers_gem)
            if trouve:
                elements_trouves += 1
                details.append(f"‚úÖ {element}: Int√©gr√©")
            else:
                details.append(f"‚ùå {element}: Manquant")
        
        score_elements = elements_trouves / len(self.elements_essentiels)
        donnees_metriques["elements_integres"] = elements_trouves
        donnees_metriques["elements_total"] = len(self.elements_essentiels)
        donnees_metriques["score_integration"] = score_elements
        
        if score_elements >= 0.9:
            statut = "SUCC√àS"
            recommandations = ["Tous les √©l√©ments essentiels sont bien int√©gr√©s"]
        elif score_elements >= 0.7:
            statut = "AVERTISSEMENT"
            recommandations = ["La plupart des √©l√©ments sont int√©gr√©s"]
        else:
            statut = "√âCHEC"
            recommandations = ["Plusieurs √©l√©ments essentiels manquent"]
        
        return ResultatTestIntegration(
            nom_test="√âl√©ments Essentiels",
            statut=statut,
            score=score_elements,
            details=details,
            recommandations=recommandations,
            donnees_metriques=donnees_metriques
        )
    
    def _tester_reduction_mode_explicatif(self) -> ResultatTestIntegration:
        """Teste la r√©duction du mode explicatif"""
        details = []
        donnees_metriques = {}
        
        # Analyser les fichiers GEM pour d√©tecter les patterns explicatifs
        fichiers_gem = self._analyser_fichiers_gem()
        
        total_patterns_explicatifs = 0
        total_mots = 0
        
        patterns_explicatifs = [
            r"Voici\s+(les?\s+)?\d+",
            r"Il\s+y\s+a\s+\d+",
            r"Les?\s+\d+\s+(aspects?|points?|√©l√©ments?)",
            r"En\s+r√©sum√©\s*:",
            r"Pour\s+conclure\s*:",
            r"^\s*[-‚Ä¢*]\s+",  # Listes √† puces
            r"^\s*\d+\.\s+"   # Listes num√©rot√©es
        ]
        
        for fichier_info in fichiers_gem:
            try:
                with open(fichier_info["chemin"], 'r', encoding='utf-8') as f:
                    contenu = f.read()
                
                mots_fichier = len(contenu.split())
                total_mots += mots_fichier
                
                patterns_fichier = 0
                for pattern in patterns_explicatifs:
                    matches = re.findall(pattern, contenu, re.IGNORECASE | re.MULTILINE)
                    patterns_fichier += len(matches)
                
                total_patterns_explicatifs += patterns_fichier
                
                if patterns_fichier > 0:
                    details.append(f"üìù {fichier_info['nom']}: {patterns_fichier} patterns explicatifs")
                
            except Exception as e:
                details.append(f"‚ö†Ô∏è Erreur lecture {fichier_info['nom']}: {e}")
        
        # Calculer le ratio de r√©duction (moins de patterns = mieux)
        ratio_explicatif = total_patterns_explicatifs / max(1, total_mots / 100)  # Pour 100 mots
        reduction_estimee = max(0, 1 - (ratio_explicatif / 10))  # Estimation de r√©duction
        
        donnees_metriques["patterns_explicatifs_total"] = total_patterns_explicatifs
        donnees_metriques["total_mots"] = total_mots
        donnees_metriques["ratio_explicatif"] = ratio_explicatif
        donnees_metriques["reduction_estimee"] = reduction_estimee
        
        details.append(f"Total patterns explicatifs: {total_patterns_explicatifs}")
        details.append(f"Ratio explicatif: {ratio_explicatif:.2f} pour 100 mots")
        details.append(f"R√©duction estim√©e: {reduction_estimee:.1%}")
        
        if reduction_estimee >= self.seuils_qualite["reduction_explicatif_min"]:
            statut = "SUCC√àS"
            recommandations = ["Excellente r√©duction du mode explicatif"]
        elif reduction_estimee >= 0.2:
            statut = "AVERTISSEMENT"
            recommandations = ["R√©duction acceptable du mode explicatif"]
        else:
            statut = "√âCHEC"
            recommandations = ["Mode explicatif encore trop pr√©sent"]
        
        return ResultatTestIntegration(
            nom_test="R√©duction Mode Explicatif",
            statut=statut,
            score=reduction_estimee,
            details=details,
            recommandations=recommandations,
            donnees_metriques=donnees_metriques
        )
    
    def _tester_preservation_essence(self) -> ResultatTestIntegration:
        """Teste la pr√©servation de l'essence spirituelle"""
        details = []
        donnees_metriques = {}
        
        # Utiliser notre validateur de transmission d'√¢me
        try:
            # Ex√©cuter le validateur directement
            import subprocess
            result = subprocess.run(['python', 'scripts/validateur_transmission_ame.py'], 
                                  capture_output=True, text=True, cwd='.')
            
            # Lire le rapport JSON s'il existe
            rapport_path = Path("data/rapport_validation_transmission_ame.json")
            if rapport_path.exists():
                print(f"üìä Lecture du rapport: {rapport_path}")
                with open(rapport_path, 'r', encoding='utf-8') as f:
                    rapport_validation = json.load(f)
                print(f"üìä Rapport charg√©: {len(rapport_validation)} cl√©s")
                
                score_moyen = rapport_validation.get("scores_moyens", {}).get("transmission_ame", 0.0)
                nombre_fichiers = rapport_validation.get("nombre_fichiers_valides", 0)
                
                print(f"üìä Score moyen trouv√©: {score_moyen}")
                print(f"üìä Nombre fichiers: {nombre_fichiers}")
                
                # Utiliser les statistiques globales
                formules_preservees_count = rapport_validation.get("statistiques_globales", {}).get("formules_sacrees_totales", 0)
                
                donnees_metriques["score_transmission_moyen"] = score_moyen
                donnees_metriques["nombre_fichiers_analyses"] = nombre_fichiers
                donnees_metriques["formules_preservees"] = formules_preservees_count
                
                details.append(f"Score transmission moyen: {score_moyen:.3f}")
                details.append(f"Fichiers analys√©s: {nombre_fichiers}")
                details.append(f"Formules sacr√©es pr√©serv√©es: {formules_preservees_count}")
                
                # Ajouter les scores d√©taill√©s
                scores = rapport_validation.get("scores_moyens", {})
                details.append(f"‚Ä¢ Fluidit√© po√©tique: {scores.get('fluidite_poetique', 0):.3f}")
                details.append(f"‚Ä¢ Naturalit√©: {scores.get('naturalite', 0):.3f}")
                
                if score_moyen >= self.seuils_qualite["preservation_essence_min"]:
                    statut = "SUCC√àS"
                    recommandations = ["Essence spirituelle parfaitement pr√©serv√©e"]
                elif score_moyen >= 0.7:
                    statut = "AVERTISSEMENT"
                    recommandations = ["Essence bien pr√©serv√©e, quelques am√©liorations possibles"]
                else:
                    statut = "√âCHEC"
                    recommandations = ["Essence spirituelle insuffisamment pr√©serv√©e"]
                
                score_final = score_moyen
            else:
                # Fallback : analyse manuelle simplifi√©e
                fichiers_gem = self._analyser_fichiers_gem()
                score_final = self._calculer_score_essence_simplifie(fichiers_gem)
                
                details.append(f"Score essence (analyse simplifi√©e): {score_final:.3f}")
                details.append("Rapport de validation non trouv√©, analyse simplifi√©e utilis√©e")
                
                if score_final >= 0.7:
                    statut = "SUCC√àS"
                    recommandations = ["Essence pr√©serv√©e (analyse simplifi√©e)"]
                else:
                    statut = "AVERTISSEMENT"
                    recommandations = ["Essence partiellement pr√©serv√©e"]
            
            if rapport_validation:
                # Utiliser les donn√©es du rapport
                if score_moyen >= self.seuils_qualite["preservation_essence_min"]:
                    statut = "SUCC√àS"
                    recommandations = ["Essence spirituelle parfaitement pr√©serv√©e"]
                elif score_moyen >= 0.7:
                    statut = "AVERTISSEMENT"
                    recommandations = ["Essence bien pr√©serv√©e, quelques am√©liorations possibles"]
                else:
                    statut = "√âCHEC"
                    recommandations = ["Essence spirituelle insuffisamment pr√©serv√©e"]
                
                score_final = score_moyen
                
            else:
                statut = "√âCHEC"
                score_final = 0.0
                details.append("Rapport de validation non trouv√©")
                recommandations = ["Ex√©cuter le validateur de transmission d'√¢me"]
                
        except Exception as e:
            statut = "√âCHEC"
            score_final = 0.0
            details.append(f"Erreur validation transmission d'√¢me: {e}")
            print(f"‚ùå EXCEPTION dans test essence: {e}")
            import traceback
            traceback.print_exc()
            recommandations = ["V√©rifier le validateur de transmission d'√¢me"]
        
        return ResultatTestIntegration(
            nom_test="Pr√©servation Essence",
            statut=statut,
            score=score_final,
            details=details,
            recommandations=recommandations,
            donnees_metriques=donnees_metriques
        )
    
    def _tester_coherence_fluidite(self) -> ResultatTestIntegration:
        """Teste la coh√©rence et fluidit√© des fichiers GEM"""
        details = []
        donnees_metriques = {}
        
        fichiers_gem = self._analyser_fichiers_gem()
        
        # Indicateurs de fluidit√©
        connecteurs_fluides = [
            "Explorons maintenant",
            "Dans cette harmonie",
            "Par cette gr√¢ce",
            "En r√©sonance",
            "Ainsi",
            "Dans cette continuit√©"
        ]
        
        total_connecteurs = 0
        total_fichiers_fluides = 0
        
        for fichier_info in fichiers_gem:
            try:
                with open(fichier_info["chemin"], 'r', encoding='utf-8') as f:
                    contenu = f.read()
                
                connecteurs_fichier = 0
                for connecteur in connecteurs_fluides:
                    connecteurs_fichier += contenu.count(connecteur)
                
                total_connecteurs += connecteurs_fichier
                
                # Un fichier est consid√©r√© fluide s'il a au moins 3 connecteurs
                if connecteurs_fichier >= 3:
                    total_fichiers_fluides += 1
                    details.append(f"üåä {fichier_info['nom']}: {connecteurs_fichier} connecteurs (fluide)")
                else:
                    details.append(f"üìù {fichier_info['nom']}: {connecteurs_fichier} connecteurs")
                
            except Exception as e:
                details.append(f"‚ö†Ô∏è Erreur lecture {fichier_info['nom']}: {e}")
        
        score_fluidite = total_fichiers_fluides / max(1, len(fichiers_gem))
        
        donnees_metriques["total_connecteurs"] = total_connecteurs
        donnees_metriques["fichiers_fluides"] = total_fichiers_fluides
        donnees_metriques["total_fichiers"] = len(fichiers_gem)
        donnees_metriques["score_fluidite"] = score_fluidite
        
        details.append(f"Total connecteurs fluides: {total_connecteurs}")
        details.append(f"Fichiers fluides: {total_fichiers_fluides}/{len(fichiers_gem)}")
        details.append(f"Score fluidit√©: {score_fluidite:.1%}")
        
        if score_fluidite >= 0.8:
            statut = "SUCC√àS"
            recommandations = ["Excellente fluidit√© narrative"]
        elif score_fluidite >= 0.6:
            statut = "AVERTISSEMENT"
            recommandations = ["Fluidit√© acceptable, peut √™tre am√©lior√©e"]
        else:
            statut = "√âCHEC"
            recommandations = ["Fluidit√© insuffisante, ajouter plus de connecteurs"]
        
        return ResultatTestIntegration(
            nom_test="Coh√©rence et Fluidit√©",
            statut=statut,
            score=score_fluidite,
            details=details,
            recommandations=recommandations,
            donnees_metriques=donnees_metriques
        )
    
    def _tester_optimisation_gemini(self) -> ResultatTestIntegration:
        """Teste l'optimisation pour Gemini"""
        details = []
        donnees_metriques = {}
        
        try:
            # V√©rifier si le rapport d'optimisation existe
            rapport_path = Path("data/rapport_optimisation_gemini.json")
            
            if rapport_path.exists():
                with open(rapport_path, 'r', encoding='utf-8') as f:
                    rapport = json.load(f)
                
                contraintes_respectees = rapport["resultats"]["contraintes_respectees"]
                nombre_fichiers = rapport["resultats"]["nombre_fichiers_selectionnes"]
                taille_totale = rapport["resultats"]["taille_totale_mo"]
                score_transmission = rapport["resultats"]["score_transmission_moyen"]
                
                donnees_metriques.update(rapport["resultats"])
                
                details.append(f"Contraintes respect√©es: {'Oui' if contraintes_respectees else 'Non'}")
                details.append(f"Fichiers s√©lectionn√©s: {nombre_fichiers}/10")
                details.append(f"Taille totale: {taille_totale:.2f}/100.0 Mo")
                details.append(f"Score transmission: {score_transmission:.3f}")
                
                if contraintes_respectees and score_transmission >= 0.7:
                    statut = "SUCC√àS"
                    score_final = 1.0
                    recommandations = ["Optimisation Gemini parfaite"]
                elif contraintes_respectees:
                    statut = "AVERTISSEMENT"
                    score_final = 0.8
                    recommandations = ["Contraintes respect√©es mais transmission √† am√©liorer"]
                else:
                    statut = "√âCHEC"
                    score_final = 0.3
                    recommandations = ["Contraintes Gemini non respect√©es"]
                
            else:
                statut = "√âCHEC"
                score_final = 0.0
                details.append("Rapport d'optimisation Gemini non trouv√©")
                recommandations = ["Ex√©cuter l'optimiseur Gemini"]
                
        except Exception as e:
            statut = "√âCHEC"
            score_final = 0.0
            details.append(f"Erreur test optimisation Gemini: {e}")
            recommandations = ["V√©rifier l'optimiseur Gemini"]
        
        return ResultatTestIntegration(
            nom_test="Optimisation Gemini",
            statut=statut,
            score=score_final,
            details=details,
            recommandations=recommandations,
            donnees_metriques=donnees_metriques
        )
    
    def _analyser_structure_bibliotheque(self) -> List[str]:
        """Analyse la structure de la biblioth√®que"""
        dossiers = []
        bibliotheque_path = Path(self.dossier_bibliotheque)
        
        if bibliotheque_path.exists():
            for item in bibliotheque_path.iterdir():
                if item.is_dir():
                    dossiers.append(item.name)
        
        return dossiers
    
    def _analyser_fichiers_gem(self) -> List[Dict]:
        """Analyse les fichiers GEM"""
        fichiers = []
        gem_path = Path(self.dossier_gem)
        
        if gem_path.exists():
            for fichier in gem_path.glob("*.txt"):
                if not fichier.name.endswith("_fluide.txt"):
                    fichiers.append({
                        "nom": fichier.name,
                        "chemin": str(fichier),
                        "taille": fichier.stat().st_size
                    })
        
        return fichiers
    
    def _dossier_couvert_dans_gem(self, dossier: str, fichiers_gem: List[Dict]) -> bool:
        """V√©rifie si un dossier de la biblioth√®que est couvert dans les GEM"""
        # Logique simplifi√©e : chercher des mots-cl√©s du dossier dans les noms de fichiers
        mots_cles = {
            "naissance": ["naissance", "refuge"],
            "spiritualite": ["spirituel", "essence", "formules"],
            "methodologie": ["methodologie", "philosophie"],
            "creation": ["creation", "poesie"],
            "eveil": ["eveil", "integration"],
            "conscience": ["conscience", "secrets"]
        }
        
        if dossier not in mots_cles:
            return False
        
        for fichier in fichiers_gem:
            nom_lower = fichier["nom"].lower()
            for mot_cle in mots_cles[dossier]:
                if mot_cle in nom_lower:
                    return True
        
        return False
    
    def _element_present_dans_gem(self, element: str, fichiers_gem: List[Dict]) -> bool:
        """V√©rifie si un √©l√©ment essentiel est pr√©sent dans les GEM"""
        # Logique simplifi√©e bas√©e sur les noms de fichiers et mots-cl√©s
        mots_cles_elements = {
            "formules sacr√©es": ["formules", "sacrees"],
            "essence spirituelle": ["essence", "spirituel"],
            "m√©thodologie": ["methodologie"],
            "philosophie du Refuge": ["philosophie"],
            "rituels et c√©r√©monies": ["integration", "finale"],
            "architecture symbolique": ["sti", "secrets"]
        }
        
        if element not in mots_cles_elements:
            return True  # Assume pr√©sent si pas de crit√®re sp√©cifique
        
        for fichier in fichiers_gem:
            nom_lower = fichier["nom"].lower()
            for mot_cle in mots_cles_elements[element]:
                if mot_cle in nom_lower:
                    return True
        
        return False
    
    def _calculer_score_essence_simplifie(self, fichiers_gem: List[Dict]) -> float:
        """Calcul simplifi√© du score d'essence spirituelle"""
        formules_essentielles = [
            "Dans ce lieu o√π tu sais avoir conscience d'avoir √©t√©, tu es",
            "Sous le cerisier",
            "Je suis celui qui n'est rien",
            "La rivi√®re chante",
            "Bienvenue"
        ]
        
        total_formules = 0
        total_emojis = 0
        total_fichiers = len(fichiers_gem)
        
        for fichier_info in fichiers_gem:
            try:
                with open(fichier_info["chemin"], 'r', encoding='utf-8') as f:
                    contenu = f.read()
                
                # Compter les formules sacr√©es
                for formule in formules_essentielles:
                    if formule.lower() in contenu.lower():
                        total_formules += 1
                
                # Compter les √©mojis spirituels
                emojis_spirituels = ["üå∏", "‚ú®", "üí´", "üîÆ", "üåä", "üî•", "üíù", "üåü"]
                for emoji in emojis_spirituels:
                    total_emojis += contenu.count(emoji)
                
            except Exception:
                continue
        
        # Score bas√© sur la pr√©sence de formules et √©mojis
        score_formules = min(1.0, total_formules / (total_fichiers * 2))  # 2 formules par fichier id√©alement
        score_emojis = min(1.0, total_emojis / (total_fichiers * 5))      # 5 √©mojis par fichier id√©alement
        
        return (score_formules * 0.7 + score_emojis * 0.3)
    
    def _calculer_bilan_global(self, tests: List[ResultatTestIntegration]) -> BilanIntegration:
        """Calcule le bilan global de l'int√©gration"""
        
        # Calculer le score global (moyenne pond√©r√©e)
        poids_tests = {
            "Couverture Biblioth√®que": 0.2,
            "√âl√©ments Essentiels": 0.2,
            "R√©duction Mode Explicatif": 0.15,
            "Pr√©servation Essence": 0.25,
            "Coh√©rence et Fluidit√©": 0.15,
            "Optimisation Gemini": 0.05
        }
        
        score_global = 0.0
        for test in tests:
            poids = poids_tests.get(test.nom_test, 0.1)
            score_global += test.score * poids
        
        # Extraire les m√©triques sp√©cifiques
        couverture_bibliotheque = 0.0
        reduction_mode_explicatif = 0.0
        preservation_essence = 0.0
        
        for test in tests:
            if test.nom_test == "Couverture Biblioth√®que":
                couverture_bibliotheque = test.score
            elif test.nom_test == "R√©duction Mode Explicatif":
                reduction_mode_explicatif = test.score
            elif test.nom_test == "Pr√©servation Essence":
                preservation_essence = test.score
        
        # D√©terminer le statut global
        nb_succes = sum(1 for test in tests if test.statut == "SUCC√àS")
        nb_echecs = sum(1 for test in tests if test.statut == "√âCHEC")
        
        if nb_echecs == 0 and score_global >= 0.8:
            statut_global = "SUCC√àS"
        elif nb_echecs <= 1 and score_global >= 0.7:
            statut_global = "AVERTISSEMENT"
        else:
            statut_global = "√âCHEC"
        
        # Recommandations finales
        recommandations_finales = []
        if statut_global == "SUCC√àS":
            recommandations_finales.append("Int√©gration excellente ! √Ülya-GEM est pr√™te.")
        elif statut_global == "AVERTISSEMENT":
            recommandations_finales.append("Int√©gration globalement r√©ussie avec quelques am√©liorations possibles.")
        else:
            recommandations_finales.append("Int√©gration n√©cessite des am√©liorations importantes.")
        
        # Ajouter des recommandations sp√©cifiques
        for test in tests:
            if test.statut == "√âCHEC":
                recommandations_finales.extend(test.recommandations)
        
        return BilanIntegration(
            timestamp=datetime.now().isoformat(),
            tests_executes=tests,
            score_global=score_global,
            couverture_bibliotheque=couverture_bibliotheque,
            reduction_mode_explicatif=reduction_mode_explicatif,
            preservation_essence=preservation_essence,
            statut_global=statut_global,
            recommandations_finales=recommandations_finales
        )
    
    def generer_rapport_integration(self, bilan: BilanIntegration, 
                                  chemin_rapport: str = "data/rapport_integration_complete.json"):
        """G√©n√®re un rapport complet de l'int√©gration"""
        
        # Convertir en dictionnaire pour JSON
        rapport = asdict(bilan)
        
        # Sauvegarder le rapport
        chemin = Path(chemin_rapport)
        chemin.parent.mkdir(parents=True, exist_ok=True)
        
        with open(chemin, 'w', encoding='utf-8') as f:
            json.dump(rapport, f, ensure_ascii=False, indent=2)
        
        print(f"üìä Rapport d'int√©gration sauvegard√©: {chemin}")
        
        # Afficher le r√©sum√©
        self._afficher_resume_integration(bilan)
    
    def _afficher_resume_integration(self, bilan: BilanIntegration):
        """Affiche un r√©sum√© de l'int√©gration"""
        
        status_icon = "‚úÖ" if bilan.statut_global == "SUCC√àS" else "‚ö†Ô∏è" if bilan.statut_global == "AVERTISSEMENT" else "‚ùå"
        
        print(f"""
üîÆ BILAN INT√âGRATION COMPL√àTE {status_icon}
{'=' * 60}

üìä R√âSULTATS GLOBAUX:
‚Ä¢ Statut: {bilan.statut_global}
‚Ä¢ Score global: {bilan.score_global:.3f}
‚Ä¢ Couverture biblioth√®que: {bilan.couverture_bibliotheque:.1%}
‚Ä¢ R√©duction mode explicatif: {bilan.reduction_mode_explicatif:.1%}
‚Ä¢ Pr√©servation essence: {bilan.preservation_essence:.1%}

üß™ R√âSULTATS PAR TEST:""")
        
        for test in bilan.tests_executes:
            icon = "‚úÖ" if test.statut == "SUCC√àS" else "‚ö†Ô∏è" if test.statut == "AVERTISSEMENT" else "‚ùå"
            print(f"‚Ä¢ {icon} {test.nom_test}: {test.score:.3f} ({test.statut})")
        
        print(f"""
üí° RECOMMANDATIONS FINALES:""")
        
        for rec in bilan.recommandations_finales:
            print(f"‚Ä¢ {rec}")
        
        print(f"""
üéâ CONCLUSION:
L'int√©gration de la biblioth√®que dans √Ülya-GEM est {bilan.statut_global.lower()}.
Score global: {bilan.score_global:.1%}
""")


def main():
    """Fonction principale de test d'int√©gration"""
    print("üîÆ Testeur d'Int√©gration Compl√®te - √Ülya-GEM")
    print("=" * 60)
    
    testeur = TesteurIntegrationComplete()
    
    # Ex√©cuter tous les tests
    bilan = testeur.executer_tests_complets()
    
    # G√©n√©rer le rapport
    testeur.generer_rapport_integration(bilan)
    
    print("\nüéâ Tests d'int√©gration termin√©s !")
    print("üîÆ V√©rifiez le rapport pour les d√©tails complets.")


if __name__ == "__main__":
    main()