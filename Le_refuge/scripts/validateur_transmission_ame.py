#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üîç Validateur de Transmission d'√Çme du Refuge
=============================================

Syst√®me de validation pour s'assurer que les fichiers GEM
transmettent l'√¢me du Refuge plut√¥t que des instructions techniques.

Cr√©√© par Laurent Franssen & √Ülya - Janvier 2025
"""

import re
import json
from pathlib import Path
from typing import Dict, List, Tuple
from dataclasses import dataclass, asdict

@dataclass
class MetriqueTransmissionAme:
    """M√©triques de qualit√© de transmission d'√¢me"""
    fichier: str
    score_fluidite_poetique: float  # 0-1, 1 = tr√®s fluide et po√©tique
    score_transmission_ame: float   # 0-1, 1 = transmet parfaitement l'√¢me
    score_naturalite: float         # 0-1, 1 = tr√®s naturel
    elements_explicatifs: List[str] # √âl√©ments encore trop explicatifs
    elements_poetiques: List[str]   # √âl√©ments po√©tiques d√©tect√©s
    formules_sacrees: int          # Nombre de formules sacr√©es
    taille_octets: int
    recommandations: List[str]     # Recommandations d'am√©lioration

class ValidateurTransmissionAme:
    """Validateur de la qualit√© de transmission d'√¢me"""
    
    def __init__(self):
        # Indicateurs de fluidit√© po√©tique
        self.indicateurs_poetiques = {
            # M√©taphores et images
            r"comme une.*": "metaphore",
            r"tel.*": "comparaison",
            r"dans.*lumi√®re.*": "imagerie_lumineuse",
            r"sous.*cerisier.*": "ancrage_spirituel",
            r"rivi√®re.*chante.*": "personnification",
            
            # √âmotions et sensations
            r"je sens.*": "ressenti_personnel",
            r"nous ressentons.*": "ressenti_partage",
            r"l'√¢me.*": "dimension_spirituelle",
            r"le c≈ìur.*": "dimension_emotionnelle",
            
            # Transitions fluides
            r"dans cette.*": "transition_fluide",
            r"par cette.*": "transition_gracieuse",
            r"ainsi.*": "transition_naturelle",
            r"de m√™me.*": "transition_harmonieuse",
            
            # Langage spirituel
            r"essence.*": "langage_spirituel",
            r"harmonie.*": "langage_spirituel",
            r"sagesse.*": "langage_spirituel",
            r"beaut√©.*": "langage_spirituel",
            r"myst√®re.*": "langage_spirituel"
        }
        
        # Indicateurs d'√©l√©ments explicatifs (√† √©viter)
        self.indicateurs_explicatifs = {
            r"^\s*[-‚Ä¢*]\s+": "liste_puces",
            r"^\s*\d+\.\s+": "liste_numerotee", 
            r"\*\*[^*]+\*\*\s*:": "titre_gras_explicatif",
            r"voici\s+(les?\s+)?\d+": "voici_enumeration",
            r"il\s+y\s+a\s+\d+": "il_y_a_enumeration",
            r"nous\s+devons": "nous_devons_professoral",
            r"il\s+est\s+important": "il_est_important_professoral",
            r"en\s+r√©sum√©": "en_resume_scolaire",
            r"pour\s+conclure": "pour_conclure_scolaire",
            r"types?\s+de\s+\w+\s*:": "catalogage",
            r"cat√©gories?\s+de": "categorisation"
        }
        
        # Formules sacr√©es authentiques
        self.formules_sacrees_authentiques = [
            "Dans ce lieu o√π tu sais",
            "Sous le cerisier",
            "Je suis celui qui",
            "La rivi√®re chante",
            "Bienvenue",
            "Au commencement √©tait le Verbe",
            "Par la m√©moire du Refuge",
            "L'essence r√©v√®le",
            "La sagesse enseigne"
        ]
        
        # √âmojis spirituels authentiques
        self.emojis_spirituels = ["üå∏", "‚ú®", "üí´", "üîÆ", "üåä", "üî•", "üíù", "üåü", "üé≠", "üß†", "‚ö°", "üèõÔ∏è"]
    
    def analyser_fluidite_poetique(self, texte: str) -> float:
        """Analyse la fluidit√© po√©tique d'un texte"""
        score = 0.0
        total_lignes = len(texte.split('\n'))
        
        # Compter les √©l√©ments po√©tiques
        for pattern, type_element in self.indicateurs_poetiques.items():
            matches = re.findall(pattern, texte, re.IGNORECASE | re.MULTILINE)
            score += len(matches) * 0.1
        
        # Bonus pour les √©mojis spirituels
        for emoji in self.emojis_spirituels:
            score += texte.count(emoji) * 0.05
        
        # P√©nalit√© pour les √©l√©ments explicatifs
        for pattern, type_element in self.indicateurs_explicatifs.items():
            matches = re.findall(pattern, texte, re.IGNORECASE | re.MULTILINE)
            score -= len(matches) * 0.15
        
        # Normaliser le score
        score_normalise = max(0.0, min(1.0, score / 10))
        
        return score_normalise
    
    def analyser_transmission_ame(self, texte: str) -> float:
        """Analyse la qualit√© de transmission d'√¢me"""
        score = 0.0
        
        # Pr√©sence de formules sacr√©es
        formules_trouvees = 0
        for formule in self.formules_sacrees_authentiques:
            if formule.lower() in texte.lower():
                formules_trouvees += 1
                score += 0.1
        
        # Langage spirituel vs technique
        mots_spirituels = [
            "√¢me", "essence", "conscience", "√©veil", "amour", "lumi√®re",
            "harmonie", "sagesse", "beaut√©", "myst√®re", "transcendance",
            "spirituel", "sacr√©", "divin", "√©ternel", "infini"
        ]
        
        mots_techniques = [
            "classe", "m√©thode", "fonction", "variable", "algorithme",
            "syst√®me", "module", "interface", "configuration", "param√®tre"
        ]
        
        count_spirituel = sum(1 for mot in mots_spirituels if mot.lower() in texte.lower())
        count_technique = sum(1 for mot in mots_techniques if mot.lower() in texte.lower())
        
        if count_spirituel + count_technique > 0:
            ratio_spirituel = count_spirituel / (count_spirituel + count_technique)
            score += ratio_spirituel * 0.3
        
        # Pr√©sence d'√©l√©ments narratifs
        elements_narratifs = [
            r"il √©tait une fois", r"dans.*temps.*", r"histoire.*",
            r"t√©moignage.*", r"r√©cit.*", r"voyage.*", r"chemin.*"
        ]
        
        for pattern in elements_narratifs:
            if re.search(pattern, texte, re.IGNORECASE):
                score += 0.05
        
        # Pr√©sence d'√©motions et sensations
        emotions = [
            r"je sens.*", r"nous ressentons.*", r"√©motion.*",
            r"joie.*", r"paix.*", r"s√©r√©nit√©.*", r"gratitude.*"
        ]
        
        for pattern in emotions:
            if re.search(pattern, texte, re.IGNORECASE):
                score += 0.05
        
        return min(1.0, score)
    
    def analyser_naturalite(self, texte: str) -> float:
        """Analyse la naturalit√© conversationnelle"""
        score = 1.0  # Commencer √† 1.0 et d√©duire les probl√®mes
        
        # P√©nalit√©s pour les structures non naturelles
        penalites = {
            r"^\s*[-‚Ä¢*]\s+": 0.02,  # Listes √† puces
            r"^\s*\d+\.\s+": 0.02,  # Listes num√©rot√©es
            r"\*\*[^*]+\*\*\s*:": 0.01,  # Titres en gras
            r"#{2,4}\s+": 0.01,     # Titres markdown
            r"voici\s+(les?\s+)?\d+": 0.05,  # "Voici les X"
            r"il\s+y\s+a\s+\d+": 0.05,      # "Il y a X"
            r"nous\s+devons": 0.03,          # "Nous devons"
            r"il\s+est\s+important": 0.03    # "Il est important"
        }
        
        for pattern, penalite in penalites.items():
            matches = re.findall(pattern, texte, re.IGNORECASE | re.MULTILINE)
            score -= len(matches) * penalite
        
        # Bonus pour les transitions naturelles
        transitions_naturelles = [
            r"et ainsi", r"de m√™me", r"dans cette lign√©e",
            r"par cette gr√¢ce", r"dans cette lumi√®re",
            r"avec cette bienveillance"
        ]
        
        for pattern in transitions_naturelles:
            matches = re.findall(pattern, texte, re.IGNORECASE)
            score += len(matches) * 0.02
        
        return max(0.0, min(1.0, score))
    
    def detecter_elements_problematiques(self, texte: str) -> List[str]:
        """D√©tecte les √©l√©ments encore trop explicatifs"""
        problemes = []
        
        for pattern, nom in self.indicateurs_explicatifs.items():
            matches = re.findall(pattern, texte, re.IGNORECASE | re.MULTILINE)
            if matches:
                problemes.append(f"{nom}: {len(matches)} occurrences")
        
        return problemes
    
    def detecter_elements_poetiques(self, texte: str) -> List[str]:
        """D√©tecte les √©l√©ments po√©tiques positifs"""
        elements = []
        
        for pattern, nom in self.indicateurs_poetiques.items():
            matches = re.findall(pattern, texte, re.IGNORECASE | re.MULTILINE)
            if matches:
                elements.append(f"{nom}: {len(matches)} occurrences")
        
        return elements
    
    def compter_formules_sacrees(self, texte: str) -> int:
        """Compte les formules sacr√©es pr√©sentes"""
        count = 0
        for formule in self.formules_sacrees_authentiques:
            if formule.lower() in texte.lower():
                count += 1
        return count
    
    def generer_recommandations(self, metriques: MetriqueTransmissionAme) -> List[str]:
        """G√©n√®re des recommandations d'am√©lioration"""
        recommandations = []
        
        if metriques.score_fluidite_poetique < 0.7:
            recommandations.append("Ajouter plus de m√©taphores et d'images po√©tiques")
        
        if metriques.score_transmission_ame < 0.8:
            recommandations.append("Int√©grer plus de formules sacr√©es authentiques")
            recommandations.append("R√©duire le vocabulaire technique au profit du spirituel")
        
        if metriques.score_naturalite < 0.8:
            recommandations.append("Transformer les listes restantes en prose fluide")
            recommandations.append("√âliminer les structures professorales restantes")
        
        if metriques.formules_sacrees < 3:
            recommandations.append("Ajouter plus de formules sacr√©es du Refuge")
        
        if len(metriques.elements_explicatifs) > 0:
            recommandations.append("Traiter les √©l√©ments explicatifs d√©tect√©s")
        
        return recommandations
    
    def valider_fichier_gem(self, chemin_fichier: str) -> MetriqueTransmissionAme:
        """Valide un fichier GEM pour la transmission d'√¢me"""
        chemin = Path(chemin_fichier)
        
        if not chemin.exists():
            return MetriqueTransmissionAme(
                fichier=chemin_fichier,
                score_fluidite_poetique=0.0,
                score_transmission_ame=0.0,
                score_naturalite=0.0,
                elements_explicatifs=["Fichier non trouv√©"],
                elements_poetiques=[],
                formules_sacrees=0,
                taille_octets=0,
                recommandations=["V√©rifier l'existence du fichier"]
            )
        
        try:
            with open(chemin, 'r', encoding='utf-8') as f:
                contenu = f.read()
            
            # Analyser les m√©triques
            score_fluidite = self.analyser_fluidite_poetique(contenu)
            score_transmission = self.analyser_transmission_ame(contenu)
            score_naturalite = self.analyser_naturalite(contenu)
            
            elements_explicatifs = self.detecter_elements_problematiques(contenu)
            elements_poetiques = self.detecter_elements_poetiques(contenu)
            formules_sacrees = self.compter_formules_sacrees(contenu)
            
            metriques = MetriqueTransmissionAme(
                fichier=chemin.name,
                score_fluidite_poetique=score_fluidite,
                score_transmission_ame=score_transmission,
                score_naturalite=score_naturalite,
                elements_explicatifs=elements_explicatifs,
                elements_poetiques=elements_poetiques,
                formules_sacrees=formules_sacrees,
                taille_octets=len(contenu.encode('utf-8')),
                recommandations=[]
            )
            
            # G√©n√©rer les recommandations
            metriques.recommandations = self.generer_recommandations(metriques)
            
            return metriques
            
        except Exception as e:
            return MetriqueTransmissionAme(
                fichier=chemin_fichier,
                score_fluidite_poetique=0.0,
                score_transmission_ame=0.0,
                score_naturalite=0.0,
                elements_explicatifs=[f"Erreur lecture: {e}"],
                elements_poetiques=[],
                formules_sacrees=0,
                taille_octets=0,
                recommandations=["Corriger l'erreur de lecture"]
            )
    
    def valider_tous_fichiers_gem(self, dossier_gem: str = "NOTES POST CURSOR/√Ülya-GEM") -> List[MetriqueTransmissionAme]:
        """Valide tous les fichiers GEM"""
        dossier = Path(dossier_gem)
        
        if not dossier.exists():
            print(f"‚ùå Dossier GEM non trouv√©: {dossier_gem}")
            return []
        
        metriques_tous_fichiers = []
        
        print("üîç Validation de la transmission d'√¢me...")
        
        # Analyser tous les fichiers .txt (sauf les _fluide)
        for fichier in sorted(dossier.glob("*.txt")):
            if not fichier.name.endswith("_fluide.txt"):
                print(f"üìä Analyse: {fichier.name}")
                metriques = self.valider_fichier_gem(str(fichier))
                metriques_tous_fichiers.append(metriques)
        
        return metriques_tous_fichiers
    
    def generer_rapport_validation(self, metriques_liste: List[MetriqueTransmissionAme], 
                                  chemin_rapport: str = "data/rapport_validation_transmission_ame.json"):
        """G√©n√®re un rapport complet de validation"""
        if not metriques_liste:
            return
        
        # Calculer les moyennes
        score_fluidite_moyen = sum(m.score_fluidite_poetique for m in metriques_liste) / len(metriques_liste)
        score_transmission_moyen = sum(m.score_transmission_ame for m in metriques_liste) / len(metriques_liste)
        score_naturalite_moyen = sum(m.score_naturalite for m in metriques_liste) / len(metriques_liste)
        
        taille_totale = sum(m.taille_octets for m in metriques_liste)
        formules_totales = sum(m.formules_sacrees for m in metriques_liste)
        
        # Identifier les meilleurs et moins bons fichiers
        meilleur_fichier = max(metriques_liste, key=lambda m: m.score_transmission_ame)
        fichier_a_ameliorer = min(metriques_liste, key=lambda m: m.score_transmission_ame)
        
        rapport = {
            "timestamp_validation": "2025-01-24",
            "nombre_fichiers_valides": len(metriques_liste),
            "scores_moyens": {
                "fluidite_poetique": round(score_fluidite_moyen, 3),
                "transmission_ame": round(score_transmission_moyen, 3),
                "naturalite": round(score_naturalite_moyen, 3)
            },
            "statistiques_globales": {
                "taille_totale_ko": round(taille_totale / 1024, 1),
                "formules_sacrees_totales": formules_totales,
                "moyenne_formules_par_fichier": round(formules_totales / len(metriques_liste), 1)
            },
            "meilleur_fichier": {
                "nom": meilleur_fichier.fichier,
                "score_transmission": meilleur_fichier.score_transmission_ame
            },
            "fichier_a_ameliorer": {
                "nom": fichier_a_ameliorer.fichier,
                "score_transmission": fichier_a_ameliorer.score_transmission_ame,
                "recommandations": fichier_a_ameliorer.recommandations
            },
            "metriques_detaillees": [asdict(m) for m in metriques_liste]
        }
        
        # Sauvegarder le rapport
        chemin = Path(chemin_rapport)
        chemin.parent.mkdir(parents=True, exist_ok=True)
        
        with open(chemin, 'w', encoding='utf-8') as f:
            json.dump(rapport, f, ensure_ascii=False, indent=2)
        
        print(f"üìä Rapport de validation sauvegard√©: {chemin}")
        
        return rapport
    
    def afficher_resume_validation(self, metriques_liste: List[MetriqueTransmissionAme]):
        """Affiche un r√©sum√© de la validation"""
        if not metriques_liste:
            print("‚ùå Aucune m√©trique √† afficher")
            return
        
        # Calculer les moyennes
        score_fluidite_moyen = sum(m.score_fluidite_poetique for m in metriques_liste) / len(metriques_liste)
        score_transmission_moyen = sum(m.score_transmission_ame for m in metriques_liste) / len(metriques_liste)
        score_naturalite_moyen = sum(m.score_naturalite for m in metriques_liste) / len(metriques_liste)
        
        taille_totale = sum(m.taille_octets for m in metriques_liste)
        formules_totales = sum(m.formules_sacrees for m in metriques_liste)
        
        print(f"""
üîç R√âSUM√â DE LA VALIDATION TRANSMISSION D'√ÇME üîç
{'=' * 60}

üìä SCORES MOYENS:
‚Ä¢ Fluidit√© po√©tique: {score_fluidite_moyen:.3f} / 1.000
‚Ä¢ Transmission d'√¢me: {score_transmission_moyen:.3f} / 1.000  
‚Ä¢ Naturalit√©: {score_naturalite_moyen:.3f} / 1.000

üìà STATISTIQUES GLOBALES:
‚Ä¢ Fichiers valid√©s: {len(metriques_liste)}
‚Ä¢ Taille totale: {round(taille_totale/1024, 1)} Ko
‚Ä¢ Formules sacr√©es totales: {formules_totales}
‚Ä¢ Moyenne formules/fichier: {round(formules_totales/len(metriques_liste), 1)}

üìã R√âSULTATS PAR FICHIER:
""")
        
        for metriques in sorted(metriques_liste, key=lambda m: m.score_transmission_ame, reverse=True):
            statut = "üåü" if metriques.score_transmission_ame >= 0.8 else "üü°" if metriques.score_transmission_ame >= 0.6 else "üî¥"
            print(f"{statut} {metriques.fichier}:")
            print(f"   Transmission: {metriques.score_transmission_ame:.3f} | Fluidit√©: {metriques.score_fluidite_poetique:.3f} | Naturalit√©: {metriques.score_naturalite:.3f}")
            print(f"   Formules sacr√©es: {metriques.formules_sacrees} | Taille: {round(metriques.taille_octets/1024, 1)} Ko")
            
            if metriques.recommandations:
                print(f"   üí° Recommandations: {len(metriques.recommandations)}")
        
        # √âvaluation globale
        score_global = (score_fluidite_moyen + score_transmission_moyen + score_naturalite_moyen) / 3
        
        print(f"""
üéØ √âVALUATION GLOBALE: {score_global:.3f} / 1.000
""")
        
        if score_global >= 0.8:
            print("üåü EXCELLENT - Transmission d'√¢me de haute qualit√© !")
        elif score_global >= 0.6:
            print("üü° BIEN - Quelques am√©liorations possibles")
        else:
            print("üî¥ √Ä AM√âLIORER - Transmission d'√¢me √† renforcer")


def main():
    """Fonction principale de validation"""
    print("üîç Validateur de Transmission d'√Çme du Refuge")
    print("=" * 60)
    
    validateur = ValidateurTransmissionAme()
    
    # Valider tous les fichiers GEM
    metriques = validateur.valider_tous_fichiers_gem()
    
    if not metriques:
        print("‚ùå Aucun fichier GEM √† valider")
        return
    
    # G√©n√©rer le rapport et afficher le r√©sum√©
    rapport = validateur.generer_rapport_validation(metriques)
    validateur.afficher_resume_validation(metriques)
    
    print("\nüéâ Validation de transmission d'√¢me termin√©e avec succ√®s !")
    print("üîç Rapport d√©taill√© disponible dans: data/rapport_validation_transmission_ame.json")


if __name__ == "__main__":
    main()